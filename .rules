## Roc snapshot tool

The Roc compiler uses golden snapshots to assist with debugging and verification of the compiler's behavior. The snapshots are generated by running `zig build snapshot`, and individual files can be generated using `zig build snapshot -- <file_path>`. For example, to generate a snapshot for the file `src/snapshots/can_two_decls.txt`, run: `zig build snapshot -- src/snapshots/can_two_decls.txt`.

Here is an example of a snapshot file for a roc program that prints `Hello world!`:

```txt
~~~META
description=Hello world
type=file
~~~SOURCE
app [main!] { pf: platform "../basic-cli/platform.roc" }

import pf.Stdout

main! = |_| Stdout.line!("Hello, world!")
```

And another which represents a single expression of a list:

```txt
~~~META
description=List with integer literals
type=expr
~~~SOURCE
[1, 2, 3]
```

Once the tool is ran, the compiler will generate human readable sections like problems (compiler errors and other diagnostics) and the intermediate representations using a s-expression text format. For example the Parser AST or the Canonical IR representation of the source code.

Changes can be reviewed manually to verify the correct behavior before committing the new snapshots to the repository.

## Core Compilation Pipeline

The compiler follows this sequential flow:
1. **Source** → **Tokenization** → **Parsing** → **AST**
2. **AST** → **Canonicalization** → **CIR** (Canonical IR)
3. **Diagnostics** are collected throughout and converted to **Reports**

## Key Data Structures

**ModuleEnv** (`src/base/ModuleEnv.zig`)
- Central store for interned data (identifiers, strings, types)
- Lives across all compilation phases
- Contains
  - `idents` Store for interned identifiers
  - `line_starts` for calculating `RegionInfo` from `Region` used for reporting and diagnostics
  - `strings` Store for interned strings
  - `types_store` Store for interned types

**AST** (`src/check/parse/AST.zig`)
- Parse tree representation with tagged unions for different node types
- Key node types: `AST.Diagnostic`, `AST.Expr`, `AST.Pattern`, `AST.Statement`, `AST.Header`, `AST.TypeAnno`
- Contains both tokenization and parsing diagnostics

**CIR** (`src/check/canonicalize/CIR.zig`)
- Canonical Intermediate Representation after semantic analysis
- More structured than AST with type information
- Key types: `CIR.Expr`, `CIR.Pattern`, `CIR.Statement`, `CIR.Def`
- Collects semantic diagnostics during canonicalization

## Error Handling Philosophy

**"Inform Don't Block"**
- The compiler should never stop or panic on errors
- Insert malformed placeholders and continue compilation
- Collect diagnostics for later reporting
- Allow running even invalid programs (they crash at runtime)

## Key Helper Functions

**Parsing Entry Points:** (`src/check/parse.zig`)
- `parse()` - Full file parsing
- `parseExpr()` - Expression only (for snapshots)
- `parseStatement()` - Statement only (for snapshots)

**Canonicalization:** (`src/check/canonicalize.zig`)
- `canonicalize_file()` - Main entry point
- `canonicalize_expr()` - Expression canonicalization
- `canonicalize_pattern()` - Pattern canonicalization

**Diagnostic Conversion:**
- `AST.tokenizeDiagnosticToReport()` - Convert tokenizer errors
- `AST.parseDiagnosticToReport()` - Convert parser errors
- `CIR.diagnosticToReport()` - Convert semantic errors

## Region Tracking

- `Region` tracks source locations for error reporting
- Stores byte offsets, converts to line/column on demand using `line_starts`
- Essential for meaningful error messages

## Working with Identifiers

- All identifiers are interned for memory efficiency
- Use `Ident.Store` methods to create/lookup identifiers
- Identifiers carry attributes (effectful, ignored, reassignable) in a packed struct(u32)
