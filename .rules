## Roc snapshot tool

The Roc compiler uses golden snapshots to assist with debugging and verification of the compiler's behavior. The snapshots are generated by running `zig build snapshot`, and individual files can be generated using `zig build snapshot -- <file_path>`. For example, to generate a snapshot for the file `src/snapshots/can_two_decls.txt`, run: `zig build snapshot -- src/snapshots/can_two_decls.txt`.

Here is an example of a snapshot file for a roc program that prints `Hello world!`:

```txt
~~~META
description=Hello world
type=file
~~~SOURCE
app [main!] { pf: platform "../basic-cli/platform.roc" }

import pf.Stdout

main! = |_| Stdout.line!("Hello, world!")
```

And another which represents a single expression of a list:

```txt
~~~META
description=List with integer literals
type=expr
~~~SOURCE
[1, 2, 3]
```

Once the tool is ran, the compiler will generate human readable sections like problems (compiler errors and other diagnostics) and the intermediate representations using a s-expression text format. For example the Parser AST or the Canonical IR representation of the source code.

Changes can be reviewed manually to verify the correct behavior before committing the new snapshots to the repository.

## Core Compilation Pipeline

The compiler follows this sequential flow:
1. **Source** → **Tokenization** → **Parsing** → **AST**
2. **AST** → **Canonicalization** → **CIR** (Canonical IR)
3. **Diagnostics** are collected throughout and converted to **Reports**

## Key Data Structures

**ModuleEnv** (`src/base/ModuleEnv.zig`)
- Central store for interned data (identifiers, strings, types)
- Lives across all compilation phases
- Contains
  - `idents` Store for interned identifiers
  - `line_starts` for calculating `RegionInfo` from `Region` used for reporting and diagnostics
  - `strings` Store for interned strings
  - `types_store` Store for interned types

**AST** (`src/check/parse/AST.zig`)
- Parse tree representation with tagged unions for different node types
- Key node types: `AST.Diagnostic`, `AST.Expr`, `AST.Pattern`, `AST.Statement`, `AST.Header`, `AST.TypeAnno`
- Contains both tokenization and parsing diagnostics

**CIR** (`src/check/canonicalize/CIR.zig`)
- Canonical Intermediate Representation after semantic analysis
- More structured than AST with type information
- Key types: `CIR.Expr`, `CIR.Pattern`, `CIR.Statement`, `CIR.Def`
- Collects semantic diagnostics during canonicalization

## Error Handling Philosophy

**"Inform Don't Block"**
- The compiler should never stop or panic on errors
- Insert malformed placeholders and continue compilation
- Collect diagnostics for later reporting
- Allow running even invalid programs (they crash at runtime)

## Key Helper Functions

**Parsing Entry Points:** (`src/check/parse.zig`)
- `parse()` - Full file parsing
- `parseExpr()` - Expression only (for snapshots)
- `parseStatement()` - Statement only (for snapshots)

**Canonicalization:** (`src/check/canonicalize.zig`)
- `canonicalize_file()` - Main entry point
- `canonicalize_expr()` - Expression canonicalization
- `canonicalize_pattern()` - Pattern canonicalization

**Diagnostic Conversion:**
- `AST.tokenizeDiagnosticToReport()` - Convert tokenizer errors
- `AST.parseDiagnosticToReport()` - Convert parser errors
- `CIR.diagnosticToReport()` - Convert semantic errors

## Region Tracking

- `Region` tracks source locations for error reporting
- Stores byte offsets, converts to line/column on demand using `line_starts`
- Essential for meaningful error messages

## Working with Identifiers

- All identifiers are interned for memory efficiency
- Use `Ident.Store` methods to create/lookup identifiers
- Identifiers carry attributes (effectful, ignored, reassignable) in a packed struct(u32)

# Roc version 0.1 Syntax Guide

Here is a comprehensive description of Roc version 0.1 syntax to assist with writing and understanding `.roc` code.

## Module Structure

```roc
# A `app` module header using the basic-cli platform
app [main!] { pf: platform "../basic-cli/platform.roc" }

# A standard module header exposing the `add` function
module [add]
```

## Import System

```roc
import pf.Stdout exposing [line!, write!]
import pkg.Something exposing [func as function, Type as ValueCategory, Custom.*]
import BadName as GoodName
```

**Import**
- `import cli.Foo` - Basic import of the `Foo` module from the `cli` package

## Type Annotations and Declarations

```roc
Map(a, b) : List(a), (a -> b) -> List(b)
Maybe(a) : [Some(a), None]
Some(a) : { foo : Ok(a), bar : Something }
```

**Type Syntax:**
- **Generic Type Parameters**: `(a, b)` after type name
- **Function Types**: `a -> b` (single arrow)
- **Tag Unions**: `[Tag1(args), Tag2, Tag3(more)]`
- **Records**: `{ field : Type, another : Type }`
- **Tuples**: `(Type1, Type2, Type3)`

## Function Definitions

```roc
add_one : U64 -> U64
add_one = |num| {
    other = 1
    if num {
        dbg some_func()
        0
    } else {
        dbg 123
        other
    }
}
```

**Function Patterns:**
- **Lambda Syntax**: `|args| body`
- **Multiline Args**: Vertical pipe, comma separated
- **Block Bodies**: `{ statements }` uses braces, statements followed by final expression
- **Pure Functions**: `add` snake_case ident
- **Effectful Functions**: `print!` exclamation mark suffix

**Pattern Types:**
- **Tag Patterns**: `Ok(value)`, `Some(inner)`
- **Literal Patterns**: `"foo"`, `123`, `3.14`
- **List Patterns**: `[1, 2, 3, .. as rest]` (rest pattern)
- **Tuple Patterns**: `(1, 2, 3)`
- **Record Patterns**: `{ foo: 1, bar: 2, ..rest }`
- **Anonymous Tag Unions**: `[Blue U8 | Green U32 | Red I64]`
- **Nested Patterns**: `Ok(Some(dude))`

## Control Flow

```roc
if condition {
    then_branch
} else {
    else_branch
}

for n in list {
    Stdout.line!("Adding ${n} to ${number}")
    number = number + n
}

return tag
```

**Control Constructs:**
- **If-Else**: Block-based with `{ }`
- **For Loops**: `for item in collection { body }`
- **Return**: Early return from functions
- **Crash**: `crash "message"` for unrecoverable errors

## Data Structures

```roc
list = [item1, item2, item3]
record = { foo: 123, bar: "Hello", baz: tag, punned }
tuple = (123, "World", tag, Ok(world))
```

**Collection Syntax:**
- **Lists**: `[item1, item2, item3]`
- **Records**: `{ field: value, punned }` (punning supported)
- **Tuples**: `(value1, value2, value3)`
- **Empty Record**: `{}`

## Variables and Assignment

```roc
world = "World"
var number_ = 123 # Variables are re-assignable, must have trailing underscore
number = number + n  # Reassignment
```

**Variable Patterns:**
- **Immutable**: `name = value`
- **Semantically Mutability**: `var name = value`, re-assignment, cannot cross function/lambda boundaries

## Operators and Expressions

```roc
bin_op_result = Err(foo) ?? 12 > 5 * 5 or 13 + 2 < 5 and 10 - 1 >= 16
static_dispatch_style = some_fn(arg1)?.method()?.next_method()?.field?
```

**Operator Types:**
- **Arithmetic**: `+`, `-`, `*`, `/`
- **Comparison**: `>`, `<`, `>=`, `<=`, `==`
- **Logical**: `and`, `or`
- **Default Value**: `??`
- **Optional Chaining**: `?.` returns early if Result is Err

## String Interpolation

```roc
interpolated = "Hello, ${world}"
"How about ${Num.toStr(number)} as a string?"
```

## Special Constructs

```roc
dbg some_func()  # Debug output
expect blah == 1  # Inline assertion
...              # Placeholder/ellipsis, valid syntax, compiles to runtime error
```

## Comments

```roc
# Line comment
```

## Type System Features

```roc
SomeFunc(a) : Maybe(a), a -> Maybe(a)  # Multiple parameters/returns
_  # Wildcard/placeholder type
```

**Advanced Types:**
- **Multiple Parameters**: Comma-separated before `:`
- **Wildcards**: `_` for inferred types
- **Parametric Types**: Generic type parameters in parentheses

This syntax emphasizes readability, strong typing, and functional programming patterns while maintaining familiar imperative constructs where needed.
