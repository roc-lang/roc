// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_ReadErr {
    Interrupted = 0,
    InvalidFilename = 1,
    NotFound = 2,
    OutOfMemory = 3,
    PermissionDenied = 4,
    StaleNetworkFileHandle = 5,
    TimedOut = 6,
    TooManyHardlinks = 7,
    TooManySymlinks = 8,
    Unrecognized = 9,
    Unsupported = 10,
}

impl core::fmt::Debug for discriminant_ReadErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Interrupted => f.write_str("discriminant_ReadErr::Interrupted"),
            Self::InvalidFilename => f.write_str("discriminant_ReadErr::InvalidFilename"),
            Self::NotFound => f.write_str("discriminant_ReadErr::NotFound"),
            Self::OutOfMemory => f.write_str("discriminant_ReadErr::OutOfMemory"),
            Self::PermissionDenied => f.write_str("discriminant_ReadErr::PermissionDenied"),
            Self::StaleNetworkFileHandle => f.write_str("discriminant_ReadErr::StaleNetworkFileHandle"),
            Self::TimedOut => f.write_str("discriminant_ReadErr::TimedOut"),
            Self::TooManyHardlinks => f.write_str("discriminant_ReadErr::TooManyHardlinks"),
            Self::TooManySymlinks => f.write_str("discriminant_ReadErr::TooManySymlinks"),
            Self::Unrecognized => f.write_str("discriminant_ReadErr::Unrecognized"),
            Self::Unsupported => f.write_str("discriminant_ReadErr::Unsupported"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
pub union ReadErr {
    Unrecognized: core::mem::ManuallyDrop<ReadErr_Unrecognized>,
    _sizer: [u8; 20],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct ReadErr_Unrecognized {
    pub f0: i32,
    pub f1: roc_std::RocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_WriteErr {
    AlreadyExists = 0,
    ExecutableFileBusy = 1,
    FileTooLarge = 2,
    FilesystemQuotaExceeded = 3,
    Interrupted = 4,
    InvalidFilename = 5,
    NotFound = 6,
    OutOfMemory = 7,
    PermissionDenied = 8,
    ReadOnlyFilesystem = 9,
    ResourceBusy = 10,
    StaleNetworkFileHandle = 11,
    StorageFull = 12,
    TimedOut = 13,
    TooManyHardlinks = 14,
    TooManySymlinks = 15,
    Unrecognized = 16,
    Unsupported = 17,
    WasADirectory = 18,
    WriteZero = 19,
}

impl core::fmt::Debug for discriminant_WriteErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::AlreadyExists => f.write_str("discriminant_WriteErr::AlreadyExists"),
            Self::ExecutableFileBusy => f.write_str("discriminant_WriteErr::ExecutableFileBusy"),
            Self::FileTooLarge => f.write_str("discriminant_WriteErr::FileTooLarge"),
            Self::FilesystemQuotaExceeded => f.write_str("discriminant_WriteErr::FilesystemQuotaExceeded"),
            Self::Interrupted => f.write_str("discriminant_WriteErr::Interrupted"),
            Self::InvalidFilename => f.write_str("discriminant_WriteErr::InvalidFilename"),
            Self::NotFound => f.write_str("discriminant_WriteErr::NotFound"),
            Self::OutOfMemory => f.write_str("discriminant_WriteErr::OutOfMemory"),
            Self::PermissionDenied => f.write_str("discriminant_WriteErr::PermissionDenied"),
            Self::ReadOnlyFilesystem => f.write_str("discriminant_WriteErr::ReadOnlyFilesystem"),
            Self::ResourceBusy => f.write_str("discriminant_WriteErr::ResourceBusy"),
            Self::StaleNetworkFileHandle => f.write_str("discriminant_WriteErr::StaleNetworkFileHandle"),
            Self::StorageFull => f.write_str("discriminant_WriteErr::StorageFull"),
            Self::TimedOut => f.write_str("discriminant_WriteErr::TimedOut"),
            Self::TooManyHardlinks => f.write_str("discriminant_WriteErr::TooManyHardlinks"),
            Self::TooManySymlinks => f.write_str("discriminant_WriteErr::TooManySymlinks"),
            Self::Unrecognized => f.write_str("discriminant_WriteErr::Unrecognized"),
            Self::Unsupported => f.write_str("discriminant_WriteErr::Unsupported"),
            Self::WasADirectory => f.write_str("discriminant_WriteErr::WasADirectory"),
            Self::WriteZero => f.write_str("discriminant_WriteErr::WriteZero"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
pub union WriteErr {
    Unrecognized: core::mem::ManuallyDrop<WriteErr_Unrecognized>,
    _sizer: [u8; 20],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct WriteErr_Unrecognized {
    pub f0: i32,
    pub f1: roc_std::RocStr,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union ReadErr {
    Unrecognized: core::mem::ManuallyDrop<ReadErr_Unrecognized>,
    _sizer: [u8; 40],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct ReadErr_Unrecognized {
    pub f1: roc_std::RocStr,
    pub f0: i32,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union WriteErr {
    Unrecognized: core::mem::ManuallyDrop<WriteErr_Unrecognized>,
    _sizer: [u8; 40],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct WriteErr_Unrecognized {
    pub f1: roc_std::RocStr,
    pub f0: i32,
}

impl ReadErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ReadErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ReadErr>(*bytes.as_ptr().add(16))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ReadErr) {
        let discriminant_ptr: *mut discriminant_ReadErr = (self as *mut ReadErr).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Interrupted, which has no payload.
    pub const Interrupted: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[16] = discriminant_ReadErr::Interrupted as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Interrupted tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Interrupted(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Interrupted tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Interrupted(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named InvalidFilename, which has no payload.
    pub const InvalidFilename: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[16] = discriminant_ReadErr::InvalidFilename as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the InvalidFilename tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_InvalidFilename(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the InvalidFilename tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_InvalidFilename(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named NotFound, which has no payload.
    pub const NotFound: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[16] = discriminant_ReadErr::NotFound as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the NotFound tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_NotFound(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the NotFound tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_NotFound(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named OutOfMemory, which has no payload.
    pub const OutOfMemory: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[16] = discriminant_ReadErr::OutOfMemory as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the OutOfMemory tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_OutOfMemory(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the OutOfMemory tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_OutOfMemory(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named PermissionDenied, which has no payload.
    pub const PermissionDenied: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[16] = discriminant_ReadErr::PermissionDenied as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the PermissionDenied tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_PermissionDenied(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the PermissionDenied tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_PermissionDenied(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named StaleNetworkFileHandle, which has no payload.
    pub const StaleNetworkFileHandle: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[16] = discriminant_ReadErr::StaleNetworkFileHandle as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the StaleNetworkFileHandle tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_StaleNetworkFileHandle(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the StaleNetworkFileHandle tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_StaleNetworkFileHandle(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named TimedOut, which has no payload.
    pub const TimedOut: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[16] = discriminant_ReadErr::TimedOut as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the TimedOut tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_TimedOut(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the TimedOut tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_TimedOut(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named TooManyHardlinks, which has no payload.
    pub const TooManyHardlinks: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[16] = discriminant_ReadErr::TooManyHardlinks as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the TooManyHardlinks tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_TooManyHardlinks(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the TooManyHardlinks tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_TooManyHardlinks(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named TooManySymlinks, which has no payload.
    pub const TooManySymlinks: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[16] = discriminant_ReadErr::TooManySymlinks as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the TooManySymlinks tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_TooManySymlinks(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the TooManySymlinks tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_TooManySymlinks(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Unrecognized`, with the appropriate payload
    pub fn Unrecognized(arg0: i32, arg1: roc_std::RocStr) -> Self {
            let mut answer = Self {
                Unrecognized: core::mem::ManuallyDrop::new(ReadErr_Unrecognized {
                    f0: arg0,
                    f1: arg1,
                })
            };

            answer.set_discriminant(discriminant_ReadErr::Unrecognized);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `ReadErr` has a `.discriminant()` of `Unrecognized` and convert it to `Unrecognized`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Unrecognized`.
            pub unsafe fn into_Unrecognized(mut self) -> (i32, roc_std::RocStr) {
                debug_assert_eq!(self.discriminant(), discriminant_ReadErr::Unrecognized);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Unrecognized,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `ReadErr` has a `.discriminant()` of `Unrecognized` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Unrecognized`.
            pub unsafe fn as_Unrecognized(&self) -> (&i32, &roc_std::RocStr) {
                debug_assert_eq!(self.discriminant(), discriminant_ReadErr::Unrecognized);
        let payload = &self.Unrecognized;

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Unsupported, which has no payload.
    pub const Unsupported: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[16] = discriminant_ReadErr::Unsupported as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Unsupported tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Unsupported(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Unsupported tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Unsupported(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ReadErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ReadErr>(*bytes.as_ptr().add(32))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ReadErr) {
        let discriminant_ptr: *mut discriminant_ReadErr = (self as *mut ReadErr).cast();

        unsafe {
            *(discriminant_ptr.add(32)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Interrupted, which has no payload.
    pub const Interrupted: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[32] = discriminant_ReadErr::Interrupted as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named InvalidFilename, which has no payload.
    pub const InvalidFilename: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[32] = discriminant_ReadErr::InvalidFilename as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named NotFound, which has no payload.
    pub const NotFound: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[32] = discriminant_ReadErr::NotFound as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named OutOfMemory, which has no payload.
    pub const OutOfMemory: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[32] = discriminant_ReadErr::OutOfMemory as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named PermissionDenied, which has no payload.
    pub const PermissionDenied: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[32] = discriminant_ReadErr::PermissionDenied as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named StaleNetworkFileHandle, which has no payload.
    pub const StaleNetworkFileHandle: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[32] = discriminant_ReadErr::StaleNetworkFileHandle as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named TimedOut, which has no payload.
    pub const TimedOut: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[32] = discriminant_ReadErr::TimedOut as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named TooManyHardlinks, which has no payload.
    pub const TooManyHardlinks: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[32] = discriminant_ReadErr::TooManyHardlinks as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named TooManySymlinks, which has no payload.
    pub const TooManySymlinks: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[32] = discriminant_ReadErr::TooManySymlinks as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Unsupported, which has no payload.
    pub const Unsupported: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ReadErr>()];

        bytes[32] = discriminant_ReadErr::Unsupported as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ReadErr>()], ReadErr>(bytes)
    };
}

impl Drop for ReadErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
                    match self.discriminant() {
                discriminant_ReadErr::Interrupted => {}
                discriminant_ReadErr::InvalidFilename => {}
                discriminant_ReadErr::NotFound => {}
                discriminant_ReadErr::OutOfMemory => {}
                discriminant_ReadErr::PermissionDenied => {}
                discriminant_ReadErr::StaleNetworkFileHandle => {}
                discriminant_ReadErr::TimedOut => {}
                discriminant_ReadErr::TooManyHardlinks => {}
                discriminant_ReadErr::TooManySymlinks => {}
                discriminant_ReadErr::Unrecognized => unsafe { core::mem::ManuallyDrop::drop(&mut self.Unrecognized) },
                discriminant_ReadErr::Unsupported => {}
            }

    }
}

impl Eq for ReadErr {}

impl PartialEq for ReadErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_ReadErr::Interrupted => true,
                discriminant_ReadErr::InvalidFilename => true,
                discriminant_ReadErr::NotFound => true,
                discriminant_ReadErr::OutOfMemory => true,
                discriminant_ReadErr::PermissionDenied => true,
                discriminant_ReadErr::StaleNetworkFileHandle => true,
                discriminant_ReadErr::TimedOut => true,
                discriminant_ReadErr::TooManyHardlinks => true,
                discriminant_ReadErr::TooManySymlinks => true,
                discriminant_ReadErr::Unrecognized => self.Unrecognized == other.Unrecognized,
                discriminant_ReadErr::Unsupported => true,
            }
        }
    }
}

impl PartialOrd for ReadErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_ReadErr::Interrupted => Some(core::cmp::Ordering::Equal),
                discriminant_ReadErr::InvalidFilename => Some(core::cmp::Ordering::Equal),
                discriminant_ReadErr::NotFound => Some(core::cmp::Ordering::Equal),
                discriminant_ReadErr::OutOfMemory => Some(core::cmp::Ordering::Equal),
                discriminant_ReadErr::PermissionDenied => Some(core::cmp::Ordering::Equal),
                discriminant_ReadErr::StaleNetworkFileHandle => Some(core::cmp::Ordering::Equal),
                discriminant_ReadErr::TimedOut => Some(core::cmp::Ordering::Equal),
                discriminant_ReadErr::TooManyHardlinks => Some(core::cmp::Ordering::Equal),
                discriminant_ReadErr::TooManySymlinks => Some(core::cmp::Ordering::Equal),
                discriminant_ReadErr::Unrecognized => self.Unrecognized.partial_cmp(&other.Unrecognized),
                discriminant_ReadErr::Unsupported => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for ReadErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_ReadErr::Interrupted => core::cmp::Ordering::Equal,
                discriminant_ReadErr::InvalidFilename => core::cmp::Ordering::Equal,
                discriminant_ReadErr::NotFound => core::cmp::Ordering::Equal,
                discriminant_ReadErr::OutOfMemory => core::cmp::Ordering::Equal,
                discriminant_ReadErr::PermissionDenied => core::cmp::Ordering::Equal,
                discriminant_ReadErr::StaleNetworkFileHandle => core::cmp::Ordering::Equal,
                discriminant_ReadErr::TimedOut => core::cmp::Ordering::Equal,
                discriminant_ReadErr::TooManyHardlinks => core::cmp::Ordering::Equal,
                discriminant_ReadErr::TooManySymlinks => core::cmp::Ordering::Equal,
                discriminant_ReadErr::Unrecognized => self.Unrecognized.cmp(&other.Unrecognized),
                discriminant_ReadErr::Unsupported => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Clone for ReadErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_ReadErr::Interrupted => core::mem::transmute::<
                    core::mem::MaybeUninit<ReadErr>,
                    ReadErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_ReadErr::InvalidFilename => core::mem::transmute::<
                    core::mem::MaybeUninit<ReadErr>,
                    ReadErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_ReadErr::NotFound => core::mem::transmute::<
                    core::mem::MaybeUninit<ReadErr>,
                    ReadErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_ReadErr::OutOfMemory => core::mem::transmute::<
                    core::mem::MaybeUninit<ReadErr>,
                    ReadErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_ReadErr::PermissionDenied => core::mem::transmute::<
                    core::mem::MaybeUninit<ReadErr>,
                    ReadErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_ReadErr::StaleNetworkFileHandle => core::mem::transmute::<
                    core::mem::MaybeUninit<ReadErr>,
                    ReadErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_ReadErr::TimedOut => core::mem::transmute::<
                    core::mem::MaybeUninit<ReadErr>,
                    ReadErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_ReadErr::TooManyHardlinks => core::mem::transmute::<
                    core::mem::MaybeUninit<ReadErr>,
                    ReadErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_ReadErr::TooManySymlinks => core::mem::transmute::<
                    core::mem::MaybeUninit<ReadErr>,
                    ReadErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_ReadErr::Unrecognized => Self {
                    Unrecognized: self.Unrecognized.clone(),
                },
                discriminant_ReadErr::Unsupported => core::mem::transmute::<
                    core::mem::MaybeUninit<ReadErr>,
                    ReadErr,
                >(core::mem::MaybeUninit::uninit()),
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for ReadErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_ReadErr::Interrupted => discriminant_ReadErr::Interrupted.hash(state),
            discriminant_ReadErr::InvalidFilename => discriminant_ReadErr::InvalidFilename.hash(state),
            discriminant_ReadErr::NotFound => discriminant_ReadErr::NotFound.hash(state),
            discriminant_ReadErr::OutOfMemory => discriminant_ReadErr::OutOfMemory.hash(state),
            discriminant_ReadErr::PermissionDenied => discriminant_ReadErr::PermissionDenied.hash(state),
            discriminant_ReadErr::StaleNetworkFileHandle => discriminant_ReadErr::StaleNetworkFileHandle.hash(state),
            discriminant_ReadErr::TimedOut => discriminant_ReadErr::TimedOut.hash(state),
            discriminant_ReadErr::TooManyHardlinks => discriminant_ReadErr::TooManyHardlinks.hash(state),
            discriminant_ReadErr::TooManySymlinks => discriminant_ReadErr::TooManySymlinks.hash(state),
            discriminant_ReadErr::Unrecognized => unsafe {
                    discriminant_ReadErr::Unrecognized.hash(state);
                    self.Unrecognized.hash(state);
                },
            discriminant_ReadErr::Unsupported => discriminant_ReadErr::Unsupported.hash(state),
        }
    }
}

impl core::fmt::Debug for ReadErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("ReadErr::")?;

        unsafe {
            match self.discriminant() {
                discriminant_ReadErr::Interrupted => f.write_str("Interrupted"),
                discriminant_ReadErr::InvalidFilename => f.write_str("InvalidFilename"),
                discriminant_ReadErr::NotFound => f.write_str("NotFound"),
                discriminant_ReadErr::OutOfMemory => f.write_str("OutOfMemory"),
                discriminant_ReadErr::PermissionDenied => f.write_str("PermissionDenied"),
                discriminant_ReadErr::StaleNetworkFileHandle => f.write_str("StaleNetworkFileHandle"),
                discriminant_ReadErr::TimedOut => f.write_str("TimedOut"),
                discriminant_ReadErr::TooManyHardlinks => f.write_str("TooManyHardlinks"),
                discriminant_ReadErr::TooManySymlinks => f.write_str("TooManySymlinks"),
                discriminant_ReadErr::Unrecognized => f.debug_tuple("Unrecognized")
        .field(&(&*self.Unrecognized).f0)
.field(&(&*self.Unrecognized).f1)
        .finish(),
                discriminant_ReadErr::Unsupported => f.write_str("Unsupported"),
            }
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("ReadErr::")?;

        unsafe {
            match self.discriminant() {
                discriminant_ReadErr::Interrupted => f.write_str("Interrupted"),
                discriminant_ReadErr::InvalidFilename => f.write_str("InvalidFilename"),
                discriminant_ReadErr::NotFound => f.write_str("NotFound"),
                discriminant_ReadErr::OutOfMemory => f.write_str("OutOfMemory"),
                discriminant_ReadErr::PermissionDenied => f.write_str("PermissionDenied"),
                discriminant_ReadErr::StaleNetworkFileHandle => f.write_str("StaleNetworkFileHandle"),
                discriminant_ReadErr::TimedOut => f.write_str("TimedOut"),
                discriminant_ReadErr::TooManyHardlinks => f.write_str("TooManyHardlinks"),
                discriminant_ReadErr::TooManySymlinks => f.write_str("TooManySymlinks"),
                discriminant_ReadErr::Unrecognized => f.debug_tuple("Unrecognized")
        .field(&(&*self.Unrecognized).f1)
.field(&(&*self.Unrecognized).f0)
        .finish(),
                discriminant_ReadErr::Unsupported => f.write_str("Unsupported"),
            }
        }
    }
}

impl WriteErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_WriteErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_WriteErr>(*bytes.as_ptr().add(16))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_WriteErr) {
        let discriminant_ptr: *mut discriminant_WriteErr = (self as *mut WriteErr).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named AlreadyExists, which has no payload.
    pub const AlreadyExists: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::AlreadyExists as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the AlreadyExists tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_AlreadyExists(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the AlreadyExists tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_AlreadyExists(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named ExecutableFileBusy, which has no payload.
    pub const ExecutableFileBusy: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::ExecutableFileBusy as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the ExecutableFileBusy tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_ExecutableFileBusy(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the ExecutableFileBusy tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_ExecutableFileBusy(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named FileTooLarge, which has no payload.
    pub const FileTooLarge: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::FileTooLarge as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the FileTooLarge tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_FileTooLarge(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the FileTooLarge tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_FileTooLarge(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named FilesystemQuotaExceeded, which has no payload.
    pub const FilesystemQuotaExceeded: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::FilesystemQuotaExceeded as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the FilesystemQuotaExceeded tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_FilesystemQuotaExceeded(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the FilesystemQuotaExceeded tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_FilesystemQuotaExceeded(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Interrupted, which has no payload.
    pub const Interrupted: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::Interrupted as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Interrupted tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Interrupted(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Interrupted tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Interrupted(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named InvalidFilename, which has no payload.
    pub const InvalidFilename: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::InvalidFilename as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the InvalidFilename tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_InvalidFilename(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the InvalidFilename tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_InvalidFilename(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named NotFound, which has no payload.
    pub const NotFound: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::NotFound as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the NotFound tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_NotFound(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the NotFound tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_NotFound(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named OutOfMemory, which has no payload.
    pub const OutOfMemory: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::OutOfMemory as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the OutOfMemory tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_OutOfMemory(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the OutOfMemory tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_OutOfMemory(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named PermissionDenied, which has no payload.
    pub const PermissionDenied: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::PermissionDenied as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the PermissionDenied tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_PermissionDenied(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the PermissionDenied tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_PermissionDenied(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named ReadOnlyFilesystem, which has no payload.
    pub const ReadOnlyFilesystem: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::ReadOnlyFilesystem as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the ReadOnlyFilesystem tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_ReadOnlyFilesystem(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the ReadOnlyFilesystem tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_ReadOnlyFilesystem(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named ResourceBusy, which has no payload.
    pub const ResourceBusy: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::ResourceBusy as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the ResourceBusy tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_ResourceBusy(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the ResourceBusy tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_ResourceBusy(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named StaleNetworkFileHandle, which has no payload.
    pub const StaleNetworkFileHandle: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::StaleNetworkFileHandle as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the StaleNetworkFileHandle tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_StaleNetworkFileHandle(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the StaleNetworkFileHandle tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_StaleNetworkFileHandle(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named StorageFull, which has no payload.
    pub const StorageFull: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::StorageFull as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the StorageFull tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_StorageFull(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the StorageFull tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_StorageFull(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named TimedOut, which has no payload.
    pub const TimedOut: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::TimedOut as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the TimedOut tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_TimedOut(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the TimedOut tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_TimedOut(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named TooManyHardlinks, which has no payload.
    pub const TooManyHardlinks: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::TooManyHardlinks as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the TooManyHardlinks tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_TooManyHardlinks(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the TooManyHardlinks tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_TooManyHardlinks(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named TooManySymlinks, which has no payload.
    pub const TooManySymlinks: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::TooManySymlinks as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the TooManySymlinks tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_TooManySymlinks(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the TooManySymlinks tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_TooManySymlinks(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Unrecognized`, with the appropriate payload
    pub fn Unrecognized(arg0: i32, arg1: roc_std::RocStr) -> Self {
            let mut answer = Self {
                Unrecognized: core::mem::ManuallyDrop::new(WriteErr_Unrecognized {
                    f0: arg0,
                    f1: arg1,
                })
            };

            answer.set_discriminant(discriminant_WriteErr::Unrecognized);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `WriteErr` has a `.discriminant()` of `Unrecognized` and convert it to `Unrecognized`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Unrecognized`.
            pub unsafe fn into_Unrecognized(mut self) -> (i32, roc_std::RocStr) {
                debug_assert_eq!(self.discriminant(), discriminant_WriteErr::Unrecognized);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Unrecognized,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `WriteErr` has a `.discriminant()` of `Unrecognized` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Unrecognized`.
            pub unsafe fn as_Unrecognized(&self) -> (&i32, &roc_std::RocStr) {
                debug_assert_eq!(self.discriminant(), discriminant_WriteErr::Unrecognized);
        let payload = &self.Unrecognized;

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named Unsupported, which has no payload.
    pub const Unsupported: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::Unsupported as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Unsupported tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Unsupported(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Unsupported tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Unsupported(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named WasADirectory, which has no payload.
    pub const WasADirectory: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::WasADirectory as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the WasADirectory tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_WasADirectory(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the WasADirectory tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_WasADirectory(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named WriteZero, which has no payload.
    pub const WriteZero: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[16] = discriminant_WriteErr::WriteZero as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the WriteZero tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_WriteZero(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the WriteZero tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_WriteZero(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_WriteErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_WriteErr>(*bytes.as_ptr().add(32))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_WriteErr) {
        let discriminant_ptr: *mut discriminant_WriteErr = (self as *mut WriteErr).cast();

        unsafe {
            *(discriminant_ptr.add(32)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named AlreadyExists, which has no payload.
    pub const AlreadyExists: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::AlreadyExists as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named ExecutableFileBusy, which has no payload.
    pub const ExecutableFileBusy: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::ExecutableFileBusy as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named FileTooLarge, which has no payload.
    pub const FileTooLarge: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::FileTooLarge as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named FilesystemQuotaExceeded, which has no payload.
    pub const FilesystemQuotaExceeded: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::FilesystemQuotaExceeded as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Interrupted, which has no payload.
    pub const Interrupted: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::Interrupted as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named InvalidFilename, which has no payload.
    pub const InvalidFilename: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::InvalidFilename as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named NotFound, which has no payload.
    pub const NotFound: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::NotFound as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named OutOfMemory, which has no payload.
    pub const OutOfMemory: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::OutOfMemory as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named PermissionDenied, which has no payload.
    pub const PermissionDenied: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::PermissionDenied as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named ReadOnlyFilesystem, which has no payload.
    pub const ReadOnlyFilesystem: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::ReadOnlyFilesystem as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named ResourceBusy, which has no payload.
    pub const ResourceBusy: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::ResourceBusy as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named StaleNetworkFileHandle, which has no payload.
    pub const StaleNetworkFileHandle: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::StaleNetworkFileHandle as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named StorageFull, which has no payload.
    pub const StorageFull: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::StorageFull as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named TimedOut, which has no payload.
    pub const TimedOut: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::TimedOut as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named TooManyHardlinks, which has no payload.
    pub const TooManyHardlinks: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::TooManyHardlinks as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named TooManySymlinks, which has no payload.
    pub const TooManySymlinks: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::TooManySymlinks as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named Unsupported, which has no payload.
    pub const Unsupported: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::Unsupported as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named WasADirectory, which has no payload.
    pub const WasADirectory: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::WasADirectory as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named WriteZero, which has no payload.
    pub const WriteZero: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<WriteErr>()];

        bytes[32] = discriminant_WriteErr::WriteZero as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<WriteErr>()], WriteErr>(bytes)
    };
}

impl Drop for WriteErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
                    match self.discriminant() {
                discriminant_WriteErr::AlreadyExists => {}
                discriminant_WriteErr::ExecutableFileBusy => {}
                discriminant_WriteErr::FileTooLarge => {}
                discriminant_WriteErr::FilesystemQuotaExceeded => {}
                discriminant_WriteErr::Interrupted => {}
                discriminant_WriteErr::InvalidFilename => {}
                discriminant_WriteErr::NotFound => {}
                discriminant_WriteErr::OutOfMemory => {}
                discriminant_WriteErr::PermissionDenied => {}
                discriminant_WriteErr::ReadOnlyFilesystem => {}
                discriminant_WriteErr::ResourceBusy => {}
                discriminant_WriteErr::StaleNetworkFileHandle => {}
                discriminant_WriteErr::StorageFull => {}
                discriminant_WriteErr::TimedOut => {}
                discriminant_WriteErr::TooManyHardlinks => {}
                discriminant_WriteErr::TooManySymlinks => {}
                discriminant_WriteErr::Unrecognized => unsafe { core::mem::ManuallyDrop::drop(&mut self.Unrecognized) },
                discriminant_WriteErr::Unsupported => {}
                discriminant_WriteErr::WasADirectory => {}
                discriminant_WriteErr::WriteZero => {}
            }

    }
}

impl Eq for WriteErr {}

impl PartialEq for WriteErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_WriteErr::AlreadyExists => true,
                discriminant_WriteErr::ExecutableFileBusy => true,
                discriminant_WriteErr::FileTooLarge => true,
                discriminant_WriteErr::FilesystemQuotaExceeded => true,
                discriminant_WriteErr::Interrupted => true,
                discriminant_WriteErr::InvalidFilename => true,
                discriminant_WriteErr::NotFound => true,
                discriminant_WriteErr::OutOfMemory => true,
                discriminant_WriteErr::PermissionDenied => true,
                discriminant_WriteErr::ReadOnlyFilesystem => true,
                discriminant_WriteErr::ResourceBusy => true,
                discriminant_WriteErr::StaleNetworkFileHandle => true,
                discriminant_WriteErr::StorageFull => true,
                discriminant_WriteErr::TimedOut => true,
                discriminant_WriteErr::TooManyHardlinks => true,
                discriminant_WriteErr::TooManySymlinks => true,
                discriminant_WriteErr::Unrecognized => self.Unrecognized == other.Unrecognized,
                discriminant_WriteErr::Unsupported => true,
                discriminant_WriteErr::WasADirectory => true,
                discriminant_WriteErr::WriteZero => true,
            }
        }
    }
}

impl PartialOrd for WriteErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_WriteErr::AlreadyExists => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::ExecutableFileBusy => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::FileTooLarge => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::FilesystemQuotaExceeded => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::Interrupted => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::InvalidFilename => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::NotFound => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::OutOfMemory => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::PermissionDenied => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::ReadOnlyFilesystem => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::ResourceBusy => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::StaleNetworkFileHandle => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::StorageFull => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::TimedOut => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::TooManyHardlinks => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::TooManySymlinks => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::Unrecognized => self.Unrecognized.partial_cmp(&other.Unrecognized),
                discriminant_WriteErr::Unsupported => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::WasADirectory => Some(core::cmp::Ordering::Equal),
                discriminant_WriteErr::WriteZero => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for WriteErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_WriteErr::AlreadyExists => core::cmp::Ordering::Equal,
                discriminant_WriteErr::ExecutableFileBusy => core::cmp::Ordering::Equal,
                discriminant_WriteErr::FileTooLarge => core::cmp::Ordering::Equal,
                discriminant_WriteErr::FilesystemQuotaExceeded => core::cmp::Ordering::Equal,
                discriminant_WriteErr::Interrupted => core::cmp::Ordering::Equal,
                discriminant_WriteErr::InvalidFilename => core::cmp::Ordering::Equal,
                discriminant_WriteErr::NotFound => core::cmp::Ordering::Equal,
                discriminant_WriteErr::OutOfMemory => core::cmp::Ordering::Equal,
                discriminant_WriteErr::PermissionDenied => core::cmp::Ordering::Equal,
                discriminant_WriteErr::ReadOnlyFilesystem => core::cmp::Ordering::Equal,
                discriminant_WriteErr::ResourceBusy => core::cmp::Ordering::Equal,
                discriminant_WriteErr::StaleNetworkFileHandle => core::cmp::Ordering::Equal,
                discriminant_WriteErr::StorageFull => core::cmp::Ordering::Equal,
                discriminant_WriteErr::TimedOut => core::cmp::Ordering::Equal,
                discriminant_WriteErr::TooManyHardlinks => core::cmp::Ordering::Equal,
                discriminant_WriteErr::TooManySymlinks => core::cmp::Ordering::Equal,
                discriminant_WriteErr::Unrecognized => self.Unrecognized.cmp(&other.Unrecognized),
                discriminant_WriteErr::Unsupported => core::cmp::Ordering::Equal,
                discriminant_WriteErr::WasADirectory => core::cmp::Ordering::Equal,
                discriminant_WriteErr::WriteZero => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Clone for WriteErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_WriteErr::AlreadyExists => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::ExecutableFileBusy => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::FileTooLarge => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::FilesystemQuotaExceeded => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::Interrupted => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::InvalidFilename => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::NotFound => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::OutOfMemory => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::PermissionDenied => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::ReadOnlyFilesystem => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::ResourceBusy => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::StaleNetworkFileHandle => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::StorageFull => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::TimedOut => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::TooManyHardlinks => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::TooManySymlinks => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::Unrecognized => Self {
                    Unrecognized: self.Unrecognized.clone(),
                },
                discriminant_WriteErr::Unsupported => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::WasADirectory => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_WriteErr::WriteZero => core::mem::transmute::<
                    core::mem::MaybeUninit<WriteErr>,
                    WriteErr,
                >(core::mem::MaybeUninit::uninit()),
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for WriteErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_WriteErr::AlreadyExists => discriminant_WriteErr::AlreadyExists.hash(state),
            discriminant_WriteErr::ExecutableFileBusy => discriminant_WriteErr::ExecutableFileBusy.hash(state),
            discriminant_WriteErr::FileTooLarge => discriminant_WriteErr::FileTooLarge.hash(state),
            discriminant_WriteErr::FilesystemQuotaExceeded => discriminant_WriteErr::FilesystemQuotaExceeded.hash(state),
            discriminant_WriteErr::Interrupted => discriminant_WriteErr::Interrupted.hash(state),
            discriminant_WriteErr::InvalidFilename => discriminant_WriteErr::InvalidFilename.hash(state),
            discriminant_WriteErr::NotFound => discriminant_WriteErr::NotFound.hash(state),
            discriminant_WriteErr::OutOfMemory => discriminant_WriteErr::OutOfMemory.hash(state),
            discriminant_WriteErr::PermissionDenied => discriminant_WriteErr::PermissionDenied.hash(state),
            discriminant_WriteErr::ReadOnlyFilesystem => discriminant_WriteErr::ReadOnlyFilesystem.hash(state),
            discriminant_WriteErr::ResourceBusy => discriminant_WriteErr::ResourceBusy.hash(state),
            discriminant_WriteErr::StaleNetworkFileHandle => discriminant_WriteErr::StaleNetworkFileHandle.hash(state),
            discriminant_WriteErr::StorageFull => discriminant_WriteErr::StorageFull.hash(state),
            discriminant_WriteErr::TimedOut => discriminant_WriteErr::TimedOut.hash(state),
            discriminant_WriteErr::TooManyHardlinks => discriminant_WriteErr::TooManyHardlinks.hash(state),
            discriminant_WriteErr::TooManySymlinks => discriminant_WriteErr::TooManySymlinks.hash(state),
            discriminant_WriteErr::Unrecognized => unsafe {
                    discriminant_WriteErr::Unrecognized.hash(state);
                    self.Unrecognized.hash(state);
                },
            discriminant_WriteErr::Unsupported => discriminant_WriteErr::Unsupported.hash(state),
            discriminant_WriteErr::WasADirectory => discriminant_WriteErr::WasADirectory.hash(state),
            discriminant_WriteErr::WriteZero => discriminant_WriteErr::WriteZero.hash(state),
        }
    }
}

impl core::fmt::Debug for WriteErr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("WriteErr::")?;

        unsafe {
            match self.discriminant() {
                discriminant_WriteErr::AlreadyExists => f.write_str("AlreadyExists"),
                discriminant_WriteErr::ExecutableFileBusy => f.write_str("ExecutableFileBusy"),
                discriminant_WriteErr::FileTooLarge => f.write_str("FileTooLarge"),
                discriminant_WriteErr::FilesystemQuotaExceeded => f.write_str("FilesystemQuotaExceeded"),
                discriminant_WriteErr::Interrupted => f.write_str("Interrupted"),
                discriminant_WriteErr::InvalidFilename => f.write_str("InvalidFilename"),
                discriminant_WriteErr::NotFound => f.write_str("NotFound"),
                discriminant_WriteErr::OutOfMemory => f.write_str("OutOfMemory"),
                discriminant_WriteErr::PermissionDenied => f.write_str("PermissionDenied"),
                discriminant_WriteErr::ReadOnlyFilesystem => f.write_str("ReadOnlyFilesystem"),
                discriminant_WriteErr::ResourceBusy => f.write_str("ResourceBusy"),
                discriminant_WriteErr::StaleNetworkFileHandle => f.write_str("StaleNetworkFileHandle"),
                discriminant_WriteErr::StorageFull => f.write_str("StorageFull"),
                discriminant_WriteErr::TimedOut => f.write_str("TimedOut"),
                discriminant_WriteErr::TooManyHardlinks => f.write_str("TooManyHardlinks"),
                discriminant_WriteErr::TooManySymlinks => f.write_str("TooManySymlinks"),
                discriminant_WriteErr::Unrecognized => f.debug_tuple("Unrecognized")
        .field(&(&*self.Unrecognized).f0)
.field(&(&*self.Unrecognized).f1)
        .finish(),
                discriminant_WriteErr::Unsupported => f.write_str("Unsupported"),
                discriminant_WriteErr::WasADirectory => f.write_str("WasADirectory"),
                discriminant_WriteErr::WriteZero => f.write_str("WriteZero"),
            }
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("WriteErr::")?;

        unsafe {
            match self.discriminant() {
                discriminant_WriteErr::AlreadyExists => f.write_str("AlreadyExists"),
                discriminant_WriteErr::ExecutableFileBusy => f.write_str("ExecutableFileBusy"),
                discriminant_WriteErr::FileTooLarge => f.write_str("FileTooLarge"),
                discriminant_WriteErr::FilesystemQuotaExceeded => f.write_str("FilesystemQuotaExceeded"),
                discriminant_WriteErr::Interrupted => f.write_str("Interrupted"),
                discriminant_WriteErr::InvalidFilename => f.write_str("InvalidFilename"),
                discriminant_WriteErr::NotFound => f.write_str("NotFound"),
                discriminant_WriteErr::OutOfMemory => f.write_str("OutOfMemory"),
                discriminant_WriteErr::PermissionDenied => f.write_str("PermissionDenied"),
                discriminant_WriteErr::ReadOnlyFilesystem => f.write_str("ReadOnlyFilesystem"),
                discriminant_WriteErr::ResourceBusy => f.write_str("ResourceBusy"),
                discriminant_WriteErr::StaleNetworkFileHandle => f.write_str("StaleNetworkFileHandle"),
                discriminant_WriteErr::StorageFull => f.write_str("StorageFull"),
                discriminant_WriteErr::TimedOut => f.write_str("TimedOut"),
                discriminant_WriteErr::TooManyHardlinks => f.write_str("TooManyHardlinks"),
                discriminant_WriteErr::TooManySymlinks => f.write_str("TooManySymlinks"),
                discriminant_WriteErr::Unrecognized => f.debug_tuple("Unrecognized")
        .field(&(&*self.Unrecognized).f1)
.field(&(&*self.Unrecognized).f0)
        .finish(),
                discriminant_WriteErr::Unsupported => f.write_str("Unsupported"),
                discriminant_WriteErr::WasADirectory => f.write_str("WasADirectory"),
                discriminant_WriteErr::WriteZero => f.write_str("WriteZero"),
            }
        }
    }
}
