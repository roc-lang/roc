// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum DiscriminantElem {
    Layout = 0,
    Paragraph = 1,
}

impl core::fmt::Debug for DiscriminantElem {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Layout => f.write_str("DiscriminantElem::Layout"),
            Self::Paragraph => f.write_str("DiscriminantElem::Paragraph"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(transparent)]
pub struct Elem {
    pointer: *mut UnionElem,
}


#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
union UnionElem {
    Layout: core::mem::ManuallyDrop<ElemLayout>,
    Paragraph: core::mem::ManuallyDrop<ElemParagraph>,
    _sizer: [u8; 4],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Span {
    pub style: Styles,
    pub text: roc_std::RocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum DiscriminantEvent {
    FocusGained = 0,
    FocusLost = 1,
    KeyPressed = 2,
    Paste = 3,
    Resize = 4,
}

impl core::fmt::Debug for DiscriminantEvent {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::FocusGained => f.write_str("DiscriminantEvent::FocusGained"),
            Self::FocusLost => f.write_str("DiscriminantEvent::FocusLost"),
            Self::KeyPressed => f.write_str("DiscriminantEvent::KeyPressed"),
            Self::Paste => f.write_str("DiscriminantEvent::Paste"),
            Self::Resize => f.write_str("DiscriminantEvent::Resize"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "wasm32",
    target_arch = "x86"
))]
#[repr(C)]
pub union Event {
    KeyPressed: KeyCode,
    Paste: core::mem::ManuallyDrop<roc_std::RocStr>,
    Resize: Bounds,
    _sizer: [u8; 16],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Model {
    pub text: roc_std::RocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum BorderModifier {
    ALL = 0,
    BOTTOM = 1,
    LEFT = 2,
    NONE = 3,
    RIGHT = 4,
    TOP = 5,
}

impl core::fmt::Debug for BorderModifier {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ALL => f.write_str("BorderModifier::ALL"),
            Self::BOTTOM => f.write_str("BorderModifier::BOTTOM"),
            Self::LEFT => f.write_str("BorderModifier::LEFT"),
            Self::NONE => f.write_str("BorderModifier::NONE"),
            Self::RIGHT => f.write_str("BorderModifier::RIGHT"),
            Self::TOP => f.write_str("BorderModifier::TOP"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum TextModifier {
    BOLD = 0,
    CROSSEDOUT = 1,
    DIM = 2,
    HIDDEN = 3,
    ITALIC = 4,
    RAPIDBLINK = 5,
    REVERSED = 6,
    SLOWBLINK = 7,
    UNDERLINED = 8,
}

impl core::fmt::Debug for TextModifier {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BOLD => f.write_str("TextModifier::BOLD"),
            Self::CROSSEDOUT => f.write_str("TextModifier::CROSSEDOUT"),
            Self::DIM => f.write_str("TextModifier::DIM"),
            Self::HIDDEN => f.write_str("TextModifier::HIDDEN"),
            Self::ITALIC => f.write_str("TextModifier::ITALIC"),
            Self::RAPIDBLINK => f.write_str("TextModifier::RAPIDBLINK"),
            Self::REVERSED => f.write_str("TextModifier::REVERSED"),
            Self::SLOWBLINK => f.write_str("TextModifier::SLOWBLINK"),
            Self::UNDERLINED => f.write_str("TextModifier::UNDERLINED"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum DiscriminantConstraint {
    Length = 0,
    Max = 1,
    Min = 2,
    Percentage = 3,
    Ratio = 4,
}

impl core::fmt::Debug for DiscriminantConstraint {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Length => f.write_str("DiscriminantConstraint::Length"),
            Self::Max => f.write_str("DiscriminantConstraint::Max"),
            Self::Min => f.write_str("DiscriminantConstraint::Min"),
            Self::Percentage => f.write_str("DiscriminantConstraint::Percentage"),
            Self::Ratio => f.write_str("DiscriminantConstraint::Ratio"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Constraint {
    Length: u16,
    Max: u16,
    Min: u16,
    Percentage: u16,
    Ratio: ConstraintRatio,
    _sizer: [u8; 12],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Bounds {
    pub height: u16,
    pub width: u16,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R1 {
    // pub init: TODO_roc_function_65,
    // pub render: TODO_roc_function_69,
    // pub update: TODO_roc_function_67,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum DiscriminantKeyCode {
    KeyBackTab = 0,
    KeyBackspace = 1,
    KeyCapsLock = 2,
    KeyDelete = 3,
    KeyDown = 4,
    KeyEnd = 5,
    KeyEnter = 6,
    KeyEsc = 7,
    KeyFunction = 8,
    KeyHome = 9,
    KeyInsert = 10,
    KeyKeypadBegin = 11,
    KeyLeft = 12,
    KeyMedia = 13,
    KeyMenu = 14,
    KeyModifier = 15,
    KeyNull = 16,
    KeyNumLock = 17,
    KeyPageDown = 18,
    KeyPageUp = 19,
    KeyPause = 20,
    KeyPrintScreen = 21,
    KeyRight = 22,
    KeyScalar = 23,
    KeyScrollLock = 24,
    KeyTab = 25,
    KeyUp = 26,
}

impl core::fmt::Debug for DiscriminantKeyCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::KeyBackTab => f.write_str("DiscriminantKeyCode::KeyBackTab"),
            Self::KeyBackspace => f.write_str("DiscriminantKeyCode::KeyBackspace"),
            Self::KeyCapsLock => f.write_str("DiscriminantKeyCode::KeyCapsLock"),
            Self::KeyDelete => f.write_str("DiscriminantKeyCode::KeyDelete"),
            Self::KeyDown => f.write_str("DiscriminantKeyCode::KeyDown"),
            Self::KeyEnd => f.write_str("DiscriminantKeyCode::KeyEnd"),
            Self::KeyEnter => f.write_str("DiscriminantKeyCode::KeyEnter"),
            Self::KeyEsc => f.write_str("DiscriminantKeyCode::KeyEsc"),
            Self::KeyFunction => f.write_str("DiscriminantKeyCode::KeyFunction"),
            Self::KeyHome => f.write_str("DiscriminantKeyCode::KeyHome"),
            Self::KeyInsert => f.write_str("DiscriminantKeyCode::KeyInsert"),
            Self::KeyKeypadBegin => f.write_str("DiscriminantKeyCode::KeyKeypadBegin"),
            Self::KeyLeft => f.write_str("DiscriminantKeyCode::KeyLeft"),
            Self::KeyMedia => f.write_str("DiscriminantKeyCode::KeyMedia"),
            Self::KeyMenu => f.write_str("DiscriminantKeyCode::KeyMenu"),
            Self::KeyModifier => f.write_str("DiscriminantKeyCode::KeyModifier"),
            Self::KeyNull => f.write_str("DiscriminantKeyCode::KeyNull"),
            Self::KeyNumLock => f.write_str("DiscriminantKeyCode::KeyNumLock"),
            Self::KeyPageDown => f.write_str("DiscriminantKeyCode::KeyPageDown"),
            Self::KeyPageUp => f.write_str("DiscriminantKeyCode::KeyPageUp"),
            Self::KeyPause => f.write_str("DiscriminantKeyCode::KeyPause"),
            Self::KeyPrintScreen => f.write_str("DiscriminantKeyCode::KeyPrintScreen"),
            Self::KeyRight => f.write_str("DiscriminantKeyCode::KeyRight"),
            Self::KeyScalar => f.write_str("DiscriminantKeyCode::KeyScalar"),
            Self::KeyScrollLock => f.write_str("DiscriminantKeyCode::KeyScrollLock"),
            Self::KeyTab => f.write_str("DiscriminantKeyCode::KeyTab"),
            Self::KeyUp => f.write_str("DiscriminantKeyCode::KeyUp"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union KeyCode {
    KeyFunction: u8,
    KeyMedia: MediaKeyCode,
    KeyModifier: ModifierKeyCode,
    KeyScalar: u32,
    _sizer: [u8; 8],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum ModifierKeyCode {
    KeyIsoLevel3Shift = 0,
    KeyIsoLevel5Shift = 1,
    KeyLeftAlt = 2,
    KeyLeftControl = 3,
    KeyLeftHyper = 4,
    KeyLeftMeta = 5,
    KeyLeftShift = 6,
    KeyLeftSuper = 7,
    KeyRightAlt = 8,
    KeyRightControl = 9,
    KeyRightHyper = 10,
    KeyRightMeta = 11,
    KeyRightShift = 12,
    KeyRightSuper = 13,
}

impl core::fmt::Debug for ModifierKeyCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::KeyIsoLevel3Shift => f.write_str("ModifierKeyCode::KeyIsoLevel3Shift"),
            Self::KeyIsoLevel5Shift => f.write_str("ModifierKeyCode::KeyIsoLevel5Shift"),
            Self::KeyLeftAlt => f.write_str("ModifierKeyCode::KeyLeftAlt"),
            Self::KeyLeftControl => f.write_str("ModifierKeyCode::KeyLeftControl"),
            Self::KeyLeftHyper => f.write_str("ModifierKeyCode::KeyLeftHyper"),
            Self::KeyLeftMeta => f.write_str("ModifierKeyCode::KeyLeftMeta"),
            Self::KeyLeftShift => f.write_str("ModifierKeyCode::KeyLeftShift"),
            Self::KeyLeftSuper => f.write_str("ModifierKeyCode::KeyLeftSuper"),
            Self::KeyRightAlt => f.write_str("ModifierKeyCode::KeyRightAlt"),
            Self::KeyRightControl => f.write_str("ModifierKeyCode::KeyRightControl"),
            Self::KeyRightHyper => f.write_str("ModifierKeyCode::KeyRightHyper"),
            Self::KeyRightMeta => f.write_str("ModifierKeyCode::KeyRightMeta"),
            Self::KeyRightShift => f.write_str("ModifierKeyCode::KeyRightShift"),
            Self::KeyRightSuper => f.write_str("ModifierKeyCode::KeyRightSuper"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum MediaKeyCode {
    KeyFastForward = 0,
    KeyLowerVolume = 1,
    KeyMuteVolume = 2,
    KeyPause = 3,
    KeyPlay = 4,
    KeyPlayPause = 5,
    KeyRaiseVolume = 6,
    KeyRecord = 7,
    KeyReverse = 8,
    KeyRewind = 9,
    KeyStop = 10,
    KeyTrackNext = 11,
    KeyTrackPrevious = 12,
}

impl core::fmt::Debug for MediaKeyCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::KeyFastForward => f.write_str("MediaKeyCode::KeyFastForward"),
            Self::KeyLowerVolume => f.write_str("MediaKeyCode::KeyLowerVolume"),
            Self::KeyMuteVolume => f.write_str("MediaKeyCode::KeyMuteVolume"),
            Self::KeyPause => f.write_str("MediaKeyCode::KeyPause"),
            Self::KeyPlay => f.write_str("MediaKeyCode::KeyPlay"),
            Self::KeyPlayPause => f.write_str("MediaKeyCode::KeyPlayPause"),
            Self::KeyRaiseVolume => f.write_str("MediaKeyCode::KeyRaiseVolume"),
            Self::KeyRecord => f.write_str("MediaKeyCode::KeyRecord"),
            Self::KeyReverse => f.write_str("MediaKeyCode::KeyReverse"),
            Self::KeyRewind => f.write_str("MediaKeyCode::KeyRewind"),
            Self::KeyStop => f.write_str("MediaKeyCode::KeyStop"),
            Self::KeyTrackNext => f.write_str("MediaKeyCode::KeyTrackNext"),
            Self::KeyTrackPrevious => f.write_str("MediaKeyCode::KeyTrackPrevious"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct ElemParagraph {
    pub f0: roc_std::RocList<roc_std::RocList<Span>>,
    pub f1: ParagraphConfig,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct ParagraphConfig {
    pub borderStyle: Styles,
    pub borders: roc_std::RocList<BorderModifier>,
    pub style: Styles,
    pub title: roc_std::RocStr,
    pub titleStyle: Styles,
    pub borderType: BorderType,
    pub textAlignment: Alignment,
    pub titleAlignment: Alignment,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum Alignment {
    Center = 0,
    Left = 1,
    Right = 2,
}

impl core::fmt::Debug for Alignment {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Center => f.write_str("Alignment::Center"),
            Self::Left => f.write_str("Alignment::Left"),
            Self::Right => f.write_str("Alignment::Right"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum BorderType {
    Double = 0,
    Plain = 1,
    Rounded = 2,
    Thick = 3,
}

impl core::fmt::Debug for BorderType {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Double => f.write_str("BorderType::Double"),
            Self::Plain => f.write_str("BorderType::Plain"),
            Self::Rounded => f.write_str("BorderType::Rounded"),
            Self::Thick => f.write_str("BorderType::Thick"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Styles {
    pub modifiers: roc_std::RocList<TextModifier>,
    pub bg: Color,
    pub fg: Color,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum DiscriminantColor {
    Black = 0,
    Blue = 1,
    Cyan = 2,
    DarkGray = 3,
    Gray = 4,
    Green = 5,
    LightBlue = 6,
    LightCyan = 7,
    LightGreen = 8,
    LightMagenta = 9,
    LightRed = 10,
    LightYellow = 11,
    Magenta = 12,
    None = 13,
    Red = 14,
    White = 15,
    Yellow = 16,
}

impl core::fmt::Debug for DiscriminantColor {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Black => f.write_str("DiscriminantColor::Black"),
            Self::Blue => f.write_str("DiscriminantColor::Blue"),
            Self::Cyan => f.write_str("DiscriminantColor::Cyan"),
            Self::DarkGray => f.write_str("DiscriminantColor::DarkGray"),
            Self::Gray => f.write_str("DiscriminantColor::Gray"),
            Self::Green => f.write_str("DiscriminantColor::Green"),
            Self::LightBlue => f.write_str("DiscriminantColor::LightBlue"),
            Self::LightCyan => f.write_str("DiscriminantColor::LightCyan"),
            Self::LightGreen => f.write_str("DiscriminantColor::LightGreen"),
            Self::LightMagenta => f.write_str("DiscriminantColor::LightMagenta"),
            Self::LightRed => f.write_str("DiscriminantColor::LightRed"),
            Self::LightYellow => f.write_str("DiscriminantColor::LightYellow"),
            Self::Magenta => f.write_str("DiscriminantColor::Magenta"),
            Self::None => f.write_str("DiscriminantColor::None"),
            Self::Red => f.write_str("DiscriminantColor::Red"),
            Self::White => f.write_str("DiscriminantColor::White"),
            Self::Yellow => f.write_str("DiscriminantColor::Yellow"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Color {
    _sizer: [u8; 1],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct ElemLayout {
    pub f0: roc_std::RocList<Elem>,
    pub f1: LayoutConfig,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct LayoutConfig {
    pub constraints: roc_std::RocList<Constraint>,
    pub hMargin: u16,
    pub vMargin: u16,
    pub direction: LayoutDirection,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum LayoutDirection {
    Horizontal = 0,
    Vertical = 1,
}

impl core::fmt::Debug for LayoutDirection {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Horizontal => f.write_str("LayoutDirection::Horizontal"),
            Self::Vertical => f.write_str("LayoutDirection::Vertical"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct ConstraintRatio {
    pub f0: u32,
    pub f1: u32,
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
union UnionElem {
    Layout: core::mem::ManuallyDrop<ElemLayout>,
    Paragraph: core::mem::ManuallyDrop<ElemParagraph>,
    _sizer: [u8; 8],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Event {
    KeyPressed: KeyCode,
    Paste: core::mem::ManuallyDrop<roc_std::RocStr>,
    Resize: Bounds,
    _sizer: [u8; 32],
}

impl Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    #[inline(always)]
    fn storage(&self) -> Option<&core::cell::Cell<roc_std::Storage>> {
        let mask = match std::mem::size_of::<usize>() {
            4 => 0b11,
            8 => 0b111,
            _ => unreachable!(),
        };

        // NOTE: pointer provenance is probably lost here
        let unmasked_address = (self.pointer as usize) & !mask;
        let untagged = unmasked_address as *const core::cell::Cell<roc_std::Storage>;

        if untagged.is_null() {
            None
        } else {
            unsafe {
                Some(&*untagged.sub(1))
            }
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> DiscriminantElem {
        // The discriminant is stored in the unused bytes at the end of the recursive pointer
        unsafe { core::mem::transmute::<u8, DiscriminantElem>((self.pointer as u8) & 0b11) }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn tag_discriminant(pointer: *mut UnionElem, discriminant: DiscriminantElem) -> *mut UnionElem {
        // The discriminant is stored in the unused bytes at the end of the union pointer
        let untagged = (pointer as usize) & (!0b11 as usize);
        let tagged = untagged | (discriminant as usize);

        tagged as *mut UnionElem
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn union_pointer(&self) -> *mut UnionElem {
        // The discriminant is stored in the unused bytes at the end of the union pointer
        ((self.pointer as usize) & (!0b11 as usize)) as *mut UnionElem
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Layout`, with the appropriate payload
    pub fn Layout(arg0: roc_std::RocList<Elem>, arg1: LayoutConfig) -> Self {
            let size = core::mem::size_of::<UnionElem>();
            let align = core::mem::align_of::<UnionElem>() as u32;

            unsafe {
                let ptr = roc_std::roc_alloc_refcounted::<UnionElem>();

                *ptr = UnionElem {
                    Layout: core::mem::ManuallyDrop::new(ElemLayout {
                    f0: arg0,
                    f1: arg1,
                })
                };

                Self {
                    pointer: Self::tag_discriminant(ptr, DiscriminantElem::Layout),
                }
            }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Layout` and convert it to `Layout`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Layout`.
            pub unsafe fn into_Layout(mut self) -> (roc_std::RocList<Elem>, LayoutConfig) {
                debug_assert_eq!(self.discriminant(), DiscriminantElem::Layout);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut UnionElem;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Layout,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Layout` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Layout`.
            pub unsafe fn as_Layout(&self) -> (&roc_std::RocList<Elem>, &LayoutConfig) {
                debug_assert_eq!(self.discriminant(), DiscriminantElem::Layout);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut UnionElem;

            unsafe { &(*ptr).Layout }
        };

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Paragraph`, with the appropriate payload
    pub fn Paragraph(arg0: roc_std::RocList<roc_std::RocList<Span>>, arg1: ParagraphConfig) -> Self {
            let size = core::mem::size_of::<UnionElem>();
            let align = core::mem::align_of::<UnionElem>() as u32;

            unsafe {
                let ptr = roc_std::roc_alloc_refcounted::<UnionElem>();

                *ptr = UnionElem {
                    Paragraph: core::mem::ManuallyDrop::new(ElemParagraph {
                    f0: arg0,
                    f1: arg1,
                })
                };

                Self {
                    pointer: Self::tag_discriminant(ptr, DiscriminantElem::Paragraph),
                }
            }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Paragraph` and convert it to `Paragraph`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Paragraph`.
            pub unsafe fn into_Paragraph(mut self) -> (roc_std::RocList<roc_std::RocList<Span>>, ParagraphConfig) {
                debug_assert_eq!(self.discriminant(), DiscriminantElem::Paragraph);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut UnionElem;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Paragraph,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Paragraph` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Paragraph`.
            pub unsafe fn as_Paragraph(&self) -> (&roc_std::RocList<roc_std::RocList<Span>>, &ParagraphConfig) {
                debug_assert_eq!(self.discriminant(), DiscriminantElem::Paragraph);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut UnionElem;

            unsafe { &(*ptr).Paragraph }
        };

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> DiscriminantElem {
        // The discriminant is stored in the unused bytes at the end of the recursive pointer
        unsafe { core::mem::transmute::<u8, DiscriminantElem>((self.pointer as u8) & 0b111) }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn tag_discriminant(pointer: *mut UnionElem, discriminant: DiscriminantElem) -> *mut UnionElem {
        // The discriminant is stored in the unused bytes at the end of the union pointer
        let untagged = (pointer as usize) & (!0b111 as usize);
        let tagged = untagged | (discriminant as usize);

        tagged as *mut UnionElem
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn union_pointer(&self) -> *mut UnionElem {
        // The discriminant is stored in the unused bytes at the end of the union pointer
        ((self.pointer as usize) & (!0b111 as usize)) as *mut UnionElem
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Layout` and convert it to `Layout`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Layout`.
            pub unsafe fn into_Layout(mut self) -> (roc_std::RocList<Elem>, LayoutConfig) {
                debug_assert_eq!(self.discriminant(), DiscriminantElem::Layout);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut UnionElem;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Layout,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Layout` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Layout`.
            pub unsafe fn as_Layout(&self) -> (&roc_std::RocList<Elem>, &LayoutConfig) {
                debug_assert_eq!(self.discriminant(), DiscriminantElem::Layout);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut UnionElem;

            unsafe { &(*ptr).Layout }
        };

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Paragraph` and convert it to `Paragraph`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Paragraph`.
            pub unsafe fn into_Paragraph(mut self) -> (roc_std::RocList<roc_std::RocList<Span>>, ParagraphConfig) {
                debug_assert_eq!(self.discriminant(), DiscriminantElem::Paragraph);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut UnionElem;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Paragraph,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Elem` has a `.discriminant()` of `Paragraph` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Paragraph`.
            pub unsafe fn as_Paragraph(&self) -> (&roc_std::RocList<roc_std::RocList<Span>>, &ParagraphConfig) {
                debug_assert_eq!(self.discriminant(), DiscriminantElem::Paragraph);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut UnionElem;

            unsafe { &(*ptr).Paragraph }
        };

        (
            &payload.f0, 
            &payload.f1
        )
    }
}

impl Drop for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // We only need to do any work if there's actually a heap-allocated payload.
        if let Some(storage) = self.storage() {
            let mut new_storage = storage.get();

            // Decrement the refcount
            let needs_dealloc = !new_storage.is_readonly() && new_storage.decrease();

            if needs_dealloc {
                // Drop the payload first.
                            match self.discriminant() {
                DiscriminantElem::Layout => unsafe { core::mem::ManuallyDrop::drop(&mut (&mut *self.union_pointer()).Layout) },
                DiscriminantElem::Paragraph => unsafe { core::mem::ManuallyDrop::drop(&mut (&mut *self.union_pointer()).Paragraph) },
            }


                // Dealloc the pointer
                let alignment = core::mem::align_of::<Self>().max(core::mem::align_of::<roc_std::Storage>());

                unsafe { crate::roc::roc_dealloc(storage.as_ptr().cast(), alignment as u32); }
            } else {
                // Write the storage back.
                storage.set(new_storage);
            }
        }
    }
}

impl Eq for Elem {}

impl PartialEq for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                DiscriminantElem::Layout => (&*self.union_pointer()).Layout == (&*other.union_pointer()).Layout,
                DiscriminantElem::Paragraph => (&*self.union_pointer()).Paragraph == (&*other.union_pointer()).Paragraph,
            }
        }
    }
}

impl PartialOrd for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                DiscriminantElem::Layout => (&*self.union_pointer()).Layout.partial_cmp(&(&*other.union_pointer()).Layout),
                DiscriminantElem::Paragraph => (&*self.union_pointer()).Paragraph.partial_cmp(&(&*other.union_pointer()).Paragraph),
            }
        }
    }
}

impl Ord for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                DiscriminantElem::Layout => (&*self.union_pointer()).Layout.cmp(&(&*other.union_pointer()).Layout),
                DiscriminantElem::Paragraph => (&*self.union_pointer()).Paragraph.cmp(&(&*other.union_pointer()).Paragraph),
            }
        }
    }
}

impl Clone for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        if let Some(storage) = self.storage() {
            let mut new_storage = storage.get();
            if !new_storage.is_readonly() {
                new_storage.increment_reference_count();
                storage.set(new_storage);
            }
        }

        Self {
            pointer: self.pointer
        }
    }
}

impl core::hash::Hash for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            DiscriminantElem::Layout => unsafe {
                    DiscriminantElem::Layout.hash(state);
                    (&*self.union_pointer()).Layout.hash(state);
                },
            DiscriminantElem::Paragraph => unsafe {
                    DiscriminantElem::Paragraph.hash(state);
                    (&*self.union_pointer()).Paragraph.hash(state);
                },
        }
    }
}

impl core::fmt::Debug for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Elem::")?;

        unsafe {
            match self.discriminant() {
                DiscriminantElem::Layout => f.debug_tuple("Layout")
        .field(&(&*(&*self.union_pointer()).Layout).f0)
.field(&(&*(&*self.union_pointer()).Layout).f1)
        .finish(),
                DiscriminantElem::Paragraph => f.debug_tuple("Paragraph")
        .field(&(&*(&*self.union_pointer()).Paragraph).f0)
.field(&(&*(&*self.union_pointer()).Paragraph).f1)
        .finish(),
            }
        }
    }
}

impl Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> DiscriminantEvent {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, DiscriminantEvent>(*bytes.as_ptr().add(12))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: DiscriminantEvent) {
        let discriminant_ptr: *mut DiscriminantEvent = (self as *mut Event).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named FocusGained, which has no payload.
    pub const FocusGained: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Event>()];

        bytes[12] = DiscriminantEvent::FocusGained as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Event>()], Event>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the FocusGained tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_FocusGained(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the FocusGained tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_FocusGained(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// A tag named FocusLost, which has no payload.
    pub const FocusLost: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Event>()];

        bytes[12] = DiscriminantEvent::FocusLost as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Event>()], Event>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the FocusLost tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_FocusLost(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the FocusLost tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_FocusLost(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `KeyPressed`, with the appropriate payload
    pub fn KeyPressed(arg: KeyCode) -> Self {
            let mut answer = Self {
                KeyPressed: arg
            };

            answer.set_discriminant(DiscriminantEvent::KeyPressed);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `KeyPressed` and convert it to `KeyPressed`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyPressed`.
            pub unsafe fn into_KeyPressed(self) -> KeyCode {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::KeyPressed);
        let payload = self.KeyPressed;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `KeyPressed` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyPressed`.
            pub unsafe fn as_KeyPressed(&self) -> &KeyCode {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::KeyPressed);
        let payload = &self.KeyPressed;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Paste`, with the appropriate payload
    pub fn Paste(arg: roc_std::RocStr) -> Self {
            let mut answer = Self {
                Paste: core::mem::ManuallyDrop::new(arg)
            };

            answer.set_discriminant(DiscriminantEvent::Paste);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Paste` and convert it to `Paste`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Paste`.
            pub unsafe fn into_Paste(mut self) -> roc_std::RocStr {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::Paste);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Paste,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Paste` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Paste`.
            pub unsafe fn as_Paste(&self) -> &roc_std::RocStr {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::Paste);
        let payload = &self.Paste;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Resize`, with the appropriate payload
    pub fn Resize(arg0: Bounds) -> Self {
            let mut answer = Self {
                Resize: arg0
            };

            answer.set_discriminant(DiscriminantEvent::Resize);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Resize` and convert it to `Resize`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Resize`.
            pub unsafe fn into_Resize(self) -> Bounds {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::Resize);
        let payload = self.Resize;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Resize` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Resize`.
            pub unsafe fn as_Resize(&self) -> &Bounds {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::Resize);
        let payload = &self.Resize;

        
        payload
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> DiscriminantEvent {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, DiscriminantEvent>(*bytes.as_ptr().add(24))
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: DiscriminantEvent) {
        let discriminant_ptr: *mut DiscriminantEvent = (self as *mut Event).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named FocusGained, which has no payload.
    pub const FocusGained: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Event>()];

        bytes[24] = DiscriminantEvent::FocusGained as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Event>()], Event>(bytes)
    };

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// A tag named FocusLost, which has no payload.
    pub const FocusLost: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Event>()];

        bytes[24] = DiscriminantEvent::FocusLost as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Event>()], Event>(bytes)
    };
}

impl Drop for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
                    match self.discriminant() {
                DiscriminantEvent::FocusGained => {}
                DiscriminantEvent::FocusLost => {}
                DiscriminantEvent::KeyPressed => {}
                DiscriminantEvent::Paste => unsafe { core::mem::ManuallyDrop::drop(&mut self.Paste) },
                DiscriminantEvent::Resize => {}
            }

    }
}

impl Eq for Event {}

impl PartialEq for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                DiscriminantEvent::FocusGained => true,
                DiscriminantEvent::FocusLost => true,
                DiscriminantEvent::KeyPressed => self.KeyPressed == other.KeyPressed,
                DiscriminantEvent::Paste => self.Paste == other.Paste,
                DiscriminantEvent::Resize => self.Resize == other.Resize,
            }
        }
    }
}

impl PartialOrd for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                DiscriminantEvent::FocusGained => Some(core::cmp::Ordering::Equal),
                DiscriminantEvent::FocusLost => Some(core::cmp::Ordering::Equal),
                DiscriminantEvent::KeyPressed => self.KeyPressed.partial_cmp(&other.KeyPressed),
                DiscriminantEvent::Paste => self.Paste.partial_cmp(&other.Paste),
                DiscriminantEvent::Resize => self.Resize.partial_cmp(&other.Resize),
            }
        }
    }
}

impl Ord for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                DiscriminantEvent::FocusGained => core::cmp::Ordering::Equal,
                DiscriminantEvent::FocusLost => core::cmp::Ordering::Equal,
                DiscriminantEvent::KeyPressed => self.KeyPressed.cmp(&other.KeyPressed),
                DiscriminantEvent::Paste => self.Paste.cmp(&other.Paste),
                DiscriminantEvent::Resize => self.Resize.cmp(&other.Resize),
            }
        }
    }
}

impl Clone for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                DiscriminantEvent::FocusGained => core::mem::transmute::<
                    core::mem::MaybeUninit<Event>,
                    Event,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantEvent::FocusLost => core::mem::transmute::<
                    core::mem::MaybeUninit<Event>,
                    Event,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantEvent::KeyPressed => Self {
                    KeyPressed: self.KeyPressed.clone(),
                },
                DiscriminantEvent::Paste => Self {
                    Paste: self.Paste.clone(),
                },
                DiscriminantEvent::Resize => Self {
                    Resize: self.Resize.clone(),
                },
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            DiscriminantEvent::FocusGained => DiscriminantEvent::FocusGained.hash(state),
            DiscriminantEvent::FocusLost => DiscriminantEvent::FocusLost.hash(state),
            DiscriminantEvent::KeyPressed => unsafe {
                    DiscriminantEvent::KeyPressed.hash(state);
                    self.KeyPressed.hash(state);
                },
            DiscriminantEvent::Paste => unsafe {
                    DiscriminantEvent::Paste.hash(state);
                    self.Paste.hash(state);
                },
            DiscriminantEvent::Resize => unsafe {
                    DiscriminantEvent::Resize.hash(state);
                    self.Resize.hash(state);
                },
        }
    }
}

impl core::fmt::Debug for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Event::")?;

        unsafe {
            match self.discriminant() {
                DiscriminantEvent::FocusGained => f.write_str("FocusGained"),
                DiscriminantEvent::FocusLost => f.write_str("FocusLost"),
                DiscriminantEvent::KeyPressed => f.debug_tuple("KeyPressed")
        .field(&self.KeyPressed)
        .finish(),
                DiscriminantEvent::Paste => f.debug_tuple("Paste")
        .field(&*self.Paste)
        .finish(),
                DiscriminantEvent::Resize => f.debug_tuple("Resize")
        .field(&self.Resize)
        .finish(),
            }
        }
    }
}

impl Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> DiscriminantConstraint {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, DiscriminantConstraint>(*bytes.as_ptr().add(8))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: DiscriminantConstraint) {
        let discriminant_ptr: *mut DiscriminantConstraint = (self as *mut Constraint).cast();

        unsafe {
            *(discriminant_ptr.add(8)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Length`, with the appropriate payload
    pub fn Length(arg: u16) -> Self {
            let mut answer = Self {
                Length: arg
            };

            answer.set_discriminant(DiscriminantConstraint::Length);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Length` and convert it to `Length`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Length`.
            pub unsafe fn into_Length(self) -> u16 {
                debug_assert_eq!(self.discriminant(), DiscriminantConstraint::Length);
        let payload = self.Length;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Length` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Length`.
            pub unsafe fn as_Length(&self) -> &u16 {
                debug_assert_eq!(self.discriminant(), DiscriminantConstraint::Length);
        let payload = &self.Length;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Max`, with the appropriate payload
    pub fn Max(arg: u16) -> Self {
            let mut answer = Self {
                Max: arg
            };

            answer.set_discriminant(DiscriminantConstraint::Max);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Max` and convert it to `Max`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Max`.
            pub unsafe fn into_Max(self) -> u16 {
                debug_assert_eq!(self.discriminant(), DiscriminantConstraint::Max);
        let payload = self.Max;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Max` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Max`.
            pub unsafe fn as_Max(&self) -> &u16 {
                debug_assert_eq!(self.discriminant(), DiscriminantConstraint::Max);
        let payload = &self.Max;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Min`, with the appropriate payload
    pub fn Min(arg: u16) -> Self {
            let mut answer = Self {
                Min: arg
            };

            answer.set_discriminant(DiscriminantConstraint::Min);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Min` and convert it to `Min`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Min`.
            pub unsafe fn into_Min(self) -> u16 {
                debug_assert_eq!(self.discriminant(), DiscriminantConstraint::Min);
        let payload = self.Min;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Min` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Min`.
            pub unsafe fn as_Min(&self) -> &u16 {
                debug_assert_eq!(self.discriminant(), DiscriminantConstraint::Min);
        let payload = &self.Min;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Percentage`, with the appropriate payload
    pub fn Percentage(arg: u16) -> Self {
            let mut answer = Self {
                Percentage: arg
            };

            answer.set_discriminant(DiscriminantConstraint::Percentage);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Percentage` and convert it to `Percentage`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Percentage`.
            pub unsafe fn into_Percentage(self) -> u16 {
                debug_assert_eq!(self.discriminant(), DiscriminantConstraint::Percentage);
        let payload = self.Percentage;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Percentage` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Percentage`.
            pub unsafe fn as_Percentage(&self) -> &u16 {
                debug_assert_eq!(self.discriminant(), DiscriminantConstraint::Percentage);
        let payload = &self.Percentage;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Ratio`, with the appropriate payload
    pub fn Ratio(arg0: u32, arg1: u32) -> Self {
            let mut answer = Self {
                Ratio: ConstraintRatio {
                    f0: arg0,
                    f1: arg1,
                }
            };

            answer.set_discriminant(DiscriminantConstraint::Ratio);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Ratio` and convert it to `Ratio`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Ratio`.
            pub unsafe fn into_Ratio(self) -> (u32, u32) {
                debug_assert_eq!(self.discriminant(), DiscriminantConstraint::Ratio);
        let payload = self.Ratio;

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Constraint` has a `.discriminant()` of `Ratio` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Ratio`.
            pub unsafe fn as_Ratio(&self) -> (&u32, &u32) {
                debug_assert_eq!(self.discriminant(), DiscriminantConstraint::Ratio);
        let payload = &self.Ratio;

        (
            &payload.f0, 
            &payload.f1
        )
    }
}

impl Eq for Constraint {}

impl PartialEq for Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                DiscriminantConstraint::Length => self.Length == other.Length,
                DiscriminantConstraint::Max => self.Max == other.Max,
                DiscriminantConstraint::Min => self.Min == other.Min,
                DiscriminantConstraint::Percentage => self.Percentage == other.Percentage,
                DiscriminantConstraint::Ratio => self.Ratio == other.Ratio,
            }
        }
    }
}

impl PartialOrd for Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                DiscriminantConstraint::Length => self.Length.partial_cmp(&other.Length),
                DiscriminantConstraint::Max => self.Max.partial_cmp(&other.Max),
                DiscriminantConstraint::Min => self.Min.partial_cmp(&other.Min),
                DiscriminantConstraint::Percentage => self.Percentage.partial_cmp(&other.Percentage),
                DiscriminantConstraint::Ratio => self.Ratio.partial_cmp(&other.Ratio),
            }
        }
    }
}

impl Ord for Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                DiscriminantConstraint::Length => self.Length.cmp(&other.Length),
                DiscriminantConstraint::Max => self.Max.cmp(&other.Max),
                DiscriminantConstraint::Min => self.Min.cmp(&other.Min),
                DiscriminantConstraint::Percentage => self.Percentage.cmp(&other.Percentage),
                DiscriminantConstraint::Ratio => self.Ratio.cmp(&other.Ratio),
            }
        }
    }
}

impl Copy for Constraint {}

impl Clone for Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                DiscriminantConstraint::Length => Self {
                    Length: self.Length.clone(),
                },
                DiscriminantConstraint::Max => Self {
                    Max: self.Max.clone(),
                },
                DiscriminantConstraint::Min => Self {
                    Min: self.Min.clone(),
                },
                DiscriminantConstraint::Percentage => Self {
                    Percentage: self.Percentage.clone(),
                },
                DiscriminantConstraint::Ratio => Self {
                    Ratio: self.Ratio.clone(),
                },
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            DiscriminantConstraint::Length => unsafe {
                    DiscriminantConstraint::Length.hash(state);
                    self.Length.hash(state);
                },
            DiscriminantConstraint::Max => unsafe {
                    DiscriminantConstraint::Max.hash(state);
                    self.Max.hash(state);
                },
            DiscriminantConstraint::Min => unsafe {
                    DiscriminantConstraint::Min.hash(state);
                    self.Min.hash(state);
                },
            DiscriminantConstraint::Percentage => unsafe {
                    DiscriminantConstraint::Percentage.hash(state);
                    self.Percentage.hash(state);
                },
            DiscriminantConstraint::Ratio => unsafe {
                    DiscriminantConstraint::Ratio.hash(state);
                    self.Ratio.hash(state);
                },
        }
    }
}

impl core::fmt::Debug for Constraint {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Constraint::")?;

        unsafe {
            match self.discriminant() {
                DiscriminantConstraint::Length => f.debug_tuple("Length")
        .field(&self.Length)
        .finish(),
                DiscriminantConstraint::Max => f.debug_tuple("Max")
        .field(&self.Max)
        .finish(),
                DiscriminantConstraint::Min => f.debug_tuple("Min")
        .field(&self.Min)
        .finish(),
                DiscriminantConstraint::Percentage => f.debug_tuple("Percentage")
        .field(&self.Percentage)
        .finish(),
                DiscriminantConstraint::Ratio => f.debug_tuple("Ratio")
        .field(&(&self.Ratio).f0)
.field(&(&self.Ratio).f1)
        .finish(),
            }
        }
    }
}

impl KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> DiscriminantKeyCode {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, DiscriminantKeyCode>(*bytes.as_ptr().add(4))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: DiscriminantKeyCode) {
        let discriminant_ptr: *mut DiscriminantKeyCode = (self as *mut KeyCode).cast();

        unsafe {
            *(discriminant_ptr.add(4)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyBackTab, which has no payload.
    pub const KeyBackTab: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyBackTab as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyBackTab tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyBackTab(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyBackTab tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyBackTab(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyBackspace, which has no payload.
    pub const KeyBackspace: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyBackspace as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyBackspace tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyBackspace(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyBackspace tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyBackspace(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyCapsLock, which has no payload.
    pub const KeyCapsLock: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyCapsLock as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyCapsLock tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyCapsLock(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyCapsLock tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyCapsLock(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyDelete, which has no payload.
    pub const KeyDelete: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyDelete as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyDelete tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyDelete(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyDelete tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyDelete(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyDown, which has no payload.
    pub const KeyDown: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyDown as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyDown tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyDown(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyDown tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyDown(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyEnd, which has no payload.
    pub const KeyEnd: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyEnd as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyEnd tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyEnd(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyEnd tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyEnd(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyEnter, which has no payload.
    pub const KeyEnter: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyEnter as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyEnter tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyEnter(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyEnter tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyEnter(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyEsc, which has no payload.
    pub const KeyEsc: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyEsc as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyEsc tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyEsc(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyEsc tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyEsc(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `KeyFunction`, with the appropriate payload
    pub fn KeyFunction(arg: u8) -> Self {
            let mut answer = Self {
                KeyFunction: arg
            };

            answer.set_discriminant(DiscriminantKeyCode::KeyFunction);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `KeyFunction` and convert it to `KeyFunction`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyFunction`.
            pub unsafe fn into_KeyFunction(self) -> u8 {
                debug_assert_eq!(self.discriminant(), DiscriminantKeyCode::KeyFunction);
        let payload = self.KeyFunction;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `KeyFunction` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyFunction`.
            pub unsafe fn as_KeyFunction(&self) -> &u8 {
                debug_assert_eq!(self.discriminant(), DiscriminantKeyCode::KeyFunction);
        let payload = &self.KeyFunction;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyHome, which has no payload.
    pub const KeyHome: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyHome as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyHome tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyHome(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyHome tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyHome(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyInsert, which has no payload.
    pub const KeyInsert: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyInsert as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyInsert tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyInsert(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyInsert tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyInsert(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyKeypadBegin, which has no payload.
    pub const KeyKeypadBegin: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyKeypadBegin as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyKeypadBegin tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyKeypadBegin(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyKeypadBegin tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyKeypadBegin(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyLeft, which has no payload.
    pub const KeyLeft: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyLeft as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyLeft tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyLeft(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyLeft tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyLeft(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `KeyMedia`, with the appropriate payload
    pub fn KeyMedia(arg: MediaKeyCode) -> Self {
            let mut answer = Self {
                KeyMedia: arg
            };

            answer.set_discriminant(DiscriminantKeyCode::KeyMedia);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `KeyMedia` and convert it to `KeyMedia`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyMedia`.
            pub unsafe fn into_KeyMedia(self) -> MediaKeyCode {
                debug_assert_eq!(self.discriminant(), DiscriminantKeyCode::KeyMedia);
        let payload = self.KeyMedia;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `KeyMedia` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyMedia`.
            pub unsafe fn as_KeyMedia(&self) -> &MediaKeyCode {
                debug_assert_eq!(self.discriminant(), DiscriminantKeyCode::KeyMedia);
        let payload = &self.KeyMedia;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyMenu, which has no payload.
    pub const KeyMenu: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyMenu as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyMenu tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyMenu(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyMenu tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyMenu(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `KeyModifier`, with the appropriate payload
    pub fn KeyModifier(arg: ModifierKeyCode) -> Self {
            let mut answer = Self {
                KeyModifier: arg
            };

            answer.set_discriminant(DiscriminantKeyCode::KeyModifier);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `KeyModifier` and convert it to `KeyModifier`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyModifier`.
            pub unsafe fn into_KeyModifier(self) -> ModifierKeyCode {
                debug_assert_eq!(self.discriminant(), DiscriminantKeyCode::KeyModifier);
        let payload = self.KeyModifier;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `KeyModifier` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyModifier`.
            pub unsafe fn as_KeyModifier(&self) -> &ModifierKeyCode {
                debug_assert_eq!(self.discriminant(), DiscriminantKeyCode::KeyModifier);
        let payload = &self.KeyModifier;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyNull, which has no payload.
    pub const KeyNull: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyNull as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyNull tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyNull(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyNull tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyNull(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyNumLock, which has no payload.
    pub const KeyNumLock: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyNumLock as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyNumLock tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyNumLock(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyNumLock tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyNumLock(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyPageDown, which has no payload.
    pub const KeyPageDown: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyPageDown as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyPageDown tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyPageDown(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyPageDown tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyPageDown(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyPageUp, which has no payload.
    pub const KeyPageUp: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyPageUp as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyPageUp tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyPageUp(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyPageUp tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyPageUp(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyPause, which has no payload.
    pub const KeyPause: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyPause as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyPause tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyPause(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyPause tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyPause(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyPrintScreen, which has no payload.
    pub const KeyPrintScreen: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyPrintScreen as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyPrintScreen tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyPrintScreen(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyPrintScreen tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyPrintScreen(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyRight, which has no payload.
    pub const KeyRight: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyRight as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyRight tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyRight(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyRight tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyRight(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `KeyScalar`, with the appropriate payload
    pub fn KeyScalar(arg: u32) -> Self {
            let mut answer = Self {
                KeyScalar: arg
            };

            answer.set_discriminant(DiscriminantKeyCode::KeyScalar);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `KeyScalar` and convert it to `KeyScalar`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyScalar`.
            pub unsafe fn into_KeyScalar(self) -> u32 {
                debug_assert_eq!(self.discriminant(), DiscriminantKeyCode::KeyScalar);
        let payload = self.KeyScalar;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `KeyCode` has a `.discriminant()` of `KeyScalar` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyScalar`.
            pub unsafe fn as_KeyScalar(&self) -> &u32 {
                debug_assert_eq!(self.discriminant(), DiscriminantKeyCode::KeyScalar);
        let payload = &self.KeyScalar;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyScrollLock, which has no payload.
    pub const KeyScrollLock: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyScrollLock as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyScrollLock tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyScrollLock(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyScrollLock tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyScrollLock(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyTab, which has no payload.
    pub const KeyTab: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyTab as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyTab tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyTab(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyTab tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyTab(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named KeyUp, which has no payload.
    pub const KeyUp: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<KeyCode>()];

        bytes[4] = DiscriminantKeyCode::KeyUp as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<KeyCode>()], KeyCode>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the KeyUp tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_KeyUp(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the KeyUp tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_KeyUp(&self) {
        ()
    }
}

impl Eq for KeyCode {}

impl PartialEq for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                DiscriminantKeyCode::KeyBackTab => true,
                DiscriminantKeyCode::KeyBackspace => true,
                DiscriminantKeyCode::KeyCapsLock => true,
                DiscriminantKeyCode::KeyDelete => true,
                DiscriminantKeyCode::KeyDown => true,
                DiscriminantKeyCode::KeyEnd => true,
                DiscriminantKeyCode::KeyEnter => true,
                DiscriminantKeyCode::KeyEsc => true,
                DiscriminantKeyCode::KeyFunction => self.KeyFunction == other.KeyFunction,
                DiscriminantKeyCode::KeyHome => true,
                DiscriminantKeyCode::KeyInsert => true,
                DiscriminantKeyCode::KeyKeypadBegin => true,
                DiscriminantKeyCode::KeyLeft => true,
                DiscriminantKeyCode::KeyMedia => self.KeyMedia == other.KeyMedia,
                DiscriminantKeyCode::KeyMenu => true,
                DiscriminantKeyCode::KeyModifier => self.KeyModifier == other.KeyModifier,
                DiscriminantKeyCode::KeyNull => true,
                DiscriminantKeyCode::KeyNumLock => true,
                DiscriminantKeyCode::KeyPageDown => true,
                DiscriminantKeyCode::KeyPageUp => true,
                DiscriminantKeyCode::KeyPause => true,
                DiscriminantKeyCode::KeyPrintScreen => true,
                DiscriminantKeyCode::KeyRight => true,
                DiscriminantKeyCode::KeyScalar => self.KeyScalar == other.KeyScalar,
                DiscriminantKeyCode::KeyScrollLock => true,
                DiscriminantKeyCode::KeyTab => true,
                DiscriminantKeyCode::KeyUp => true,
            }
        }
    }
}

impl PartialOrd for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                DiscriminantKeyCode::KeyBackTab => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyBackspace => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyCapsLock => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyDelete => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyDown => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyEnd => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyEnter => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyEsc => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyFunction => self.KeyFunction.partial_cmp(&other.KeyFunction),
                DiscriminantKeyCode::KeyHome => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyInsert => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyKeypadBegin => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyLeft => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyMedia => self.KeyMedia.partial_cmp(&other.KeyMedia),
                DiscriminantKeyCode::KeyMenu => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyModifier => self.KeyModifier.partial_cmp(&other.KeyModifier),
                DiscriminantKeyCode::KeyNull => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyNumLock => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyPageDown => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyPageUp => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyPause => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyPrintScreen => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyRight => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyScalar => self.KeyScalar.partial_cmp(&other.KeyScalar),
                DiscriminantKeyCode::KeyScrollLock => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyTab => Some(core::cmp::Ordering::Equal),
                DiscriminantKeyCode::KeyUp => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                DiscriminantKeyCode::KeyBackTab => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyBackspace => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyCapsLock => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyDelete => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyDown => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyEnd => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyEnter => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyEsc => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyFunction => self.KeyFunction.cmp(&other.KeyFunction),
                DiscriminantKeyCode::KeyHome => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyInsert => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyKeypadBegin => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyLeft => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyMedia => self.KeyMedia.cmp(&other.KeyMedia),
                DiscriminantKeyCode::KeyMenu => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyModifier => self.KeyModifier.cmp(&other.KeyModifier),
                DiscriminantKeyCode::KeyNull => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyNumLock => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyPageDown => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyPageUp => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyPause => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyPrintScreen => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyRight => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyScalar => self.KeyScalar.cmp(&other.KeyScalar),
                DiscriminantKeyCode::KeyScrollLock => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyTab => core::cmp::Ordering::Equal,
                DiscriminantKeyCode::KeyUp => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Copy for KeyCode {}

impl Clone for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                DiscriminantKeyCode::KeyBackTab => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyBackspace => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyCapsLock => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyDelete => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyDown => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyEnd => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyEnter => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyEsc => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyFunction => Self {
                    KeyFunction: self.KeyFunction.clone(),
                },
                DiscriminantKeyCode::KeyHome => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyInsert => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyKeypadBegin => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyLeft => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyMedia => Self {
                    KeyMedia: self.KeyMedia.clone(),
                },
                DiscriminantKeyCode::KeyMenu => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyModifier => Self {
                    KeyModifier: self.KeyModifier.clone(),
                },
                DiscriminantKeyCode::KeyNull => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyNumLock => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyPageDown => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyPageUp => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyPause => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyPrintScreen => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyRight => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyScalar => Self {
                    KeyScalar: self.KeyScalar.clone(),
                },
                DiscriminantKeyCode::KeyScrollLock => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyTab => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantKeyCode::KeyUp => core::mem::transmute::<
                    core::mem::MaybeUninit<KeyCode>,
                    KeyCode,
                >(core::mem::MaybeUninit::uninit()),
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            DiscriminantKeyCode::KeyBackTab => DiscriminantKeyCode::KeyBackTab.hash(state),
            DiscriminantKeyCode::KeyBackspace => DiscriminantKeyCode::KeyBackspace.hash(state),
            DiscriminantKeyCode::KeyCapsLock => DiscriminantKeyCode::KeyCapsLock.hash(state),
            DiscriminantKeyCode::KeyDelete => DiscriminantKeyCode::KeyDelete.hash(state),
            DiscriminantKeyCode::KeyDown => DiscriminantKeyCode::KeyDown.hash(state),
            DiscriminantKeyCode::KeyEnd => DiscriminantKeyCode::KeyEnd.hash(state),
            DiscriminantKeyCode::KeyEnter => DiscriminantKeyCode::KeyEnter.hash(state),
            DiscriminantKeyCode::KeyEsc => DiscriminantKeyCode::KeyEsc.hash(state),
            DiscriminantKeyCode::KeyFunction => unsafe {
                    DiscriminantKeyCode::KeyFunction.hash(state);
                    self.KeyFunction.hash(state);
                },
            DiscriminantKeyCode::KeyHome => DiscriminantKeyCode::KeyHome.hash(state),
            DiscriminantKeyCode::KeyInsert => DiscriminantKeyCode::KeyInsert.hash(state),
            DiscriminantKeyCode::KeyKeypadBegin => DiscriminantKeyCode::KeyKeypadBegin.hash(state),
            DiscriminantKeyCode::KeyLeft => DiscriminantKeyCode::KeyLeft.hash(state),
            DiscriminantKeyCode::KeyMedia => unsafe {
                    DiscriminantKeyCode::KeyMedia.hash(state);
                    self.KeyMedia.hash(state);
                },
            DiscriminantKeyCode::KeyMenu => DiscriminantKeyCode::KeyMenu.hash(state),
            DiscriminantKeyCode::KeyModifier => unsafe {
                    DiscriminantKeyCode::KeyModifier.hash(state);
                    self.KeyModifier.hash(state);
                },
            DiscriminantKeyCode::KeyNull => DiscriminantKeyCode::KeyNull.hash(state),
            DiscriminantKeyCode::KeyNumLock => DiscriminantKeyCode::KeyNumLock.hash(state),
            DiscriminantKeyCode::KeyPageDown => DiscriminantKeyCode::KeyPageDown.hash(state),
            DiscriminantKeyCode::KeyPageUp => DiscriminantKeyCode::KeyPageUp.hash(state),
            DiscriminantKeyCode::KeyPause => DiscriminantKeyCode::KeyPause.hash(state),
            DiscriminantKeyCode::KeyPrintScreen => DiscriminantKeyCode::KeyPrintScreen.hash(state),
            DiscriminantKeyCode::KeyRight => DiscriminantKeyCode::KeyRight.hash(state),
            DiscriminantKeyCode::KeyScalar => unsafe {
                    DiscriminantKeyCode::KeyScalar.hash(state);
                    self.KeyScalar.hash(state);
                },
            DiscriminantKeyCode::KeyScrollLock => DiscriminantKeyCode::KeyScrollLock.hash(state),
            DiscriminantKeyCode::KeyTab => DiscriminantKeyCode::KeyTab.hash(state),
            DiscriminantKeyCode::KeyUp => DiscriminantKeyCode::KeyUp.hash(state),
        }
    }
}

impl core::fmt::Debug for KeyCode {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("KeyCode::")?;

        unsafe {
            match self.discriminant() {
                DiscriminantKeyCode::KeyBackTab => f.write_str("KeyBackTab"),
                DiscriminantKeyCode::KeyBackspace => f.write_str("KeyBackspace"),
                DiscriminantKeyCode::KeyCapsLock => f.write_str("KeyCapsLock"),
                DiscriminantKeyCode::KeyDelete => f.write_str("KeyDelete"),
                DiscriminantKeyCode::KeyDown => f.write_str("KeyDown"),
                DiscriminantKeyCode::KeyEnd => f.write_str("KeyEnd"),
                DiscriminantKeyCode::KeyEnter => f.write_str("KeyEnter"),
                DiscriminantKeyCode::KeyEsc => f.write_str("KeyEsc"),
                DiscriminantKeyCode::KeyFunction => f.debug_tuple("KeyFunction")
        .field(&self.KeyFunction)
        .finish(),
                DiscriminantKeyCode::KeyHome => f.write_str("KeyHome"),
                DiscriminantKeyCode::KeyInsert => f.write_str("KeyInsert"),
                DiscriminantKeyCode::KeyKeypadBegin => f.write_str("KeyKeypadBegin"),
                DiscriminantKeyCode::KeyLeft => f.write_str("KeyLeft"),
                DiscriminantKeyCode::KeyMedia => f.debug_tuple("KeyMedia")
        .field(&self.KeyMedia)
        .finish(),
                DiscriminantKeyCode::KeyMenu => f.write_str("KeyMenu"),
                DiscriminantKeyCode::KeyModifier => f.debug_tuple("KeyModifier")
        .field(&self.KeyModifier)
        .finish(),
                DiscriminantKeyCode::KeyNull => f.write_str("KeyNull"),
                DiscriminantKeyCode::KeyNumLock => f.write_str("KeyNumLock"),
                DiscriminantKeyCode::KeyPageDown => f.write_str("KeyPageDown"),
                DiscriminantKeyCode::KeyPageUp => f.write_str("KeyPageUp"),
                DiscriminantKeyCode::KeyPause => f.write_str("KeyPause"),
                DiscriminantKeyCode::KeyPrintScreen => f.write_str("KeyPrintScreen"),
                DiscriminantKeyCode::KeyRight => f.write_str("KeyRight"),
                DiscriminantKeyCode::KeyScalar => f.debug_tuple("KeyScalar")
        .field(&self.KeyScalar)
        .finish(),
                DiscriminantKeyCode::KeyScrollLock => f.write_str("KeyScrollLock"),
                DiscriminantKeyCode::KeyTab => f.write_str("KeyTab"),
                DiscriminantKeyCode::KeyUp => f.write_str("KeyUp"),
            }
        }
    }
}

impl Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> DiscriminantColor {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, DiscriminantColor>(*bytes.as_ptr().add(0))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: DiscriminantColor) {
        let discriminant_ptr: *mut DiscriminantColor = (self as *mut Color).cast();

        unsafe {
            *(discriminant_ptr.add(0)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Black, which has no payload.
    pub const Black: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Black as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Black tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Black(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Black tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Black(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Blue, which has no payload.
    pub const Blue: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Blue as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Blue tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Blue(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Blue tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Blue(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Cyan, which has no payload.
    pub const Cyan: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Cyan as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Cyan tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Cyan(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Cyan tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Cyan(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named DarkGray, which has no payload.
    pub const DarkGray: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::DarkGray as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the DarkGray tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_DarkGray(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the DarkGray tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_DarkGray(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Gray, which has no payload.
    pub const Gray: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Gray as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Gray tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Gray(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Gray tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Gray(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Green, which has no payload.
    pub const Green: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Green as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Green tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Green(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Green tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Green(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named LightBlue, which has no payload.
    pub const LightBlue: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::LightBlue as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the LightBlue tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_LightBlue(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the LightBlue tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_LightBlue(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named LightCyan, which has no payload.
    pub const LightCyan: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::LightCyan as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the LightCyan tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_LightCyan(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the LightCyan tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_LightCyan(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named LightGreen, which has no payload.
    pub const LightGreen: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::LightGreen as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the LightGreen tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_LightGreen(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the LightGreen tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_LightGreen(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named LightMagenta, which has no payload.
    pub const LightMagenta: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::LightMagenta as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the LightMagenta tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_LightMagenta(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the LightMagenta tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_LightMagenta(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named LightRed, which has no payload.
    pub const LightRed: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::LightRed as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the LightRed tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_LightRed(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the LightRed tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_LightRed(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named LightYellow, which has no payload.
    pub const LightYellow: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::LightYellow as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the LightYellow tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_LightYellow(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the LightYellow tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_LightYellow(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Magenta, which has no payload.
    pub const Magenta: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Magenta as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Magenta tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Magenta(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Magenta tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Magenta(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_None(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_None(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Red, which has no payload.
    pub const Red: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Red as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Red tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Red(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Red tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Red(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named White, which has no payload.
    pub const White: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::White as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the White tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_White(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the White tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_White(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Yellow, which has no payload.
    pub const Yellow: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Yellow as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Yellow tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Yellow(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Yellow tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Yellow(&self) {
        ()
    }
}

impl Eq for Color {}

impl PartialEq for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                DiscriminantColor::Black => true,
                DiscriminantColor::Blue => true,
                DiscriminantColor::Cyan => true,
                DiscriminantColor::DarkGray => true,
                DiscriminantColor::Gray => true,
                DiscriminantColor::Green => true,
                DiscriminantColor::LightBlue => true,
                DiscriminantColor::LightCyan => true,
                DiscriminantColor::LightGreen => true,
                DiscriminantColor::LightMagenta => true,
                DiscriminantColor::LightRed => true,
                DiscriminantColor::LightYellow => true,
                DiscriminantColor::Magenta => true,
                DiscriminantColor::None => true,
                DiscriminantColor::Red => true,
                DiscriminantColor::White => true,
                DiscriminantColor::Yellow => true,
            }
        }
    }
}

impl PartialOrd for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                DiscriminantColor::Black => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Blue => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Cyan => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::DarkGray => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Gray => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Green => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::LightBlue => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::LightCyan => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::LightGreen => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::LightMagenta => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::LightRed => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::LightYellow => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Magenta => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::None => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Red => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::White => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Yellow => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                DiscriminantColor::Black => core::cmp::Ordering::Equal,
                DiscriminantColor::Blue => core::cmp::Ordering::Equal,
                DiscriminantColor::Cyan => core::cmp::Ordering::Equal,
                DiscriminantColor::DarkGray => core::cmp::Ordering::Equal,
                DiscriminantColor::Gray => core::cmp::Ordering::Equal,
                DiscriminantColor::Green => core::cmp::Ordering::Equal,
                DiscriminantColor::LightBlue => core::cmp::Ordering::Equal,
                DiscriminantColor::LightCyan => core::cmp::Ordering::Equal,
                DiscriminantColor::LightGreen => core::cmp::Ordering::Equal,
                DiscriminantColor::LightMagenta => core::cmp::Ordering::Equal,
                DiscriminantColor::LightRed => core::cmp::Ordering::Equal,
                DiscriminantColor::LightYellow => core::cmp::Ordering::Equal,
                DiscriminantColor::Magenta => core::cmp::Ordering::Equal,
                DiscriminantColor::None => core::cmp::Ordering::Equal,
                DiscriminantColor::Red => core::cmp::Ordering::Equal,
                DiscriminantColor::White => core::cmp::Ordering::Equal,
                DiscriminantColor::Yellow => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Copy for Color {}

impl Clone for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                DiscriminantColor::Black => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Blue => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Cyan => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::DarkGray => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Gray => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Green => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::LightBlue => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::LightCyan => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::LightGreen => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::LightMagenta => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::LightRed => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::LightYellow => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Magenta => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::None => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Red => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::White => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Yellow => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            DiscriminantColor::Black => DiscriminantColor::Black.hash(state),
            DiscriminantColor::Blue => DiscriminantColor::Blue.hash(state),
            DiscriminantColor::Cyan => DiscriminantColor::Cyan.hash(state),
            DiscriminantColor::DarkGray => DiscriminantColor::DarkGray.hash(state),
            DiscriminantColor::Gray => DiscriminantColor::Gray.hash(state),
            DiscriminantColor::Green => DiscriminantColor::Green.hash(state),
            DiscriminantColor::LightBlue => DiscriminantColor::LightBlue.hash(state),
            DiscriminantColor::LightCyan => DiscriminantColor::LightCyan.hash(state),
            DiscriminantColor::LightGreen => DiscriminantColor::LightGreen.hash(state),
            DiscriminantColor::LightMagenta => DiscriminantColor::LightMagenta.hash(state),
            DiscriminantColor::LightRed => DiscriminantColor::LightRed.hash(state),
            DiscriminantColor::LightYellow => DiscriminantColor::LightYellow.hash(state),
            DiscriminantColor::Magenta => DiscriminantColor::Magenta.hash(state),
            DiscriminantColor::None => DiscriminantColor::None.hash(state),
            DiscriminantColor::Red => DiscriminantColor::Red.hash(state),
            DiscriminantColor::White => DiscriminantColor::White.hash(state),
            DiscriminantColor::Yellow => DiscriminantColor::Yellow.hash(state),
        }
    }
}

impl core::fmt::Debug for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Color::")?;

        unsafe {
            match self.discriminant() {
                DiscriminantColor::Black => f.write_str("Black"),
                DiscriminantColor::Blue => f.write_str("Blue"),
                DiscriminantColor::Cyan => f.write_str("Cyan"),
                DiscriminantColor::DarkGray => f.write_str("DarkGray"),
                DiscriminantColor::Gray => f.write_str("Gray"),
                DiscriminantColor::Green => f.write_str("Green"),
                DiscriminantColor::LightBlue => f.write_str("LightBlue"),
                DiscriminantColor::LightCyan => f.write_str("LightCyan"),
                DiscriminantColor::LightGreen => f.write_str("LightGreen"),
                DiscriminantColor::LightMagenta => f.write_str("LightMagenta"),
                DiscriminantColor::LightRed => f.write_str("LightRed"),
                DiscriminantColor::LightYellow => f.write_str("LightYellow"),
                DiscriminantColor::Magenta => f.write_str("Magenta"),
                DiscriminantColor::None => f.write_str("None"),
                DiscriminantColor::Red => f.write_str("Red"),
                DiscriminantColor::White => f.write_str("White"),
                DiscriminantColor::Yellow => f.write_str("Yellow"),
            }
        }
    }
}
