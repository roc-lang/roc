// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command


#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
// #[repr(transparent)]
#[derive(Clone, Eq, Ord, Hash, PartialEq, PartialOrd)]
pub struct Elem {
    f0: roc_std::RocList<roc_std::RocList<Span>>,
    f1: ParagraphConfig,
}


#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Span {
    pub style: Styles,
    pub text: roc_std::RocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum DiscriminantEvent {
    KeyDown = 0,
    KeyUp = 1,
    Resize = 2,
    Tick = 3,
}

impl core::fmt::Debug for DiscriminantEvent {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::KeyDown => f.write_str("DiscriminantEvent::KeyDown"),
            Self::KeyUp => f.write_str("DiscriminantEvent::KeyUp"),
            Self::Resize => f.write_str("DiscriminantEvent::Resize"),
            Self::Tick => f.write_str("DiscriminantEvent::Tick"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Event {
    KeyDown: KeyCode,
    KeyUp: KeyCode,
    Resize: Bounds,
    Tick: roc_std::U128,
    _sizer: [u8; 32],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Model {
    pub text: roc_std::RocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum BorderModifier {
    ALL = 0,
    BOTTOM = 1,
    LEFT = 2,
    NONE = 3,
    RIGHT = 4,
    TOP = 5,
}

impl core::fmt::Debug for BorderModifier {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ALL => f.write_str("BorderModifier::ALL"),
            Self::BOTTOM => f.write_str("BorderModifier::BOTTOM"),
            Self::LEFT => f.write_str("BorderModifier::LEFT"),
            Self::NONE => f.write_str("BorderModifier::NONE"),
            Self::RIGHT => f.write_str("BorderModifier::RIGHT"),
            Self::TOP => f.write_str("BorderModifier::TOP"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum TextModifier {
    BOLD = 0,
    CROSSEDOUT = 1,
    DIM = 2,
    HIDDEN = 3,
    ITALIC = 4,
    RAPIDBLINK = 5,
    REVERSED = 6,
    SLOWBLINK = 7,
    UNDERLINED = 8,
}

impl core::fmt::Debug for TextModifier {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BOLD => f.write_str("TextModifier::BOLD"),
            Self::CROSSEDOUT => f.write_str("TextModifier::CROSSEDOUT"),
            Self::DIM => f.write_str("TextModifier::DIM"),
            Self::HIDDEN => f.write_str("TextModifier::HIDDEN"),
            Self::ITALIC => f.write_str("TextModifier::ITALIC"),
            Self::RAPIDBLINK => f.write_str("TextModifier::RAPIDBLINK"),
            Self::REVERSED => f.write_str("TextModifier::REVERSED"),
            Self::SLOWBLINK => f.write_str("TextModifier::SLOWBLINK"),
            Self::UNDERLINED => f.write_str("TextModifier::UNDERLINED"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Default, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Bounds {
    pub height: f32,
    pub width: f32,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R1 {
    // pub init: TODO_roc_function_65,
    // pub render: TODO_roc_function_69,
    // pub update: TODO_roc_function_67,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum KeyCode {
    Down = 0,
    Left = 1,
    Other = 2,
    Right = 3,
    Up = 4,
}

impl core::fmt::Debug for KeyCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Down => f.write_str("KeyCode::Down"),
            Self::Left => f.write_str("KeyCode::Left"),
            Self::Other => f.write_str("KeyCode::Other"),
            Self::Right => f.write_str("KeyCode::Right"),
            Self::Up => f.write_str("KeyCode::Up"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct ParagraphConfig {
    pub borderStyle: Styles,
    pub borders: roc_std::RocList<BorderModifier>,
    pub style: Styles,
    pub title: roc_std::RocStr,
    pub titleStyle: Styles,
    pub borderType: BorderType,
    pub textAlignment: Alignment,
    pub titleAlignment: Alignment,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum Alignment {
    Center = 0,
    Left = 1,
    Right = 2,
}

impl core::fmt::Debug for Alignment {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Center => f.write_str("Alignment::Center"),
            Self::Left => f.write_str("Alignment::Left"),
            Self::Right => f.write_str("Alignment::Right"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum BorderType {
    Double = 0,
    Plain = 1,
    Rounded = 2,
    Thick = 3,
}

impl core::fmt::Debug for BorderType {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Double => f.write_str("BorderType::Double"),
            Self::Plain => f.write_str("BorderType::Plain"),
            Self::Rounded => f.write_str("BorderType::Rounded"),
            Self::Thick => f.write_str("BorderType::Thick"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Styles {
    pub modifiers: roc_std::RocList<TextModifier>,
    pub bg: Color,
    pub fg: Color,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum DiscriminantColor {
    Black = 0,
    Blue = 1,
    Cyan = 2,
    DarkGray = 3,
    Gray = 4,
    Green = 5,
    LightBlue = 6,
    LightCyan = 7,
    LightGreen = 8,
    LightMagenta = 9,
    LightRed = 10,
    LightYellow = 11,
    Magenta = 12,
    None = 13,
    Red = 14,
    White = 15,
    Yellow = 16,
}

impl core::fmt::Debug for DiscriminantColor {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Black => f.write_str("DiscriminantColor::Black"),
            Self::Blue => f.write_str("DiscriminantColor::Blue"),
            Self::Cyan => f.write_str("DiscriminantColor::Cyan"),
            Self::DarkGray => f.write_str("DiscriminantColor::DarkGray"),
            Self::Gray => f.write_str("DiscriminantColor::Gray"),
            Self::Green => f.write_str("DiscriminantColor::Green"),
            Self::LightBlue => f.write_str("DiscriminantColor::LightBlue"),
            Self::LightCyan => f.write_str("DiscriminantColor::LightCyan"),
            Self::LightGreen => f.write_str("DiscriminantColor::LightGreen"),
            Self::LightMagenta => f.write_str("DiscriminantColor::LightMagenta"),
            Self::LightRed => f.write_str("DiscriminantColor::LightRed"),
            Self::LightYellow => f.write_str("DiscriminantColor::LightYellow"),
            Self::Magenta => f.write_str("DiscriminantColor::Magenta"),
            Self::None => f.write_str("DiscriminantColor::None"),
            Self::Red => f.write_str("DiscriminantColor::Red"),
            Self::White => f.write_str("DiscriminantColor::White"),
            Self::Yellow => f.write_str("DiscriminantColor::Yellow"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Color {
    _sizer: [u8; 1],
}

impl Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Paragraph, with the given payload.
    pub fn Paragraph(f0: roc_std::RocList<roc_std::RocList<Span>>, f1: ParagraphConfig) -> Self {
        Self {
            f0,
            f1,
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Since `Paragraph` only has one tag (namely, `Paragraph`),
    /// convert it to `Paragraph`'s payload.
    pub fn into_Paragraph(self) -> (roc_std::RocList<roc_std::RocList<Span>>, ParagraphConfig) {
        (self.f0, self.f1)
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Since `Paragraph` only has one tag (namely, `Paragraph`),
    /// convert it to `Paragraph`'s payload.
    pub fn as_Paragraph(&self) -> (&roc_std::RocList<roc_std::RocList<Span>>, &ParagraphConfig) {
        (&self.f0, &self.f1)
    }
}

impl core::fmt::Debug for Elem {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.debug_tuple("Elem::Paragraph")                .field(&self.f0)                .field(&self.f1)                .finish()    }

}

impl Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> DiscriminantEvent {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, DiscriminantEvent>(*bytes.as_ptr().add(16))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: DiscriminantEvent) {
        let discriminant_ptr: *mut DiscriminantEvent = (self as *mut Event).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `KeyDown`, with the appropriate payload
    pub fn KeyDown(arg: KeyCode) -> Self {
            let mut answer = Self {
                KeyDown: arg
            };

            answer.set_discriminant(DiscriminantEvent::KeyDown);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `KeyDown` and convert it to `KeyDown`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyDown`.
            pub unsafe fn into_KeyDown(self) -> KeyCode {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::KeyDown);
        let payload = self.KeyDown;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `KeyDown` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyDown`.
            pub unsafe fn as_KeyDown(&self) -> &KeyCode {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::KeyDown);
        let payload = &self.KeyDown;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `KeyUp`, with the appropriate payload
    pub fn KeyUp(arg: KeyCode) -> Self {
            let mut answer = Self {
                KeyUp: arg
            };

            answer.set_discriminant(DiscriminantEvent::KeyUp);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `KeyUp` and convert it to `KeyUp`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyUp`.
            pub unsafe fn into_KeyUp(self) -> KeyCode {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::KeyUp);
        let payload = self.KeyUp;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `KeyUp` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `KeyUp`.
            pub unsafe fn as_KeyUp(&self) -> &KeyCode {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::KeyUp);
        let payload = &self.KeyUp;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Resize`, with the appropriate payload
    pub fn Resize(arg0: Bounds) -> Self {
            let mut answer = Self {
                Resize: arg0
            };

            answer.set_discriminant(DiscriminantEvent::Resize);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Resize` and convert it to `Resize`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Resize`.
            pub unsafe fn into_Resize(self) -> Bounds {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::Resize);
        let payload = self.Resize;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Resize` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Resize`.
            pub unsafe fn as_Resize(&self) -> &Bounds {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::Resize);
        let payload = &self.Resize;

        
        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Tick`, with the appropriate payload
    pub fn Tick(arg: roc_std::U128) -> Self {
            let mut answer = Self {
                Tick: arg
            };

            answer.set_discriminant(DiscriminantEvent::Tick);

            answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Tick` and convert it to `Tick`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Tick`.
            pub unsafe fn into_Tick(self) -> roc_std::U128 {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::Tick);
        let payload = self.Tick;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Event` has a `.discriminant()` of `Tick` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Tick`.
            pub unsafe fn as_Tick(&self) -> &roc_std::U128 {
                debug_assert_eq!(self.discriminant(), DiscriminantEvent::Tick);
        let payload = &self.Tick;

        &payload
    }
}

impl PartialEq for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                DiscriminantEvent::KeyDown => self.KeyDown == other.KeyDown,
                DiscriminantEvent::KeyUp => self.KeyUp == other.KeyUp,
                DiscriminantEvent::Resize => self.Resize == other.Resize,
                DiscriminantEvent::Tick => self.Tick == other.Tick,
            }
        }
    }
}

impl PartialOrd for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                DiscriminantEvent::KeyDown => self.KeyDown.partial_cmp(&other.KeyDown),
                DiscriminantEvent::KeyUp => self.KeyUp.partial_cmp(&other.KeyUp),
                DiscriminantEvent::Resize => self.Resize.partial_cmp(&other.Resize),
                DiscriminantEvent::Tick => self.Tick.partial_cmp(&other.Tick),
            }
        }
    }
}

impl Copy for Event {}

impl Clone for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                DiscriminantEvent::KeyDown => Self {
                    KeyDown: self.KeyDown.clone(),
                },
                DiscriminantEvent::KeyUp => Self {
                    KeyUp: self.KeyUp.clone(),
                },
                DiscriminantEvent::Resize => Self {
                    Resize: self.Resize.clone(),
                },
                DiscriminantEvent::Tick => Self {
                    Tick: self.Tick.clone(),
                },
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::fmt::Debug for Event {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Event::")?;

        unsafe {
            match self.discriminant() {
                DiscriminantEvent::KeyDown => f.debug_tuple("KeyDown")
        .field(&self.KeyDown)
        .finish(),
                DiscriminantEvent::KeyUp => f.debug_tuple("KeyUp")
        .field(&self.KeyUp)
        .finish(),
                DiscriminantEvent::Resize => f.debug_tuple("Resize")
        .field(&self.Resize)
        .finish(),
                DiscriminantEvent::Tick => f.debug_tuple("Tick")
        .field(&self.Tick)
        .finish(),
            }
        }
    }
}

impl Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> DiscriminantColor {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, DiscriminantColor>(*bytes.as_ptr().add(0))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: DiscriminantColor) {
        let discriminant_ptr: *mut DiscriminantColor = (self as *mut Color).cast();

        unsafe {
            *(discriminant_ptr.add(0)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Black, which has no payload.
    pub const Black: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Black as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Black tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Black(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Black tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Black(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Blue, which has no payload.
    pub const Blue: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Blue as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Blue tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Blue(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Blue tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Blue(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Cyan, which has no payload.
    pub const Cyan: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Cyan as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Cyan tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Cyan(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Cyan tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Cyan(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named DarkGray, which has no payload.
    pub const DarkGray: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::DarkGray as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the DarkGray tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_DarkGray(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the DarkGray tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_DarkGray(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Gray, which has no payload.
    pub const Gray: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Gray as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Gray tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Gray(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Gray tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Gray(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Green, which has no payload.
    pub const Green: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Green as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Green tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Green(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Green tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Green(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named LightBlue, which has no payload.
    pub const LightBlue: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::LightBlue as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the LightBlue tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_LightBlue(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the LightBlue tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_LightBlue(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named LightCyan, which has no payload.
    pub const LightCyan: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::LightCyan as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the LightCyan tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_LightCyan(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the LightCyan tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_LightCyan(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named LightGreen, which has no payload.
    pub const LightGreen: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::LightGreen as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the LightGreen tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_LightGreen(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the LightGreen tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_LightGreen(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named LightMagenta, which has no payload.
    pub const LightMagenta: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::LightMagenta as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the LightMagenta tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_LightMagenta(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the LightMagenta tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_LightMagenta(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named LightRed, which has no payload.
    pub const LightRed: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::LightRed as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the LightRed tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_LightRed(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the LightRed tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_LightRed(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named LightYellow, which has no payload.
    pub const LightYellow: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::LightYellow as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the LightYellow tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_LightYellow(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the LightYellow tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_LightYellow(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Magenta, which has no payload.
    pub const Magenta: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Magenta as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Magenta tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Magenta(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Magenta tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Magenta(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_None(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_None(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Red, which has no payload.
    pub const Red: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Red as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Red tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Red(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Red tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Red(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named White, which has no payload.
    pub const White: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::White as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the White tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_White(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the White tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_White(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Yellow, which has no payload.
    pub const Yellow: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Color>()];

        bytes[0] = DiscriminantColor::Yellow as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Color>()], Color>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Yellow tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Yellow(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Yellow tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Yellow(&self) {
        ()
    }
}

impl Eq for Color {}

impl PartialEq for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                DiscriminantColor::Black => true,
                DiscriminantColor::Blue => true,
                DiscriminantColor::Cyan => true,
                DiscriminantColor::DarkGray => true,
                DiscriminantColor::Gray => true,
                DiscriminantColor::Green => true,
                DiscriminantColor::LightBlue => true,
                DiscriminantColor::LightCyan => true,
                DiscriminantColor::LightGreen => true,
                DiscriminantColor::LightMagenta => true,
                DiscriminantColor::LightRed => true,
                DiscriminantColor::LightYellow => true,
                DiscriminantColor::Magenta => true,
                DiscriminantColor::None => true,
                DiscriminantColor::Red => true,
                DiscriminantColor::White => true,
                DiscriminantColor::Yellow => true,
            }
        }
    }
}

impl PartialOrd for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                DiscriminantColor::Black => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Blue => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Cyan => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::DarkGray => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Gray => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Green => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::LightBlue => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::LightCyan => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::LightGreen => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::LightMagenta => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::LightRed => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::LightYellow => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Magenta => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::None => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Red => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::White => Some(core::cmp::Ordering::Equal),
                DiscriminantColor::Yellow => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                DiscriminantColor::Black => core::cmp::Ordering::Equal,
                DiscriminantColor::Blue => core::cmp::Ordering::Equal,
                DiscriminantColor::Cyan => core::cmp::Ordering::Equal,
                DiscriminantColor::DarkGray => core::cmp::Ordering::Equal,
                DiscriminantColor::Gray => core::cmp::Ordering::Equal,
                DiscriminantColor::Green => core::cmp::Ordering::Equal,
                DiscriminantColor::LightBlue => core::cmp::Ordering::Equal,
                DiscriminantColor::LightCyan => core::cmp::Ordering::Equal,
                DiscriminantColor::LightGreen => core::cmp::Ordering::Equal,
                DiscriminantColor::LightMagenta => core::cmp::Ordering::Equal,
                DiscriminantColor::LightRed => core::cmp::Ordering::Equal,
                DiscriminantColor::LightYellow => core::cmp::Ordering::Equal,
                DiscriminantColor::Magenta => core::cmp::Ordering::Equal,
                DiscriminantColor::None => core::cmp::Ordering::Equal,
                DiscriminantColor::Red => core::cmp::Ordering::Equal,
                DiscriminantColor::White => core::cmp::Ordering::Equal,
                DiscriminantColor::Yellow => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Copy for Color {}

impl Clone for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                DiscriminantColor::Black => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Blue => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Cyan => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::DarkGray => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Gray => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Green => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::LightBlue => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::LightCyan => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::LightGreen => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::LightMagenta => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::LightRed => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::LightYellow => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Magenta => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::None => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Red => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::White => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
                DiscriminantColor::Yellow => core::mem::transmute::<
                    core::mem::MaybeUninit<Color>,
                    Color,
                >(core::mem::MaybeUninit::uninit()),
            }

        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            DiscriminantColor::Black => DiscriminantColor::Black.hash(state),
            DiscriminantColor::Blue => DiscriminantColor::Blue.hash(state),
            DiscriminantColor::Cyan => DiscriminantColor::Cyan.hash(state),
            DiscriminantColor::DarkGray => DiscriminantColor::DarkGray.hash(state),
            DiscriminantColor::Gray => DiscriminantColor::Gray.hash(state),
            DiscriminantColor::Green => DiscriminantColor::Green.hash(state),
            DiscriminantColor::LightBlue => DiscriminantColor::LightBlue.hash(state),
            DiscriminantColor::LightCyan => DiscriminantColor::LightCyan.hash(state),
            DiscriminantColor::LightGreen => DiscriminantColor::LightGreen.hash(state),
            DiscriminantColor::LightMagenta => DiscriminantColor::LightMagenta.hash(state),
            DiscriminantColor::LightRed => DiscriminantColor::LightRed.hash(state),
            DiscriminantColor::LightYellow => DiscriminantColor::LightYellow.hash(state),
            DiscriminantColor::Magenta => DiscriminantColor::Magenta.hash(state),
            DiscriminantColor::None => DiscriminantColor::None.hash(state),
            DiscriminantColor::Red => DiscriminantColor::Red.hash(state),
            DiscriminantColor::White => DiscriminantColor::White.hash(state),
            DiscriminantColor::Yellow => DiscriminantColor::Yellow.hash(state),
        }
    }
}

impl core::fmt::Debug for Color {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Color::")?;

        unsafe {
            match self.discriminant() {
                DiscriminantColor::Black => f.write_str("Black"),
                DiscriminantColor::Blue => f.write_str("Blue"),
                DiscriminantColor::Cyan => f.write_str("Cyan"),
                DiscriminantColor::DarkGray => f.write_str("DarkGray"),
                DiscriminantColor::Gray => f.write_str("Gray"),
                DiscriminantColor::Green => f.write_str("Green"),
                DiscriminantColor::LightBlue => f.write_str("LightBlue"),
                DiscriminantColor::LightCyan => f.write_str("LightCyan"),
                DiscriminantColor::LightGreen => f.write_str("LightGreen"),
                DiscriminantColor::LightMagenta => f.write_str("LightMagenta"),
                DiscriminantColor::LightRed => f.write_str("LightRed"),
                DiscriminantColor::LightYellow => f.write_str("LightYellow"),
                DiscriminantColor::Magenta => f.write_str("Magenta"),
                DiscriminantColor::None => f.write_str("None"),
                DiscriminantColor::Red => f.write_str("Red"),
                DiscriminantColor::White => f.write_str("White"),
                DiscriminantColor::Yellow => f.write_str("Yellow"),
            }
        }
    }
}
