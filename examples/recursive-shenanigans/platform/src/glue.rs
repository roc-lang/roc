// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(transparent)]
pub struct Rec {
    pointer: *mut union_Rec,
}


#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
union union_Rec {
    Rec: core::mem::ManuallyDrop<Rec_Rec>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
struct Rec_Rec {
    pub f0: Below,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(transparent)]
pub struct Below {
    pointer: *mut union_Below,
}


#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
union union_Below {
    Below: core::mem::ManuallyDrop<Below_Below>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
struct Below_Below {
    pub f0: roc_std::RocList<Below>,
}

impl Rec {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn storage(&self) -> Option<&core::cell::Cell<roc_std::Storage>> {
        let untagged = self.pointer as *const core::cell::Cell<roc_std::Storage>;

        unsafe {
            Some(&*untagged.sub(1))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// This is a single-tag union, so it has no alternatives
    /// to discriminate between. This method is only included for completeness.
    pub fn discriminant(&self) -> () {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Rec`, with the appropriate payload
    pub fn Rec(arg0: Below) -> Self {
            let size = core::mem::size_of::<union_Rec>();
            let align = core::mem::align_of::<union_Rec>() as u32;

            unsafe {
                let ptr = roc_std::roc_alloc_refcounted::<union_Rec>();

                *ptr = union_Rec {
                    Rec: core::mem::ManuallyDrop::new(Rec_Rec {
                    f0: arg0,
                })
                };

                Self {
                    pointer: ptr,
                }
            }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Since `Rec` only has one tag (namely, `Rec`),
    /// convert it to `Rec`'s payload.
    pub fn into_Rec(mut self) -> Below {
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Rec;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Rec,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload.f0
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Since `Rec` only has one tag (namely, `Rec`),
    /// convert it to `Rec`'s payload.
    pub fn as_Rec(&self) -> &Below {
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Rec;

            unsafe { &(*ptr).Rec }
        };

        
        &payload.f0
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Since `Rec` only has one tag (namely, `Rec`),
    /// convert it to `Rec`'s payload.
    pub fn into_Rec(mut self) -> Below {
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Rec;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Rec,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload.f0
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Since `Rec` only has one tag (namely, `Rec`),
    /// convert it to `Rec`'s payload.
    pub fn as_Rec(&self) -> &Below {
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Rec;

            unsafe { &(*ptr).Rec }
        };

        
        &payload.f0
    }
}

impl Drop for Rec {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // We only need to do any work if there's actually a heap-allocated payload.
        if let Some(storage) = self.storage() {
            let mut new_storage = storage.get();

            // Decrement the refcount
            let needs_dealloc = !new_storage.is_readonly() && new_storage.decrease();

            if needs_dealloc {
                // Drop the payload first.
                unsafe { core::mem::ManuallyDrop::drop(&mut core::ptr::read(self.pointer).Rec); }

                // Dealloc the pointer
                let alignment = core::mem::align_of::<Self>().max(core::mem::align_of::<roc_std::Storage>());

                unsafe { crate::roc_dealloc(storage.as_ptr().cast(), alignment as u32); }
            } else {
                // Write the storage back.
                storage.set(new_storage);
            }
        }
    }
}

impl Eq for Rec {}

impl PartialEq for Rec {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
                (*self.pointer).Rec == (*other.pointer).Rec
            }
    }
}

impl PartialOrd for Rec {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        unsafe {
            (&*self.pointer).Rec.partial_cmp(&(*other.pointer).Rec)
        }
    }

}

impl Ord for Rec {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        unsafe {
            (&*self.pointer).Rec.cmp(&(*other.pointer).Rec)
        }
    }

}

impl Clone for Rec {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        if let Some(storage) = self.storage() {
            let mut new_storage = storage.get();
            if !new_storage.is_readonly() {
                new_storage.increment_reference_count();
                storage.set(new_storage);
            }
        }

        Self {
            pointer: self.pointer
        }
    }
}

impl core::hash::Hash for Rec {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        unsafe {
            (*self.pointer).Rec.hash(state)
        }    }
}

impl core::fmt::Debug for Rec {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Rec::")?;

        unsafe {
f.debug_tuple("Rec")
        .field(&(*self.pointer).Rec)
        .finish()        }
    }
}

impl Below {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn storage(&self) -> Option<&core::cell::Cell<roc_std::Storage>> {
        let untagged = self.pointer as *const core::cell::Cell<roc_std::Storage>;

        unsafe {
            Some(&*untagged.sub(1))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// This is a single-tag union, so it has no alternatives
    /// to discriminate between. This method is only included for completeness.
    pub fn discriminant(&self) -> () {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Below`, with the appropriate payload
    pub fn Below(arg0: roc_std::RocList<Below>) -> Self {
            let size = core::mem::size_of::<union_Below>();
            let align = core::mem::align_of::<union_Below>() as u32;

            unsafe {
                let ptr = roc_std::roc_alloc_refcounted::<union_Below>();

                *ptr = union_Below {
                    Below: core::mem::ManuallyDrop::new(Below_Below {
                    f0: arg0,
                })
                };

                Self {
                    pointer: ptr,
                }
            }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Since `Below` only has one tag (namely, `Below`),
    /// convert it to `Below`'s payload.
    pub fn into_Below(mut self) -> roc_std::RocList<Below> {
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Below;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Below,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload.f0
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Since `Below` only has one tag (namely, `Below`),
    /// convert it to `Below`'s payload.
    pub fn as_Below(&self) -> &roc_std::RocList<Below> {
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Below;

            unsafe { &(*ptr).Below }
        };

        
        &payload.f0
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Since `Below` only has one tag (namely, `Below`),
    /// convert it to `Below`'s payload.
    pub fn into_Below(mut self) -> roc_std::RocList<Below> {
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Below;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Below,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload.f0
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Since `Below` only has one tag (namely, `Below`),
    /// convert it to `Below`'s payload.
    pub fn as_Below(&self) -> &roc_std::RocList<Below> {
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Below;

            unsafe { &(*ptr).Below }
        };

        
        &payload.f0
    }
}

impl Drop for Below {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // We only need to do any work if there's actually a heap-allocated payload.
        if let Some(storage) = self.storage() {
            let mut new_storage = storage.get();

            // Decrement the refcount
            let needs_dealloc = !new_storage.is_readonly() && new_storage.decrease();

            if needs_dealloc {
                // Drop the payload first.
                unsafe { core::mem::ManuallyDrop::drop(&mut core::ptr::read(self.pointer).Below); }

                // Dealloc the pointer
                let alignment = core::mem::align_of::<Self>().max(core::mem::align_of::<roc_std::Storage>());

                unsafe { crate::roc_dealloc(storage.as_ptr().cast(), alignment as u32); }
            } else {
                // Write the storage back.
                storage.set(new_storage);
            }
        }
    }
}

impl Eq for Below {}

impl PartialEq for Below {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
                (*self.pointer).Below == (*other.pointer).Below
            }
    }
}

impl PartialOrd for Below {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        unsafe {
            (&*self.pointer).Below.partial_cmp(&(*other.pointer).Below)
        }
    }

}

impl Ord for Below {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        unsafe {
            (&*self.pointer).Below.cmp(&(*other.pointer).Below)
        }
    }

}

impl Clone for Below {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        if let Some(storage) = self.storage() {
            let mut new_storage = storage.get();
            if !new_storage.is_readonly() {
                new_storage.increment_reference_count();
                storage.set(new_storage);
            }
        }

        Self {
            pointer: self.pointer
        }
    }
}

impl core::hash::Hash for Below {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        unsafe {
            (*self.pointer).Below.hash(state)
        }    }
}

impl core::fmt::Debug for Below {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Below::")?;

        unsafe {
f.debug_tuple("Below")
        .field(&(*self.pointer).Below)
        .finish()        }
    }
}
