procedure Bool.1 ():
    let Bool.32 : Int1 = false;
    ret Bool.32;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.28 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.28;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.29 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.29;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.34 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.34;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.35 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.35;

procedure Bool.12 (#Attr.2, #Attr.3):
    let Bool.24 : Int1 = lowlevel NotEq #Attr.2 #Attr.3;
    ret Bool.24;

procedure Bool.12 (#Attr.2, #Attr.3):
    let Bool.26 : Int1 = lowlevel NotEq #Attr.2 #Attr.3;
    ret Bool.26;

procedure Bool.2 ():
    let Bool.31 : Int1 = true;
    ret Bool.31;

procedure Bool.3 (#Attr.2, #Attr.3):
    let Bool.33 : Int1 = lowlevel And #Attr.2 #Attr.3;
    ret Bool.33;

procedure Bool.7 (Bool.19, Bool.20):
    let Bool.25 : Int1 = CallByName Bool.12 Bool.19 Bool.20;
    ret Bool.25;

procedure Bool.7 (Bool.19, Bool.20):
    let Bool.27 : Int1 = CallByName Bool.12 Bool.19 Bool.20;
    ret Bool.27;

procedure Dict.1 (Dict.731):
    let Dict.893 : List {U32, U32} = Array [];
    let Dict.894 : List {Str, I64} = Array [];
    let Dict.895 : U64 = 0i64;
    let Dict.51 : Float32 = CallByName Dict.51;
    let Dict.52 : U8 = CallByName Dict.52;
    let Dict.892 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.893, Dict.894, Dict.895, Dict.51, Dict.52};
    ret Dict.892;

procedure Dict.10 (Dict.732, Dict.186, Dict.187):
    let Dict.185 : List {Str, I64} = StructAtIndex 1 Dict.732;
    let #Derived_gen.78 : List {U32, U32} = StructAtIndex 0 Dict.732;
    dec #Derived_gen.78;
    let Dict.1109 : {Str, Int1} = CallByName List.18 Dict.185 Dict.186 Dict.187;
    dec Dict.185;
    ret Dict.1109;

procedure Dict.100 (Dict.545, Dict.546, Dict.547):
    let Dict.1062 : U8 = CallByName Dict.22 Dict.545 Dict.546;
    let Dict.548 : U64 = CallByName Num.133 Dict.1062;
    let Dict.1061 : U8 = 1i64;
    let Dict.1060 : U64 = CallByName Num.74 Dict.547 Dict.1061;
    let Dict.1059 : U64 = CallByName Num.51 Dict.1060 Dict.546;
    let Dict.1058 : U8 = CallByName Dict.22 Dict.545 Dict.1059;
    let Dict.549 : U64 = CallByName Num.133 Dict.1058;
    let Dict.1057 : U64 = 1i64;
    let Dict.1056 : U64 = CallByName Num.75 Dict.547 Dict.1057;
    let Dict.1055 : U64 = CallByName Num.51 Dict.1056 Dict.546;
    let Dict.1054 : U8 = CallByName Dict.22 Dict.545 Dict.1055;
    let Dict.550 : U64 = CallByName Num.133 Dict.1054;
    let Dict.1053 : U8 = 16i64;
    let Dict.1050 : U64 = CallByName Num.72 Dict.548 Dict.1053;
    let Dict.1052 : U8 = 8i64;
    let Dict.1051 : U64 = CallByName Num.72 Dict.549 Dict.1052;
    let Dict.551 : U64 = CallByName Num.71 Dict.1050 Dict.1051;
    let Dict.1049 : U64 = CallByName Num.71 Dict.551 Dict.550;
    ret Dict.1049;

procedure Dict.12 (Dict.158):
    let Dict.891 : {} = Struct {};
    let Dict.739 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.1 Dict.891;
    let Dict.740 : {} = Struct {};
    let Dict.738 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName List.18 Dict.158 Dict.739 Dict.740;
    ret Dict.738;

procedure Dict.127 (Dict.128, Dict.126):
    let Dict.1106 : {} = Struct {};
    let Dict.1107 : {} = Struct {};
    let Dict.1108 : {} = Struct {};
    let Dict.1105 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = CallByName Inspect.42 Dict.126 Dict.1106 Dict.1107 Dict.1108;
    let Dict.1104 : Str = CallByName Inspect.31 Dict.1105 Dict.128;
    ret Dict.1104;

procedure Dict.159 (Dict.160, Dict.741):
    let Dict.161 : Str = StructAtIndex 0 Dict.741;
    let Dict.162 : I64 = StructAtIndex 1 Dict.741;
    let Dict.742 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.8 Dict.160 Dict.161 Dict.162;
    ret Dict.742;

procedure Dict.188 (Dict.189, Dict.1111, Dict.187):
    let Dict.190 : Str = StructAtIndex 0 Dict.1111;
    let Dict.191 : I64 = StructAtIndex 1 Dict.1111;
    let Dict.1113 : {Str, Int1} = CallByName Inspect.191 Dict.189 Dict.190 Dict.191 Dict.187;
    ret Dict.1113;

procedure Dict.20 (Dict.728):
    let Dict.155 : U64 = StructAtIndex 2 Dict.728;
    let #Derived_gen.81 : List {U32, U32} = StructAtIndex 0 Dict.728;
    dec #Derived_gen.81;
    let #Derived_gen.80 : List {Str, I64} = StructAtIndex 1 Dict.728;
    dec #Derived_gen.80;
    ret Dict.155;

procedure Dict.22 (#Attr.2, #Attr.3):
    let Dict.773 : {U32, U32} = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret Dict.773;

procedure Dict.22 (#Attr.2, #Attr.3):
    let Dict.789 : {Str, I64} = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret Dict.789;

procedure Dict.22 (#Attr.2, #Attr.3):
    let Dict.952 : U8 = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret Dict.952;

procedure Dict.23 (#Attr.2):
    let Dict.825 : U64 = lowlevel DictPseudoSeed #Attr.2;
    ret Dict.825;

procedure Dict.4 (Dict.737):
    let Dict.163 : List {Str, I64} = StructAtIndex 1 Dict.737;
    let #Derived_gen.77 : List {U32, U32} = StructAtIndex 0 Dict.737;
    dec #Derived_gen.77;
    let Dict.890 : U64 = CallByName List.6 Dict.163;
    dec Dict.163;
    ret Dict.890;

procedure Dict.406 (Dict.407, Dict.848, Dict.409, Dict.405):
    let Dict.408 : Str = StructAtIndex 0 Dict.848;
    let Dict.853 : {U64, U32} = CallByName Dict.72 Dict.407 Dict.408 Dict.405;
    let Dict.410 : U64 = StructAtIndex 0 Dict.853;
    let Dict.411 : U32 = StructAtIndex 1 Dict.853;
    let Dict.852 : U32 = CallByName Num.131 Dict.409;
    let Dict.851 : {U32, U32} = Struct {Dict.852, Dict.411};
    let Dict.850 : List {U32, U32} = CallByName Dict.74 Dict.407 Dict.851 Dict.410;
    ret Dict.850;

procedure Dict.43 (Dict.126):
    let Dict.1101 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Inspect.30 Dict.126;
    ret Dict.1101;

procedure Dict.45 (#Derived_gen.50, #Derived_gen.51, #Derived_gen.52, #Derived_gen.53, #Derived_gen.54, #Derived_gen.55, #Derived_gen.56, #Derived_gen.57, #Derived_gen.58):
    joinpoint Dict.744 Dict.228 Dict.229 Dict.230 Dict.231 Dict.232 Dict.233 Dict.234 Dict.235 Dict.236:
        let Dict.237 : {U32, U32} = CallByName Dict.22 Dict.228 Dict.230;
        let Dict.791 : U32 = StructAtIndex 1 Dict.237;
        let Dict.779 : Int1 = CallByName Bool.11 Dict.231 Dict.791;
        if Dict.779 then
            let Dict.790 : U32 = StructAtIndex 0 Dict.237;
            let Dict.788 : U64 = CallByName Num.133 Dict.790;
            let Dict.787 : {Str, I64} = CallByName Dict.22 Dict.229 Dict.788;
            let Dict.238 : Str = StructAtIndex 0 Dict.787;
            let Dict.782 : Int1 = CallByName Bool.11 Dict.238 Dict.232;
            if Dict.782 then
                let Dict.786 : U32 = StructAtIndex 0 Dict.237;
                let Dict.784 : U64 = CallByName Num.133 Dict.786;
                let Dict.785 : {Str, I64} = Struct {Dict.232, Dict.233};
                let Dict.239 : List {Str, I64} = CallByName List.3 Dict.229 Dict.784 Dict.785;
                let Dict.783 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.228, Dict.239, Dict.234, Dict.235, Dict.236};
                ret Dict.783;
            else
                let Dict.781 : U64 = CallByName List.6 Dict.228;
                let Dict.240 : U64 = CallByName Dict.75 Dict.230 Dict.781;
                let Dict.241 : U32 = CallByName Dict.55 Dict.231;
                jump Dict.744 Dict.228 Dict.229 Dict.240 Dict.241 Dict.232 Dict.233 Dict.234 Dict.235 Dict.236;
        else
            let Dict.778 : U32 = StructAtIndex 1 Dict.237;
            let Dict.758 : Int1 = CallByName Num.24 Dict.231 Dict.778;
            if Dict.758 then
                let Dict.777 : {Str, I64} = Struct {Dict.232, Dict.233};
                let Dict.242 : List {Str, I64} = CallByName List.4 Dict.229 Dict.777;
                let Dict.775 : U64 = CallByName List.6 Dict.242;
                let Dict.776 : U64 = 1i64;
                let Dict.243 : U64 = CallByName Num.75 Dict.775 Dict.776;
                let Dict.774 : U32 = CallByName Num.131 Dict.243;
                let Dict.760 : {U32, U32} = Struct {Dict.774, Dict.231};
                let Dict.244 : List {U32, U32} = CallByName Dict.74 Dict.228 Dict.760 Dict.230;
                let Dict.759 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.244, Dict.242, Dict.234, Dict.235, Dict.236};
                ret Dict.759;
            else
                let Dict.751 : U64 = CallByName List.6 Dict.228;
                let Dict.245 : U64 = CallByName Dict.75 Dict.230 Dict.751;
                let Dict.246 : U32 = CallByName Dict.55 Dict.231;
                jump Dict.744 Dict.228 Dict.229 Dict.245 Dict.246 Dict.232 Dict.233 Dict.234 Dict.235 Dict.236;
    in
    inc #Derived_gen.54;
    jump Dict.744 #Derived_gen.50 #Derived_gen.51 #Derived_gen.52 #Derived_gen.53 #Derived_gen.54 #Derived_gen.55 #Derived_gen.56 #Derived_gen.57 #Derived_gen.58;

procedure Dict.48 ():
    let Dict.868 : U32 = 0i64;
    let Dict.869 : U32 = 0i64;
    let Dict.867 : {U32, U32} = Struct {Dict.868, Dict.869};
    ret Dict.867;

procedure Dict.49 ():
    let Dict.749 : U32 = 1i64;
    let Dict.750 : U8 = 8i64;
    let Dict.748 : U32 = CallByName Num.72 Dict.749 Dict.750;
    ret Dict.748;

procedure Dict.50 ():
    let Dict.799 : U32 = CallByName Dict.49;
    let Dict.800 : U32 = 1i64;
    let Dict.798 : U32 = CallByName Num.75 Dict.799 Dict.800;
    ret Dict.798;

procedure Dict.51 ():
    let Dict.899 : Float32 = 0.8f64;
    ret Dict.899;

procedure Dict.52 ():
    let Dict.897 : U8 = 64i64;
    let Dict.898 : U8 = 3i64;
    let Dict.896 : U8 = CallByName Num.75 Dict.897 Dict.898;
    ret Dict.896;

procedure Dict.53 ():
    let Dict.842 : U64 = 1i64;
    let Dict.843 : U8 = 32i64;
    let Dict.841 : U64 = CallByName Num.72 Dict.842 Dict.843;
    ret Dict.841;

procedure Dict.54 ():
    let Dict.840 : U64 = CallByName Dict.53;
    ret Dict.840;

procedure Dict.55 (Dict.314):
    let Dict.747 : U32 = CallByName Dict.49;
    let Dict.746 : U32 = CallByName Num.51 Dict.314 Dict.747;
    ret Dict.746;

procedure Dict.66 (Dict.727):
    let Dict.384 : List {Str, I64} = StructAtIndex 1 Dict.727;
    let Dict.385 : U64 = StructAtIndex 2 Dict.727;
    let Dict.386 : Float32 = StructAtIndex 3 Dict.727;
    let Dict.387 : U8 = StructAtIndex 4 Dict.727;
    let #Derived_gen.79 : List {U32, U32} = StructAtIndex 0 Dict.727;
    dec #Derived_gen.79;
    let Dict.885 : U64 = CallByName Dict.54;
    let Dict.844 : Int1 = CallByName Bool.7 Dict.385 Dict.885;
    if Dict.844 then
        let Dict.884 : U8 = 1i64;
        let Dict.388 : U8 = CallByName Num.75 Dict.387 Dict.884;
        let Dict.863 : {List {U32, U32}, U64} = CallByName Dict.67 Dict.388 Dict.386;
        let Dict.389 : List {U32, U32} = StructAtIndex 0 Dict.863;
        let Dict.390 : U64 = StructAtIndex 1 Dict.863;
        let Dict.391 : List {U32, U32} = CallByName Dict.71 Dict.389 Dict.384 Dict.388;
        let Dict.845 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.391, Dict.384, Dict.390, Dict.386, Dict.388};
        ret Dict.845;
    else
        dec Dict.384;
        let Dict.835 : Str = "Dict hit limit of ";
        let Dict.839 : U64 = CallByName Dict.54;
        let Dict.837 : Str = CallByName Num.96 Dict.839;
        let Dict.838 : Str = " elements. Unable to grow more.";
        let Dict.836 : Str = CallByName Str.3 Dict.837 Dict.838;
        dec Dict.838;
        let Dict.834 : Str = CallByName Str.3 Dict.835 Dict.836;
        dec Dict.836;
        Crash Dict.834

procedure Dict.67 (Dict.392, Dict.393):
    let Dict.394 : U64 = CallByName Dict.70 Dict.392;
    let Dict.877 : U64 = CallByName Dict.54;
    let Dict.872 : Int1 = CallByName Bool.11 Dict.394 Dict.877;
    if Dict.872 then
        let Dict.875 : {U32, U32} = CallByName Dict.48;
        let Dict.876 : U64 = CallByName Dict.54;
        let Dict.874 : List {U32, U32} = CallByName List.11 Dict.875 Dict.876;
        let Dict.54 : U64 = CallByName Dict.54;
        let Dict.873 : {List {U32, U32}, U64} = Struct {Dict.874, Dict.54};
        ret Dict.873;
    else
        let Dict.871 : Float32 = CallByName Num.139 Dict.394;
        let Dict.870 : Float32 = CallByName Num.21 Dict.871 Dict.393;
        let Dict.395 : U64 = CallByName Num.50 Dict.870;
        let Dict.866 : {U32, U32} = CallByName Dict.48;
        let Dict.865 : List {U32, U32} = CallByName List.11 Dict.866 Dict.394;
        let Dict.864 : {List {U32, U32}, U64} = Struct {Dict.865, Dict.395};
        ret Dict.864;

procedure Dict.70 (Dict.402):
    let Dict.881 : U64 = 1i64;
    let Dict.883 : U8 = 64i64;
    let Dict.882 : U8 = CallByName Num.75 Dict.883 Dict.402;
    let Dict.879 : U64 = CallByName Num.72 Dict.881 Dict.882;
    let Dict.880 : U64 = CallByName Dict.54;
    let Dict.878 : U64 = CallByName Num.148 Dict.879 Dict.880;
    ret Dict.878;

procedure Dict.71 (Dict.403, Dict.404, Dict.405):
    let Dict.846 : List {U32, U32} = CallByName List.83 Dict.404 Dict.403 Dict.405;
    ret Dict.846;

procedure Dict.72 (Dict.412, Dict.413, Dict.414):
    let Dict.415 : U64 = CallByName Dict.76 Dict.413;
    let Dict.416 : U32 = CallByName Dict.77 Dict.415;
    let Dict.417 : U64 = CallByName Dict.78 Dict.415 Dict.414;
    let Dict.854 : {U64, U32} = CallByName Dict.73 Dict.412 Dict.417 Dict.416;
    ret Dict.854;

procedure Dict.73 (#Derived_gen.19, #Derived_gen.20, #Derived_gen.21):
    joinpoint Dict.855 Dict.418 Dict.419 Dict.420:
        let Dict.421 : {U32, U32} = CallByName Dict.22 Dict.418 Dict.419;
        let Dict.862 : U32 = StructAtIndex 1 Dict.421;
        let Dict.857 : Int1 = CallByName Num.22 Dict.420 Dict.862;
        if Dict.857 then
            let Dict.861 : U64 = CallByName List.6 Dict.418;
            let Dict.859 : U64 = CallByName Dict.75 Dict.419 Dict.861;
            let Dict.860 : U32 = CallByName Dict.55 Dict.420;
            jump Dict.855 Dict.418 Dict.859 Dict.860;
        else
            dec Dict.418;
            let Dict.856 : {U64, U32} = Struct {Dict.419, Dict.420};
            ret Dict.856;
    in
    inc #Derived_gen.19;
    jump Dict.855 #Derived_gen.19 #Derived_gen.20 #Derived_gen.21;

procedure Dict.74 (#Derived_gen.59, #Derived_gen.60, #Derived_gen.61):
    joinpoint Dict.761 Dict.422 Dict.423 Dict.424:
        let Dict.425 : {U32, U32} = CallByName Dict.22 Dict.422 Dict.424;
        let Dict.771 : U32 = StructAtIndex 1 Dict.425;
        let Dict.772 : U32 = 0i64;
        let Dict.763 : Int1 = CallByName Bool.7 Dict.771 Dict.772;
        if Dict.763 then
            let Dict.426 : List {U32, U32} = CallByName List.3 Dict.422 Dict.424 Dict.423;
            let Dict.768 : U32 = StructAtIndex 0 Dict.425;
            let Dict.769 : U32 = StructAtIndex 1 Dict.425;
            let Dict.770 : U32 = CallByName Dict.55 Dict.769;
            let Dict.765 : {U32, U32} = Struct {Dict.768, Dict.770};
            let Dict.767 : U64 = CallByName List.6 Dict.426;
            let Dict.766 : U64 = CallByName Dict.75 Dict.424 Dict.767;
            jump Dict.761 Dict.426 Dict.765 Dict.766;
        else
            let Dict.762 : List {U32, U32} = CallByName List.3 Dict.422 Dict.424 Dict.423;
            ret Dict.762;
    in
    jump Dict.761 #Derived_gen.59 #Derived_gen.60 #Derived_gen.61;

procedure Dict.75 (Dict.427, Dict.428):
    let Dict.757 : U64 = 1i64;
    let Dict.756 : U64 = CallByName Num.51 Dict.427 Dict.757;
    let Dict.753 : Int1 = CallByName Bool.7 Dict.756 Dict.428;
    if Dict.753 then
        let Dict.755 : U64 = 1i64;
        let Dict.754 : U64 = CallByName Num.51 Dict.427 Dict.755;
        ret Dict.754;
    else
        let Dict.752 : U64 = 0i64;
        ret Dict.752;

procedure Dict.76 (Dict.429):
    let Dict.805 : [C , C U64] = TagId(0) ;
    let Dict.804 : {U64, U64} = CallByName Dict.80 Dict.805;
    let Dict.802 : {U64, U64} = CallByName Hash.19 Dict.804 Dict.429;
    let Dict.801 : U64 = CallByName Dict.83 Dict.802;
    ret Dict.801;

procedure Dict.77 (Dict.431):
    let Dict.796 : U32 = CallByName Num.131 Dict.431;
    let Dict.797 : U32 = CallByName Dict.50;
    let Dict.794 : U32 = CallByName Num.69 Dict.796 Dict.797;
    let Dict.795 : U32 = CallByName Dict.49;
    let Dict.793 : U32 = CallByName Num.71 Dict.794 Dict.795;
    ret Dict.793;

procedure Dict.78 (Dict.432, Dict.433):
    let Dict.792 : U64 = CallByName Num.74 Dict.432 Dict.433;
    ret Dict.792;

procedure Dict.8 (Dict.217, Dict.218, Dict.219):
    joinpoint Dict.832 Dict.830:
        let Dict.220 : List {U32, U32} = StructAtIndex 0 Dict.830;
        let Dict.221 : List {Str, I64} = StructAtIndex 1 Dict.830;
        let Dict.222 : U64 = StructAtIndex 2 Dict.830;
        let Dict.223 : Float32 = StructAtIndex 3 Dict.830;
        let Dict.224 : U8 = StructAtIndex 4 Dict.830;
        inc Dict.218;
        let Dict.225 : U64 = CallByName Dict.76 Dict.218;
        let Dict.226 : U32 = CallByName Dict.77 Dict.225;
        let Dict.227 : U64 = CallByName Dict.78 Dict.225 Dict.224;
        let Dict.743 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.45 Dict.220 Dict.221 Dict.227 Dict.226 Dict.218 Dict.219 Dict.222 Dict.223 Dict.224;
        dec Dict.218;
        ret Dict.743;
    in
    inc 2 Dict.217;
    let Dict.887 : U64 = CallByName Dict.4 Dict.217;
    let Dict.888 : U64 = CallByName Dict.20 Dict.217;
    let Dict.886 : Int1 = CallByName Num.22 Dict.887 Dict.888;
    if Dict.886 then
        jump Dict.832 Dict.217;
    else
        let Dict.831 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.66 Dict.217;
        jump Dict.832 Dict.831;

procedure Dict.80 (Dict.435):
    joinpoint Dict.822 Dict.436:
        let Dict.807 : U64 = CallByName Dict.82 Dict.436;
        let Dict.806 : {U64, U64} = Struct {Dict.807, Dict.436};
        ret Dict.806;
    in
    let Dict.827 : U8 = 0i64;
    let Dict.828 : U8 = GetTagId Dict.435;
    let Dict.829 : Int1 = lowlevel Eq Dict.827 Dict.828;
    if Dict.829 then
        let Dict.824 : {} = Struct {};
        let Dict.823 : U64 = CallByName Dict.23 Dict.824;
        jump Dict.822 Dict.823;
    else
        let Dict.437 : U64 = UnionAtIndex (Id 1) (Index 0) Dict.435;
        jump Dict.822 Dict.437;

procedure Dict.81 (Dict.716, Dict.717):
    let Dict.440 : U64 = StructAtIndex 0 Dict.717;
    let Dict.441 : U64 = StructAtIndex 1 Dict.717;
    let Dict.443 : U64 = StructAtIndex 2 Dict.717;
    let Dict.442 : U64 = StructAtIndex 3 Dict.717;
    let Dict.438 : U64 = StructAtIndex 0 Dict.716;
    let Dict.439 : U64 = StructAtIndex 1 Dict.716;
    let Dict.921 : U64 = CallByName Dict.93;
    let Dict.919 : U64 = CallByName Num.70 Dict.440 Dict.921;
    let Dict.920 : U64 = CallByName Num.70 Dict.441 Dict.442;
    let Dict.444 : {U64, U64} = CallByName Dict.97 Dict.919 Dict.920;
    let Dict.916 : U64 = StructAtIndex 0 Dict.444;
    let Dict.917 : U64 = CallByName Dict.92;
    let Dict.915 : U64 = CallByName Num.70 Dict.916 Dict.917;
    let Dict.445 : U64 = CallByName Num.70 Dict.915 Dict.443;
    let Dict.912 : U64 = StructAtIndex 1 Dict.444;
    let Dict.913 : U64 = CallByName Dict.93;
    let Dict.446 : U64 = CallByName Num.70 Dict.912 Dict.913;
    let Dict.447 : U64 = CallByName Dict.96 Dict.445 Dict.446;
    let Dict.904 : U64 = CallByName Dict.96 Dict.439 Dict.447;
    let Dict.903 : {U64, U64} = Struct {Dict.438, Dict.904};
    ret Dict.903;

procedure Dict.82 (Dict.448):
    let Dict.820 : U64 = CallByName Dict.92;
    let Dict.810 : U64 = CallByName Num.70 Dict.448 Dict.820;
    let Dict.811 : U64 = CallByName Dict.93;
    let Dict.809 : U64 = CallByName Dict.96 Dict.810 Dict.811;
    let Dict.808 : U64 = CallByName Num.70 Dict.809 Dict.448;
    ret Dict.808;

procedure Dict.83 (Dict.735):
    let Dict.449 : U64 = StructAtIndex 1 Dict.735;
    ret Dict.449;

procedure Dict.89 (Dict.710, Dict.488):
    let Dict.486 : U64 = StructAtIndex 0 Dict.710;
    let Dict.487 : U64 = StructAtIndex 1 Dict.710;
    let Dict.489 : U64 = CallByName List.6 Dict.488;
    joinpoint Dict.926 Dict.490:
        let Dict.901 : {U64, U64} = Struct {Dict.486, Dict.487};
        let Dict.922 : U64 = StructAtIndex 0 Dict.490;
        let Dict.923 : U64 = StructAtIndex 1 Dict.490;
        let Dict.924 : U64 = StructAtIndex 2 Dict.490;
        let Dict.902 : {U64, U64, U64, U64} = Struct {Dict.922, Dict.923, Dict.489, Dict.924};
        let Dict.900 : {U64, U64} = CallByName Dict.81 Dict.901 Dict.902;
        ret Dict.900;
    in
    let Dict.1100 : U64 = 16i64;
    let Dict.1040 : Int1 = CallByName Num.23 Dict.489 Dict.1100;
    if Dict.1040 then
        joinpoint Dict.1042 Dict.925:
            jump Dict.926 Dict.925;
        in
        let Dict.1099 : U64 = 4i64;
        let Dict.1064 : Int1 = CallByName Num.25 Dict.489 Dict.1099;
        if Dict.1064 then
            let Dict.1098 : U8 = 3i64;
            let Dict.1096 : U64 = CallByName Num.74 Dict.489 Dict.1098;
            let Dict.1097 : U8 = 2i64;
            let Dict.491 : U64 = CallByName Num.72 Dict.1096 Dict.1097;
            let Dict.1095 : U64 = 0i64;
            let Dict.1093 : U64 = CallByName Dict.99 Dict.488 Dict.1095;
            let Dict.1094 : U8 = 32i64;
            let Dict.1091 : U64 = CallByName Num.72 Dict.1093 Dict.1094;
            let Dict.1092 : U64 = CallByName Dict.99 Dict.488 Dict.491;
            let Dict.492 : U64 = CallByName Num.71 Dict.1091 Dict.1092;
            let Dict.1090 : U64 = 4i64;
            let Dict.1089 : U64 = CallByName Num.75 Dict.489 Dict.1090;
            let Dict.1087 : U64 = CallByName Dict.99 Dict.488 Dict.1089;
            let Dict.1088 : U8 = 32i64;
            let Dict.1065 : U64 = CallByName Num.72 Dict.1087 Dict.1088;
            let Dict.1086 : U64 = 4i64;
            let Dict.1085 : U64 = CallByName Num.75 Dict.489 Dict.1086;
            let Dict.1067 : U64 = CallByName Num.75 Dict.1085 Dict.491;
            let Dict.1066 : U64 = CallByName Dict.99 Dict.488 Dict.1067;
            let Dict.493 : U64 = CallByName Num.71 Dict.1065 Dict.1066;
            let Dict.1041 : {U64, U64, U64} = Struct {Dict.492, Dict.493, Dict.486};
            jump Dict.1042 Dict.1041;
        else
            let Dict.1063 : U64 = 0i64;
            let Dict.1045 : Int1 = CallByName Num.24 Dict.489 Dict.1063;
            if Dict.1045 then
                let Dict.1048 : U64 = 0i64;
                let Dict.1046 : U64 = CallByName Dict.100 Dict.488 Dict.1048 Dict.489;
                let Dict.1047 : U64 = 0i64;
                let Dict.1041 : {U64, U64, U64} = Struct {Dict.1046, Dict.1047, Dict.486};
                jump Dict.1042 Dict.1041;
            else
                let Dict.1043 : U64 = 0i64;
                let Dict.1044 : U64 = 0i64;
                let Dict.1041 : {U64, U64, U64} = Struct {Dict.1043, Dict.1044, Dict.486};
                jump Dict.1042 Dict.1041;
    else
        let Dict.1039 : U64 = 48i64;
        let Dict.1037 : Int1 = CallByName Num.23 Dict.489 Dict.1039;
        if Dict.1037 then
            let Dict.1038 : U64 = 0i64;
            let Dict.925 : {U64, U64, U64} = CallByName Dict.91 Dict.486 Dict.488 Dict.1038 Dict.489;
            jump Dict.926 Dict.925;
        else
            let Dict.927 : U64 = 0i64;
            let Dict.925 : {U64, U64, U64} = CallByName Dict.90 Dict.486 Dict.486 Dict.486 Dict.488 Dict.927 Dict.489;
            jump Dict.926 Dict.925;

procedure Dict.90 (#Derived_gen.9, #Derived_gen.10, #Derived_gen.11, #Derived_gen.12, #Derived_gen.13, #Derived_gen.14):
    joinpoint Dict.928 Dict.494 Dict.495 Dict.496 Dict.497 Dict.498 Dict.499:
        let Dict.1035 : U64 = CallByName Dict.98 Dict.497 Dict.498;
        let Dict.1036 : U64 = CallByName Dict.93;
        let Dict.1030 : U64 = CallByName Num.70 Dict.1035 Dict.1036;
        let Dict.1034 : U64 = 8i64;
        let Dict.1033 : U64 = CallByName Num.51 Dict.498 Dict.1034;
        let Dict.1032 : U64 = CallByName Dict.98 Dict.497 Dict.1033;
        let Dict.1031 : U64 = CallByName Num.70 Dict.1032 Dict.494;
        let Dict.500 : U64 = CallByName Dict.96 Dict.1030 Dict.1031;
        let Dict.1029 : U64 = 16i64;
        let Dict.1028 : U64 = CallByName Num.51 Dict.498 Dict.1029;
        let Dict.1025 : U64 = CallByName Dict.98 Dict.497 Dict.1028;
        let Dict.1026 : U64 = CallByName Dict.94;
        let Dict.1020 : U64 = CallByName Num.70 Dict.1025 Dict.1026;
        let Dict.1024 : U64 = 24i64;
        let Dict.1023 : U64 = CallByName Num.51 Dict.498 Dict.1024;
        let Dict.1022 : U64 = CallByName Dict.98 Dict.497 Dict.1023;
        let Dict.1021 : U64 = CallByName Num.70 Dict.1022 Dict.495;
        let Dict.501 : U64 = CallByName Dict.96 Dict.1020 Dict.1021;
        let Dict.1019 : U64 = 32i64;
        let Dict.1018 : U64 = CallByName Num.51 Dict.498 Dict.1019;
        let Dict.1015 : U64 = CallByName Dict.98 Dict.497 Dict.1018;
        let Dict.1016 : U64 = CallByName Dict.95;
        let Dict.1010 : U64 = CallByName Num.70 Dict.1015 Dict.1016;
        let Dict.1014 : U64 = 40i64;
        let Dict.1013 : U64 = CallByName Num.51 Dict.498 Dict.1014;
        let Dict.1012 : U64 = CallByName Dict.98 Dict.497 Dict.1013;
        let Dict.1011 : U64 = CallByName Num.70 Dict.1012 Dict.496;
        let Dict.502 : U64 = CallByName Dict.96 Dict.1010 Dict.1011;
        let Dict.1009 : U64 = 48i64;
        let Dict.503 : U64 = CallByName Num.75 Dict.499 Dict.1009;
        let Dict.1008 : U64 = 48i64;
        let Dict.504 : U64 = CallByName Num.51 Dict.498 Dict.1008;
        let Dict.1007 : U64 = 48i64;
        let Dict.1005 : Int1 = CallByName Num.24 Dict.503 Dict.1007;
        if Dict.1005 then
            jump Dict.928 Dict.500 Dict.501 Dict.502 Dict.497 Dict.504 Dict.503;
        else
            let Dict.1004 : U64 = 16i64;
            let Dict.979 : Int1 = CallByName Num.24 Dict.503 Dict.1004;
            if Dict.979 then
                let Dict.1003 : U64 = CallByName Num.70 Dict.501 Dict.500;
                let Dict.505 : U64 = CallByName Num.70 Dict.502 Dict.1003;
                let Dict.980 : {U64, U64, U64} = CallByName Dict.91 Dict.505 Dict.497 Dict.504 Dict.503;
                dec Dict.497;
                ret Dict.980;
            else
                let Dict.978 : U64 = CallByName Num.70 Dict.501 Dict.500;
                let Dict.506 : U64 = CallByName Num.70 Dict.502 Dict.978;
                let Dict.977 : U64 = 16i64;
                let Dict.976 : U64 = CallByName Num.75 Dict.503 Dict.977;
                let Dict.975 : U64 = CallByName Num.51 Dict.976 Dict.504;
                let Dict.930 : U64 = CallByName Dict.98 Dict.497 Dict.975;
                let Dict.974 : U64 = 8i64;
                let Dict.973 : U64 = CallByName Num.75 Dict.503 Dict.974;
                let Dict.932 : U64 = CallByName Num.51 Dict.973 Dict.504;
                let Dict.931 : U64 = CallByName Dict.98 Dict.497 Dict.932;
                dec Dict.497;
                let Dict.929 : {U64, U64, U64} = Struct {Dict.930, Dict.931, Dict.506};
                ret Dict.929;
    in
    inc #Derived_gen.12;
    jump Dict.928 #Derived_gen.9 #Derived_gen.10 #Derived_gen.11 #Derived_gen.12 #Derived_gen.13 #Derived_gen.14;

procedure Dict.91 (#Derived_gen.1, #Derived_gen.2, #Derived_gen.3, #Derived_gen.4):
    joinpoint Dict.981 Dict.507 Dict.508 Dict.509 Dict.510:
        let Dict.1001 : U64 = CallByName Dict.98 Dict.508 Dict.509;
        let Dict.1002 : U64 = CallByName Dict.93;
        let Dict.996 : U64 = CallByName Num.70 Dict.1001 Dict.1002;
        let Dict.1000 : U64 = 8i64;
        let Dict.999 : U64 = CallByName Num.51 Dict.509 Dict.1000;
        let Dict.998 : U64 = CallByName Dict.98 Dict.508 Dict.999;
        let Dict.997 : U64 = CallByName Num.70 Dict.998 Dict.507;
        let Dict.511 : U64 = CallByName Dict.96 Dict.996 Dict.997;
        let Dict.995 : U64 = 16i64;
        let Dict.512 : U64 = CallByName Num.75 Dict.510 Dict.995;
        let Dict.994 : U64 = 16i64;
        let Dict.513 : U64 = CallByName Num.51 Dict.509 Dict.994;
        let Dict.993 : U64 = 16i64;
        let Dict.983 : Int1 = CallByName Num.23 Dict.512 Dict.993;
        if Dict.983 then
            let Dict.992 : U64 = 16i64;
            let Dict.991 : U64 = CallByName Num.75 Dict.512 Dict.992;
            let Dict.990 : U64 = CallByName Num.51 Dict.991 Dict.513;
            let Dict.985 : U64 = CallByName Dict.98 Dict.508 Dict.990;
            let Dict.989 : U64 = 8i64;
            let Dict.988 : U64 = CallByName Num.75 Dict.512 Dict.989;
            let Dict.987 : U64 = CallByName Num.51 Dict.988 Dict.513;
            let Dict.986 : U64 = CallByName Dict.98 Dict.508 Dict.987;
            dec Dict.508;
            let Dict.984 : {U64, U64, U64} = Struct {Dict.985, Dict.986, Dict.511};
            ret Dict.984;
        else
            jump Dict.981 Dict.511 Dict.508 Dict.513 Dict.512;
    in
    inc #Derived_gen.2;
    jump Dict.981 #Derived_gen.1 #Derived_gen.2 #Derived_gen.3 #Derived_gen.4;

procedure Dict.92 ():
    let Dict.918 : U64 = 11562461410679940143i64;
    ret Dict.918;

procedure Dict.93 ():
    let Dict.914 : U64 = 16646288086500911323i64;
    ret Dict.914;

procedure Dict.94 ():
    let Dict.1027 : U64 = 10285213230658275043i64;
    ret Dict.1027;

procedure Dict.95 ():
    let Dict.1017 : U64 = 6384245875588680899i64;
    ret Dict.1017;

procedure Dict.96 (Dict.514, Dict.515):
    let Dict.906 : {U64, U64} = CallByName Dict.97 Dict.514 Dict.515;
    let Dict.516 : U64 = StructAtIndex 0 Dict.906;
    let Dict.517 : U64 = StructAtIndex 1 Dict.906;
    let Dict.905 : U64 = CallByName Num.70 Dict.516 Dict.517;
    ret Dict.905;

procedure Dict.97 (Dict.518, Dict.519):
    let Dict.910 : U128 = CallByName Num.135 Dict.518;
    let Dict.911 : U128 = CallByName Num.135 Dict.519;
    let Dict.520 : U128 = CallByName Num.78 Dict.910 Dict.911;
    let Dict.521 : U64 = CallByName Num.133 Dict.520;
    let Dict.909 : U8 = 64i64;
    let Dict.908 : U128 = CallByName Num.74 Dict.520 Dict.909;
    let Dict.522 : U64 = CallByName Num.133 Dict.908;
    let Dict.907 : {U64, U64} = Struct {Dict.521, Dict.522};
    ret Dict.907;

procedure Dict.98 (Dict.523, Dict.524):
    let Dict.972 : U8 = CallByName Dict.22 Dict.523 Dict.524;
    let Dict.525 : U64 = CallByName Num.133 Dict.972;
    let Dict.971 : U64 = 1i64;
    let Dict.970 : U64 = CallByName Num.51 Dict.524 Dict.971;
    let Dict.969 : U8 = CallByName Dict.22 Dict.523 Dict.970;
    let Dict.526 : U64 = CallByName Num.133 Dict.969;
    let Dict.968 : U64 = 2i64;
    let Dict.967 : U64 = CallByName Num.51 Dict.524 Dict.968;
    let Dict.966 : U8 = CallByName Dict.22 Dict.523 Dict.967;
    let Dict.527 : U64 = CallByName Num.133 Dict.966;
    let Dict.965 : U64 = 3i64;
    let Dict.964 : U64 = CallByName Num.51 Dict.524 Dict.965;
    let Dict.963 : U8 = CallByName Dict.22 Dict.523 Dict.964;
    let Dict.528 : U64 = CallByName Num.133 Dict.963;
    let Dict.962 : U64 = 4i64;
    let Dict.961 : U64 = CallByName Num.51 Dict.524 Dict.962;
    let Dict.960 : U8 = CallByName Dict.22 Dict.523 Dict.961;
    let Dict.529 : U64 = CallByName Num.133 Dict.960;
    let Dict.959 : U64 = 5i64;
    let Dict.958 : U64 = CallByName Num.51 Dict.524 Dict.959;
    let Dict.957 : U8 = CallByName Dict.22 Dict.523 Dict.958;
    let Dict.530 : U64 = CallByName Num.133 Dict.957;
    let Dict.956 : U64 = 6i64;
    let Dict.955 : U64 = CallByName Num.51 Dict.524 Dict.956;
    let Dict.954 : U8 = CallByName Dict.22 Dict.523 Dict.955;
    let Dict.531 : U64 = CallByName Num.133 Dict.954;
    let Dict.953 : U64 = 7i64;
    let Dict.951 : U64 = CallByName Num.51 Dict.524 Dict.953;
    let Dict.950 : U8 = CallByName Dict.22 Dict.523 Dict.951;
    let Dict.532 : U64 = CallByName Num.133 Dict.950;
    let Dict.949 : U8 = 8i64;
    let Dict.948 : U64 = CallByName Num.72 Dict.526 Dict.949;
    let Dict.533 : U64 = CallByName Num.71 Dict.525 Dict.948;
    let Dict.947 : U8 = 16i64;
    let Dict.944 : U64 = CallByName Num.72 Dict.527 Dict.947;
    let Dict.946 : U8 = 24i64;
    let Dict.945 : U64 = CallByName Num.72 Dict.528 Dict.946;
    let Dict.534 : U64 = CallByName Num.71 Dict.944 Dict.945;
    let Dict.943 : U8 = 32i64;
    let Dict.940 : U64 = CallByName Num.72 Dict.529 Dict.943;
    let Dict.942 : U8 = 40i64;
    let Dict.941 : U64 = CallByName Num.72 Dict.530 Dict.942;
    let Dict.535 : U64 = CallByName Num.71 Dict.940 Dict.941;
    let Dict.939 : U8 = 48i64;
    let Dict.936 : U64 = CallByName Num.72 Dict.531 Dict.939;
    let Dict.938 : U8 = 56i64;
    let Dict.937 : U64 = CallByName Num.72 Dict.532 Dict.938;
    let Dict.536 : U64 = CallByName Num.71 Dict.936 Dict.937;
    let Dict.934 : U64 = CallByName Num.71 Dict.533 Dict.534;
    let Dict.935 : U64 = CallByName Num.71 Dict.535 Dict.536;
    let Dict.933 : U64 = CallByName Num.71 Dict.934 Dict.935;
    ret Dict.933;

procedure Dict.99 (Dict.537, Dict.538):
    let Dict.1084 : U8 = CallByName Dict.22 Dict.537 Dict.538;
    let Dict.539 : U64 = CallByName Num.133 Dict.1084;
    let Dict.1083 : U64 = 1i64;
    let Dict.1082 : U64 = CallByName Num.51 Dict.538 Dict.1083;
    let Dict.1081 : U8 = CallByName Dict.22 Dict.537 Dict.1082;
    let Dict.540 : U64 = CallByName Num.133 Dict.1081;
    let Dict.1080 : U64 = 2i64;
    let Dict.1079 : U64 = CallByName Num.51 Dict.538 Dict.1080;
    let Dict.1078 : U8 = CallByName Dict.22 Dict.537 Dict.1079;
    let Dict.541 : U64 = CallByName Num.133 Dict.1078;
    let Dict.1077 : U64 = 3i64;
    let Dict.1076 : U64 = CallByName Num.51 Dict.538 Dict.1077;
    let Dict.1075 : U8 = CallByName Dict.22 Dict.537 Dict.1076;
    let Dict.542 : U64 = CallByName Num.133 Dict.1075;
    let Dict.1074 : U8 = 8i64;
    let Dict.1073 : U64 = CallByName Num.72 Dict.540 Dict.1074;
    let Dict.543 : U64 = CallByName Num.71 Dict.539 Dict.1073;
    let Dict.1072 : U8 = 16i64;
    let Dict.1069 : U64 = CallByName Num.72 Dict.541 Dict.1072;
    let Dict.1071 : U8 = 24i64;
    let Dict.1070 : U64 = CallByName Num.72 Dict.542 Dict.1071;
    let Dict.544 : U64 = CallByName Num.71 Dict.1069 Dict.1070;
    let Dict.1068 : U64 = CallByName Num.71 Dict.543 Dict.544;
    ret Dict.1068;

procedure Hash.19 (Hash.42, Hash.43):
    let Hash.75 : List U8 = CallByName Str.12 Hash.43;
    let Hash.74 : {U64, U64} = CallByName Dict.89 Hash.42 Hash.75;
    dec Hash.75;
    ret Hash.74;

procedure Inspect.187 (Inspect.188, #Attr.12):
    let Inspect.186 : {} = StructAtIndex 3 #Attr.12;
    let Inspect.185 : {} = StructAtIndex 2 #Attr.12;
    let Inspect.184 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.183 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = StructAtIndex 0 #Attr.12;
    let Inspect.358 : Str = "{";
    let Inspect.331 : Str = CallByName Inspect.63 Inspect.188 Inspect.358;
    dec Inspect.358;
    let Inspect.332 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = Struct {Inspect.183, Inspect.184, Inspect.185, Inspect.186};
    let Inspect.327 : {Str, Int1} = CallByName Inspect.189 Inspect.331 Inspect.332;
    dec Inspect.331;
    let Inspect.328 : {} = Struct {};
    let Inspect.323 : Str = CallByName Inspect.201 Inspect.327;
    let Inspect.324 : Str = "}";
    let Inspect.322 : Str = CallByName Inspect.63 Inspect.323 Inspect.324;
    dec Inspect.324;
    ret Inspect.322;

procedure Inspect.189 (Inspect.190, #Attr.12):
    let Inspect.186 : {} = StructAtIndex 3 #Attr.12;
    let Inspect.185 : {} = StructAtIndex 2 #Attr.12;
    let Inspect.184 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.183 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = StructAtIndex 0 #Attr.12;
    let Inspect.357 : Int1 = CallByName Bool.1;
    inc Inspect.190;
    let Inspect.335 : {Str, Int1} = Struct {Inspect.190, Inspect.357};
    let Inspect.336 : {{}, {}} = Struct {Inspect.185, Inspect.186};
    let Inspect.334 : {Str, Int1} = CallByName Dict.10 Inspect.183 Inspect.335 Inspect.336;
    ret Inspect.334;

procedure Inspect.191 (Inspect.337, Inspect.194, Inspect.195, #Attr.12):
    let Inspect.186 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.185 : {} = StructAtIndex 0 #Attr.12;
    let Inspect.192 : Str = StructAtIndex 0 Inspect.337;
    let Inspect.193 : Int1 = StructAtIndex 1 Inspect.337;
    joinpoint Inspect.355 Inspect.196:
        let Inspect.352 : Str = CallByName Inspect.47 Inspect.194;
        let Inspect.350 : Str = CallByName Inspect.31 Inspect.352 Inspect.196;
        let Inspect.351 : Str = ": ";
        let Inspect.344 : Str = CallByName Inspect.63 Inspect.350 Inspect.351;
        dec Inspect.351;
        let Inspect.345 : {I64, {}} = Struct {Inspect.195, Inspect.186};
        let Inspect.340 : Str = CallByName Inspect.197 Inspect.344 Inspect.345;
        let Inspect.341 : {} = Struct {};
        let Inspect.339 : {Str, Int1} = CallByName Inspect.199 Inspect.340;
        dec Inspect.340;
        ret Inspect.339;
    in
    if Inspect.193 then
        let Inspect.356 : Str = ", ";
        let Inspect.354 : Str = CallByName Inspect.63 Inspect.192 Inspect.356;
        dec Inspect.356;
        jump Inspect.355 Inspect.354;
    else
        jump Inspect.355 Inspect.192;

procedure Inspect.197 (Inspect.198, #Attr.12):
    let Inspect.186 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.195 : I64 = StructAtIndex 0 #Attr.12;
    let Inspect.348 : I64 = CallByName Inspect.57 Inspect.195;
    let Inspect.347 : Str = CallByName Inspect.31 Inspect.348 Inspect.198;
    ret Inspect.347;

procedure Inspect.199 (Inspect.200):
    let Inspect.343 : Int1 = CallByName Bool.2;
    inc Inspect.200;
    let Inspect.342 : {Str, Int1} = Struct {Inspect.200, Inspect.343};
    ret Inspect.342;

procedure Inspect.201 (Inspect.329):
    let Inspect.330 : Str = StructAtIndex 0 Inspect.329;
    ret Inspect.330;

procedure Inspect.250 (Inspect.251, Inspect.249):
    let Inspect.387 : Str = "\"";
    let Inspect.372 : Str = CallByName Inspect.63 Inspect.251 Inspect.387;
    dec Inspect.387;
    let Inspect.370 : Str = CallByName Inspect.252 Inspect.372 Inspect.249;
    let Inspect.371 : Str = "\"";
    let Inspect.369 : Str = CallByName Inspect.63 Inspect.370 Inspect.371;
    dec Inspect.371;
    ret Inspect.369;

procedure Inspect.252 (Inspect.253, Inspect.249):
    let Inspect.385 : Str = "\u{feff}";
    let Inspect.386 : Str = "\\u(feff)";
    let Inspect.382 : Str = CallByName Str.45 Inspect.249 Inspect.385 Inspect.386;
    dec Inspect.386;
    dec Inspect.385;
    let Inspect.383 : Str = "\u{200b}";
    let Inspect.384 : Str = "\\u(200b)";
    let Inspect.379 : Str = CallByName Str.45 Inspect.382 Inspect.383 Inspect.384;
    dec Inspect.384;
    dec Inspect.383;
    let Inspect.380 : Str = "\u{200c}";
    let Inspect.381 : Str = "\\u(200c)";
    let Inspect.376 : Str = CallByName Str.45 Inspect.379 Inspect.380 Inspect.381;
    dec Inspect.380;
    dec Inspect.381;
    let Inspect.377 : Str = "\u{200d}";
    let Inspect.378 : Str = "\\u(200d)";
    let Inspect.254 : Str = CallByName Str.45 Inspect.376 Inspect.377 Inspect.378;
    dec Inspect.377;
    dec Inspect.378;
    let Inspect.375 : Str = CallByName Inspect.63 Inspect.253 Inspect.254;
    dec Inspect.254;
    ret Inspect.375;

procedure Inspect.281 (Inspect.282, Inspect.280):
    let Inspect.364 : Str = CallByName Num.96 Inspect.280;
    let Inspect.363 : Str = CallByName Inspect.63 Inspect.282 Inspect.364;
    dec Inspect.364;
    ret Inspect.363;

procedure Inspect.30 (Inspect.147):
    ret Inspect.147;

procedure Inspect.30 (Inspect.147):
    ret Inspect.147;

procedure Inspect.30 (Inspect.147):
    ret Inspect.147;

procedure Inspect.30 (Inspect.147):
    ret Inspect.147;

procedure Inspect.31 (Inspect.306, Inspect.149):
    let Inspect.317 : Str = CallByName Inspect.187 Inspect.149 Inspect.306;
    ret Inspect.317;

procedure Inspect.31 (Inspect.306, Inspect.149):
    let Inspect.349 : Str = CallByName Inspect.281 Inspect.149 Inspect.306;
    ret Inspect.349;

procedure Inspect.31 (Inspect.306, Inspect.149):
    let Inspect.353 : Str = CallByName Inspect.250 Inspect.149 Inspect.306;
    ret Inspect.353;

procedure Inspect.33 (Inspect.152):
    let Inspect.308 : Str = CallByName Inspect.5 Inspect.152;
    let Inspect.307 : Str = CallByName Inspect.64 Inspect.308;
    ret Inspect.307;

procedure Inspect.39 (Inspect.304):
    let Inspect.314 : Str = "";
    ret Inspect.314;

procedure Inspect.42 (Inspect.183, Inspect.184, Inspect.185, Inspect.186):
    let Inspect.319 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = Struct {Inspect.183, Inspect.184, Inspect.185, Inspect.186};
    let Inspect.318 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = CallByName Inspect.30 Inspect.319;
    ret Inspect.318;

procedure Inspect.47 (Inspect.249):
    let Inspect.365 : Str = CallByName Inspect.30 Inspect.249;
    ret Inspect.365;

procedure Inspect.5 (Inspect.150):
    let Inspect.315 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.43 Inspect.150;
    let Inspect.312 : {} = Struct {};
    let Inspect.311 : Str = CallByName Inspect.39 Inspect.312;
    let Inspect.310 : Str = CallByName Dict.127 Inspect.311 Inspect.315;
    ret Inspect.310;

procedure Inspect.57 (Inspect.280):
    let Inspect.359 : I64 = CallByName Inspect.30 Inspect.280;
    ret Inspect.359;

procedure Inspect.63 (Inspect.303, Inspect.299):
    let Inspect.326 : Str = CallByName Str.3 Inspect.303 Inspect.299;
    ret Inspect.326;

procedure Inspect.64 (Inspect.305):
    ret Inspect.305;

procedure List.100 (#Derived_gen.45, #Derived_gen.46, #Derived_gen.47, #Derived_gen.48, #Derived_gen.49):
    joinpoint List.726 List.174 List.175 List.176 List.177 List.178:
        let List.728 : Int1 = CallByName Num.22 List.177 List.178;
        if List.728 then
            let List.732 : {Str, I64} = CallByName List.66 List.174 List.177;
            inc List.732;
            let List.179 : {Str, Int1} = CallByName Dict.188 List.175 List.732 List.176;
            let List.731 : U64 = 1i64;
            let List.730 : U64 = CallByName Num.51 List.177 List.731;
            jump List.726 List.174 List.179 List.176 List.730 List.178;
        else
            dec List.174;
            ret List.175;
    in
    inc #Derived_gen.45;
    jump List.726 #Derived_gen.45 #Derived_gen.46 #Derived_gen.47 #Derived_gen.48 #Derived_gen.49;

procedure List.100 (#Derived_gen.72, #Derived_gen.73, #Derived_gen.74, #Derived_gen.75, #Derived_gen.76):
    joinpoint List.662 List.174 List.175 List.176 List.177 List.178:
        let List.664 : Int1 = CallByName Num.22 List.177 List.178;
        if List.664 then
            let List.668 : {Str, I64} = CallByName List.66 List.174 List.177;
            inc List.668;
            let List.179 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.159 List.175 List.668;
            let List.667 : U64 = 1i64;
            let List.666 : U64 = CallByName Num.51 List.177 List.667;
            jump List.662 List.174 List.179 List.176 List.666 List.178;
        else
            dec List.174;
            ret List.175;
    in
    inc #Derived_gen.72;
    jump List.662 #Derived_gen.72 #Derived_gen.73 #Derived_gen.74 #Derived_gen.75 #Derived_gen.76;

procedure List.101 (#Derived_gen.24, #Derived_gen.25, #Derived_gen.26, #Derived_gen.27, #Derived_gen.28):
    joinpoint List.701 List.183 List.184 List.185 List.186 List.187:
        let List.703 : Int1 = CallByName Num.22 List.186 List.187;
        if List.703 then
            let List.707 : {Str, I64} = CallByName List.66 List.183 List.186;
            inc List.707;
            let List.188 : List {U32, U32} = CallByName Dict.406 List.184 List.707 List.186 List.185;
            let List.706 : U64 = 1i64;
            let List.705 : U64 = CallByName Num.51 List.186 List.706;
            jump List.701 List.183 List.188 List.185 List.705 List.187;
        else
            dec List.183;
            ret List.184;
    in
    inc #Derived_gen.24;
    jump List.701 #Derived_gen.24 #Derived_gen.25 #Derived_gen.26 #Derived_gen.27 #Derived_gen.28;

procedure List.11 (List.149, List.150):
    let List.727 : List {U32, U32} = CallByName List.68 List.150;
    let List.726 : List {U32, U32} = CallByName List.98 List.149 List.150 List.727;
    ret List.726;

procedure List.18 (List.171, List.172, List.173):
    let List.666 : U64 = 0i64;
    let List.667 : U64 = CallByName List.6 List.171;
    let List.665 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName List.100 List.171 List.172 List.173 List.666 List.667;
    ret List.665;

procedure List.18 (List.171, List.172, List.173):
    let List.730 : U64 = 0i64;
    let List.731 : U64 = CallByName List.6 List.171;
    let List.729 : {Str, Int1} = CallByName List.100 List.171 List.172 List.173 List.730 List.731;
    ret List.729;

procedure List.3 (List.127, List.128, List.129):
    let List.691 : {List {U32, U32}, {U32, U32}} = CallByName List.64 List.127 List.128 List.129;
    let List.690 : List {U32, U32} = StructAtIndex 0 List.691;
    ret List.690;

procedure List.3 (List.127, List.128, List.129):
    let List.687 : {List {Str, I64}, {Str, I64}} = CallByName List.64 List.127 List.128 List.129;
    let List.686 : List {Str, I64} = StructAtIndex 0 List.687;
    let #Derived_gen.82 : {Str, I64} = StructAtIndex 1 List.687;
    dec #Derived_gen.82;
    ret List.686;

procedure List.4 (List.135, List.136):
    let List.702 : U64 = 1i64;
    let List.700 : List {Str, I64} = CallByName List.70 List.135 List.702;
    let List.699 : List {Str, I64} = CallByName List.71 List.700 List.136;
    ret List.699;

procedure List.6 (#Attr.2):
    let List.681 : U64 = lowlevel ListLenU64 #Attr.2;
    ret List.681;

procedure List.6 (#Attr.2):
    let List.728 : U64 = lowlevel ListLenU64 #Attr.2;
    ret List.728;

procedure List.6 (#Attr.2):
    let List.740 : U64 = lowlevel ListLenU64 #Attr.2;
    ret List.740;

procedure List.64 (List.124, List.125, List.126):
    let List.689 : U64 = CallByName List.6 List.124;
    let List.686 : Int1 = CallByName Num.22 List.125 List.689;
    if List.686 then
        let List.687 : {List {U32, U32}, {U32, U32}} = CallByName List.67 List.124 List.125 List.126;
        ret List.687;
    else
        let List.685 : {List {U32, U32}, {U32, U32}} = Struct {List.124, List.126};
        ret List.685;

procedure List.64 (List.124, List.125, List.126):
    let List.698 : U64 = CallByName List.6 List.124;
    let List.695 : Int1 = CallByName Num.22 List.125 List.698;
    if List.695 then
        let List.696 : {List {Str, I64}, {Str, I64}} = CallByName List.67 List.124 List.125 List.126;
        ret List.696;
    else
        let List.694 : {List {Str, I64}, {Str, I64}} = Struct {List.124, List.126};
        ret List.694;

procedure List.66 (#Attr.2, #Attr.3):
    let List.739 : {Str, I64} = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret List.739;

procedure List.67 (#Attr.2, #Attr.3, #Attr.4):
    let List.688 : {List {U32, U32}, {U32, U32}} = lowlevel ListReplaceUnsafe #Attr.2 #Attr.3 #Attr.4;
    ret List.688;

procedure List.67 (#Attr.2, #Attr.3, #Attr.4):
    let List.697 : {List {Str, I64}, {Str, I64}} = lowlevel ListReplaceUnsafe #Attr.2 #Attr.3 #Attr.4;
    ret List.697;

procedure List.68 (#Attr.2):
    let List.725 : List {U32, U32} = lowlevel ListWithCapacity #Attr.2;
    ret List.725;

procedure List.70 (#Attr.2, #Attr.3):
    let List.703 : List {Str, I64} = lowlevel ListReserve #Attr.2 #Attr.3;
    ret List.703;

procedure List.71 (#Attr.2, #Attr.3):
    let List.701 : List {Str, I64} = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.701;

procedure List.71 (#Attr.2, #Attr.3):
    let List.722 : List {U32, U32} = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.722;

procedure List.83 (List.180, List.181, List.182):
    let List.705 : U64 = 0i64;
    let List.706 : U64 = CallByName List.6 List.180;
    let List.704 : List {U32, U32} = CallByName List.101 List.180 List.181 List.182 List.705 List.706;
    ret List.704;

procedure List.98 (#Derived_gen.33, #Derived_gen.34, #Derived_gen.35):
    joinpoint List.710 List.151 List.152 List.153:
        let List.718 : U64 = 0i64;
        let List.712 : Int1 = CallByName Num.24 List.152 List.718;
        if List.712 then
            let List.717 : U64 = 1i64;
            let List.714 : U64 = CallByName Num.75 List.152 List.717;
            let List.715 : List {U32, U32} = CallByName List.71 List.153 List.151;
            jump List.710 List.151 List.714 List.715;
        else
            ret List.153;
    in
    jump List.710 #Derived_gen.33 #Derived_gen.34 #Derived_gen.35;

procedure Num.131 (#Attr.2):
    let Num.291 : U32 = lowlevel NumIntCast #Attr.2;
    ret Num.291;

procedure Num.133 (#Attr.2):
    let Num.299 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.299;

procedure Num.133 (#Attr.2):
    let Num.348 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.348;

procedure Num.133 (#Attr.2):
    let Num.363 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.363;

procedure Num.135 (#Attr.2):
    let Num.369 : U128 = lowlevel NumIntCast #Attr.2;
    ret Num.369;

procedure Num.139 (#Attr.2):
    let Num.317 : Float32 = lowlevel NumToFloatCast #Attr.2;
    ret Num.317;

procedure Num.148 (Num.226, Num.227):
    let Num.319 : Int1 = CallByName Num.22 Num.226 Num.227;
    if Num.319 then
        ret Num.226;
    else
        ret Num.227;

procedure Num.20 (#Attr.2, #Attr.3):
    let Num.446 : U64 = lowlevel NumSub #Attr.2 #Attr.3;
    ret Num.446;

procedure Num.21 (#Attr.2, #Attr.3):
    let Num.316 : Float32 = lowlevel NumMul #Attr.2 #Attr.3;
    ret Num.316;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.313 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.313;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.453 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.453;

procedure Num.23 (#Attr.2, #Attr.3):
    let Num.450 : Int1 = lowlevel NumLte #Attr.2 #Attr.3;
    ret Num.450;

procedure Num.24 (#Attr.2, #Attr.3):
    let Num.297 : Int1 = lowlevel NumGt #Attr.2 #Attr.3;
    ret Num.297;

procedure Num.24 (#Attr.2, #Attr.3):
    let Num.438 : Int1 = lowlevel NumGt #Attr.2 #Attr.3;
    ret Num.438;

procedure Num.25 (#Attr.2, #Attr.3):
    let Num.447 : Int1 = lowlevel NumGte #Attr.2 #Attr.3;
    ret Num.447;

procedure Num.50 (#Attr.2):
    let Num.315 : U64 = lowlevel NumFloor #Attr.2;
    ret Num.315;

procedure Num.51 (#Attr.2, #Attr.3):
    let Num.283 : U32 = lowlevel NumAddWrap #Attr.2 #Attr.3;
    ret Num.283;

procedure Num.51 (#Attr.2, #Attr.3):
    let Num.452 : U64 = lowlevel NumAddWrap #Attr.2 #Attr.3;
    ret Num.452;

procedure Num.53 (#Attr.2, #Attr.3):
    let Num.449 : U64 = lowlevel NumAddSaturated #Attr.2 #Attr.3;
    ret Num.449;

procedure Num.69 (#Attr.2, #Attr.3):
    let Num.305 : U32 = lowlevel NumBitwiseAnd #Attr.2 #Attr.3;
    ret Num.305;

procedure Num.70 (#Attr.2, #Attr.3):
    let Num.346 : U64 = lowlevel NumBitwiseXor #Attr.2 #Attr.3;
    ret Num.346;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.304 : U32 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.304;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.383 : U64 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.383;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.286 : U32 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.286;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.398 : U64 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.398;

procedure Num.74 (#Attr.2, #Attr.3):
    let Num.364 : U128 = lowlevel NumShiftRightZfBy #Attr.2 #Attr.3;
    ret Num.364;

procedure Num.74 (#Attr.2, #Attr.3):
    let Num.366 : U64 = lowlevel NumShiftRightZfBy #Attr.2 #Attr.3;
    ret Num.366;

procedure Num.75 (#Attr.2, #Attr.3):
    let Num.293 : U32 = lowlevel NumSubWrap #Attr.2 #Attr.3;
    ret Num.293;

procedure Num.75 (#Attr.2, #Attr.3):
    let Num.296 : U8 = lowlevel NumSubWrap #Attr.2 #Attr.3;
    ret Num.296;

procedure Num.75 (#Attr.2, #Attr.3):
    let Num.432 : U64 = lowlevel NumSubWrap #Attr.2 #Attr.3;
    ret Num.432;

procedure Num.77 (#Attr.2, #Attr.3):
    let Num.451 : U64 = lowlevel NumSubSaturated #Attr.2 #Attr.3;
    ret Num.451;

procedure Num.78 (#Attr.2, #Attr.3):
    let Num.367 : U128 = lowlevel NumMulWrap #Attr.2 #Attr.3;
    ret Num.367;

procedure Num.96 (#Attr.2):
    let Num.312 : Str = lowlevel NumToStr #Attr.2;
    ret Num.312;

procedure Num.96 (#Attr.2):
    let Num.440 : Str = lowlevel NumToStr #Attr.2;
    ret Num.440;

procedure Str.12 (#Attr.2):
    let Str.248 : List U8 = lowlevel StrToUtf8 #Attr.2;
    ret Str.248;

procedure Str.20 (#Attr.2):
    let Str.316 : Str = lowlevel StrWithCapacity #Attr.2;
    ret Str.316;

procedure Str.3 (#Attr.2, #Attr.3):
    let Str.249 : Str = lowlevel StrConcat #Attr.2 #Attr.3;
    ret Str.249;

procedure Str.35 (#Attr.2, #Attr.3):
    let Str.306 : U8 = lowlevel StrGetUnsafe #Attr.2 #Attr.3;
    ret Str.306;

procedure Str.36 (#Attr.2):
    let Str.269 : U64 = lowlevel StrCountUtf8Bytes #Attr.2;
    ret Str.269;

procedure Str.37 (#Attr.2, #Attr.3, #Attr.4):
    let Str.267 : Str = lowlevel StrSubstringUnsafe #Attr.2 #Attr.3 #Attr.4;
    ret Str.267;

procedure Str.38 (Str.112, Str.113):
    let Str.263 : [C , C U64] = CallByName Str.57 Str.112 Str.113;
    let Str.276 : U8 = 1i64;
    let Str.277 : U8 = GetTagId Str.263;
    let Str.278 : Int1 = lowlevel Eq Str.276 Str.277;
    if Str.278 then
        let Str.114 : U64 = UnionAtIndex (Id 1) (Index 0) Str.263;
        let Str.272 : U64 = CallByName Str.36 Str.112;
        let Str.273 : U64 = CallByName Str.36 Str.113;
        let Str.271 : U64 = CallByName Num.20 Str.272 Str.273;
        let Str.115 : U64 = CallByName Num.20 Str.271 Str.114;
        let Str.270 : U64 = 0i64;
        inc Str.112;
        let Str.116 : Str = CallByName Str.37 Str.112 Str.270 Str.114;
        let Str.268 : U64 = CallByName Str.36 Str.113;
        let Str.266 : U64 = CallByName Num.51 Str.114 Str.268;
        let Str.117 : Str = CallByName Str.37 Str.112 Str.266 Str.115;
        let Str.265 : {Str, Str} = Struct {Str.117, Str.116};
        let Str.264 : [C {}, C {Str, Str}] = TagId(1) Str.265;
        ret Str.264;
    else
        dec Str.112;
        let Str.275 : {} = Struct {};
        let Str.274 : [C {}, C {Str, Str}] = TagId(0) Str.275;
        ret Str.274;

procedure Str.45 (Str.91, Str.92, Str.93):
    inc Str.91;
    let Str.344 : [C {}, C {Str, Str}] = CallByName Str.38 Str.91 Str.92;
    let Str.352 : U8 = 1i64;
    let Str.353 : U8 = GetTagId Str.344;
    let Str.354 : Int1 = lowlevel Eq Str.352 Str.353;
    if Str.354 then
        let Str.351 : {Str, Str} = UnionAtIndex (Id 1) (Index 0) Str.344;
        let Str.95 : Str = StructAtIndex 0 Str.351;
        let Str.94 : Str = StructAtIndex 1 Str.351;
        let Str.349 : U64 = CallByName Str.36 Str.91;
        dec Str.91;
        let Str.348 : Str = CallByName Str.20 Str.349;
        let Str.347 : Str = CallByName Str.3 Str.348 Str.94;
        dec Str.94;
        let Str.346 : Str = CallByName Str.3 Str.347 Str.93;
        let Str.345 : Str = CallByName Str.56 Str.346 Str.95 Str.92 Str.93;
        ret Str.345;
    else
        dec Str.344;
        ret Str.91;

procedure Str.56 (#Derived_gen.62, #Derived_gen.63, #Derived_gen.64, #Derived_gen.65):
    joinpoint Str.253 Str.96 Str.97 Str.98 Str.99:
        inc Str.97;
        let Str.254 : [C {}, C {Str, Str}] = CallByName Str.38 Str.97 Str.98;
        let Str.260 : U8 = 1i64;
        let Str.261 : U8 = GetTagId Str.254;
        let Str.262 : Int1 = lowlevel Eq Str.260 Str.261;
        if Str.262 then
            dec Str.97;
            let Str.259 : {Str, Str} = UnionAtIndex (Id 1) (Index 0) Str.254;
            let Str.101 : Str = StructAtIndex 0 Str.259;
            let Str.100 : Str = StructAtIndex 1 Str.259;
            let Str.257 : Str = CallByName Str.3 Str.96 Str.100;
            dec Str.100;
            let Str.256 : Str = CallByName Str.3 Str.257 Str.99;
            jump Str.253 Str.256 Str.101 Str.98 Str.99;
        else
            dec Str.98;
            dec Str.99;
            dec Str.254;
            let Str.258 : Str = CallByName Str.3 Str.96 Str.97;
            dec Str.97;
            ret Str.258;
    in
    inc #Derived_gen.64;
    inc #Derived_gen.65;
    jump Str.253 #Derived_gen.62 #Derived_gen.63 #Derived_gen.64 #Derived_gen.65;

procedure Str.57 (Str.121, Str.122):
    let Str.123 : U64 = CallByName Str.36 Str.121;
    let Str.124 : U64 = CallByName Str.36 Str.122;
    let Str.125 : U64 = CallByName Num.77 Str.123 Str.124;
    let Str.280 : U64 = 0i64;
    let Str.279 : [C , C U64] = CallByName Str.58 Str.121 Str.122 Str.280 Str.125;
    ret Str.279;

procedure Str.58 (#Derived_gen.68, #Derived_gen.69, #Derived_gen.70, #Derived_gen.71):
    joinpoint Str.281 Str.126 Str.127 Str.128 Str.129:
        let Str.283 : Int1 = CallByName Num.23 Str.128 Str.129;
        if Str.283 then
            let Str.287 : Int1 = CallByName Str.62 Str.126 Str.128 Str.127;
            if Str.287 then
                dec Str.127;
                dec Str.126;
                let Str.288 : [C , C U64] = TagId(1) Str.128;
                ret Str.288;
            else
                let Str.286 : U64 = 1i64;
                let Str.285 : U64 = CallByName Num.51 Str.128 Str.286;
                jump Str.281 Str.126 Str.127 Str.285 Str.129;
        else
            dec Str.127;
            dec Str.126;
            let Str.282 : [C , C U64] = TagId(0) ;
            ret Str.282;
    in
    inc #Derived_gen.69;
    inc #Derived_gen.68;
    jump Str.281 #Derived_gen.68 #Derived_gen.69 #Derived_gen.70 #Derived_gen.71;

procedure Str.61 (Str.152, Str.153):
    let Str.311 : Int1 = CallByName Num.22 Str.152 Str.153;
    if Str.311 then
        ret Str.152;
    else
        ret Str.153;

procedure Str.62 (Str.154, Str.155, Str.156):
    let Str.157 : U64 = CallByName Str.36 Str.154;
    let Str.158 : U64 = CallByName Str.36 Str.156;
    let Str.309 : U64 = CallByName Num.53 Str.155 Str.158;
    let Str.159 : U64 = CallByName Str.61 Str.309 Str.157;
    let Str.308 : U64 = 0i64;
    inc Str.156;
    inc Str.154;
    let Str.290 : {U64, Str, U64, Str, U64, U64} = Struct {Str.159, Str.154, Str.155, Str.156, Str.308, Str.158};
    let Str.289 : Int1 = CallByName Str.63 Str.290;
    ret Str.289;

procedure Str.63 (Str.160):
    let Str.166 : U64 = StructAtIndex 0 Str.160;
    let Str.161 : Str = StructAtIndex 1 Str.160;
    let Str.162 : U64 = StructAtIndex 2 Str.160;
    let Str.163 : Str = StructAtIndex 3 Str.160;
    let Str.164 : U64 = StructAtIndex 4 Str.160;
    let Str.165 : U64 = StructAtIndex 5 Str.160;
    let Str.167 : Int1 = CallByName Num.25 Str.162 Str.166;
    if Str.167 then
        dec Str.163;
        dec Str.161;
        let Str.168 : Int1 = CallByName Bool.11 Str.164 Str.165;
        ret Str.168;
    else
        let Str.304 : U8 = CallByName Str.35 Str.161 Str.162;
        let Str.305 : U8 = CallByName Str.35 Str.163 Str.164;
        let Str.169 : Int1 = CallByName Bool.11 Str.304 Str.305;
        let Str.294 : U64 = StructAtIndex 0 Str.160;
        let Str.295 : Str = StructAtIndex 1 Str.160;
        let Str.297 : Str = StructAtIndex 3 Str.160;
        let Str.299 : U64 = StructAtIndex 5 Str.160;
        let Str.303 : U64 = 1i64;
        let Str.301 : U64 = CallByName Num.51 Str.164 Str.303;
        let Str.302 : U64 = 1i64;
        let Str.300 : U64 = CallByName Num.51 Str.162 Str.302;
        let Str.293 : {U64, Str, U64, Str, U64, U64} = Struct {Str.294, Str.295, Str.300, Str.297, Str.301, Str.299};
        let Str.170 : Int1 = CallByName Str.63 Str.293;
        let Str.292 : Int1 = CallByName Bool.3 Str.169 Str.170;
        ret Str.292;

procedure Test.0 ():
    let Test.8 : Str = "a";
    let Test.9 : I64 = 1i64;
    let Test.4 : {Str, I64} = Struct {Test.8, Test.9};
    let Test.6 : Str = "b";
    let Test.7 : I64 = 2i64;
    let Test.5 : {Str, I64} = Struct {Test.6, Test.7};
    let Test.3 : List {Str, I64} = Array [Test.4, Test.5];
    let Test.2 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.12 Test.3;
    dec Test.3;
    let Test.1 : Str = CallByName Inspect.33 Test.2;
    ret Test.1;
