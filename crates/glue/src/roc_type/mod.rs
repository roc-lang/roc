// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct File {
    pub content: roc_std::RocStr,
    pub name: roc_std::RocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Types {
    pub aligns: roc_std::RocList<u32>,
    pub deps: roc_std::RocList<Tuple2>,
    pub entrypoints: roc_std::RocList<Tuple1>,
    pub sizes: roc_std::RocList<u32>,
    pub types: roc_std::RocList<RocType>,
    pub typesByName: roc_std::RocList<Tuple1>,
    pub target: Target,
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[repr(C)]
#[derive(Clone, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
pub struct Tuple1 {
    f0: roc_std::RocStr,
    f1: u32,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_RocType {
    Bool = 0,
    EmptyTagUnion = 1,
    Function = 2,
    Num = 3,
    RecursivePointer = 4,
    RocBox = 5,
    RocDict = 6,
    RocList = 7,
    RocResult = 8,
    RocSet = 9,
    RocStr = 10,
    Struct = 11,
    TagUnion = 12,
    TagUnionPayload = 13,
    Unit = 14,
    Unsized = 15,
}

impl core::fmt::Debug for discriminant_RocType {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Bool => f.write_str("discriminant_RocType::Bool"),
            Self::EmptyTagUnion => f.write_str("discriminant_RocType::EmptyTagUnion"),
            Self::Function => f.write_str("discriminant_RocType::Function"),
            Self::Num => f.write_str("discriminant_RocType::Num"),
            Self::RecursivePointer => f.write_str("discriminant_RocType::RecursivePointer"),
            Self::RocBox => f.write_str("discriminant_RocType::RocBox"),
            Self::RocDict => f.write_str("discriminant_RocType::RocDict"),
            Self::RocList => f.write_str("discriminant_RocType::RocList"),
            Self::RocResult => f.write_str("discriminant_RocType::RocResult"),
            Self::RocSet => f.write_str("discriminant_RocType::RocSet"),
            Self::RocStr => f.write_str("discriminant_RocType::RocStr"),
            Self::Struct => f.write_str("discriminant_RocType::Struct"),
            Self::TagUnion => f.write_str("discriminant_RocType::TagUnion"),
            Self::TagUnionPayload => f.write_str("discriminant_RocType::TagUnionPayload"),
            Self::Unit => f.write_str("discriminant_RocType::Unit"),
            Self::Unsized => f.write_str("discriminant_RocType::Unsized"),
        }
    }
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[repr(C)]
pub union RocType {
    Function: core::mem::ManuallyDrop<RocFn>,
    Num: RocNum,
    RecursivePointer: u32,
    RocBox: u32,
    RocDict: RocType_RocDict,
    RocList: u32,
    RocResult: RocType_RocDict,
    RocSet: u32,
    Struct: core::mem::ManuallyDrop<R1>,
    TagUnion: core::mem::ManuallyDrop<RocTagUnion>,
    TagUnionPayload: core::mem::ManuallyDrop<R1>,
    _sizer: [u8; 96],
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct R16 {
    pub id: u32,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R8 {
    pub name: roc_std::RocStr,
    pub payload: U1,
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R4 {
    pub id: u32,
    pub name: roc_std::RocStr,
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R2 {
    pub accessors: R3,
    pub id: u32,
    pub name: roc_std::RocStr,
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[repr(C)]
#[derive(Clone, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
pub struct Tuple2 {
    f0: u32,
    f1: roc_std::RocList<u32>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Target {
    pub architecture: Architecture,
    pub operatingSystem: OperatingSystem,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum OperatingSystem {
    Freestanding = 0,
    Linux = 1,
    Mac = 2,
    Windows = 3,
}

impl core::fmt::Debug for OperatingSystem {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Freestanding => f.write_str("OperatingSystem::Freestanding"),
            Self::Linux => f.write_str("OperatingSystem::Linux"),
            Self::Mac => f.write_str("OperatingSystem::Mac"),
            Self::Windows => f.write_str("OperatingSystem::Windows"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum Architecture {
    Aarch32 = 0,
    Aarch64 = 1,
    Wasm32 = 2,
    X86x32 = 3,
    X86x64 = 4,
}

impl core::fmt::Debug for Architecture {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Aarch32 => f.write_str("Architecture::Aarch32"),
            Self::Aarch64 => f.write_str("Architecture::Aarch64"),
            Self::Wasm32 => f.write_str("Architecture::Wasm32"),
            Self::X86x32 => f.write_str("Architecture::X86x32"),
            Self::X86x64 => f.write_str("Architecture::X86x64"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_RocTagUnion {
    Enumeration = 0,
    NonNullableUnwrapped = 1,
    NonRecursive = 2,
    NullableUnwrapped = 3,
    NullableWrapped = 4,
    Recursive = 5,
    SingleTagStruct = 6,
}

impl core::fmt::Debug for discriminant_RocTagUnion {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Enumeration => f.write_str("discriminant_RocTagUnion::Enumeration"),
            Self::NonNullableUnwrapped => {
                f.write_str("discriminant_RocTagUnion::NonNullableUnwrapped")
            }
            Self::NonRecursive => f.write_str("discriminant_RocTagUnion::NonRecursive"),
            Self::NullableUnwrapped => f.write_str("discriminant_RocTagUnion::NullableUnwrapped"),
            Self::NullableWrapped => f.write_str("discriminant_RocTagUnion::NullableWrapped"),
            Self::Recursive => f.write_str("discriminant_RocTagUnion::Recursive"),
            Self::SingleTagStruct => f.write_str("discriminant_RocTagUnion::SingleTagStruct"),
        }
    }
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[repr(C)]
pub union RocTagUnion {
    Enumeration: core::mem::ManuallyDrop<R5>,
    NonNullableUnwrapped: core::mem::ManuallyDrop<R6>,
    NonRecursive: core::mem::ManuallyDrop<R7>,
    NullableUnwrapped: core::mem::ManuallyDrop<R9>,
    NullableWrapped: core::mem::ManuallyDrop<R10>,
    Recursive: core::mem::ManuallyDrop<R7>,
    SingleTagStruct: core::mem::ManuallyDrop<R14>,
    _sizer: [u8; 88],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R14 {
    pub name: roc_std::RocStr,
    pub payload: RocSingleTagPayload,
    pub tagName: roc_std::RocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_RocSingleTagPayload {
    HasClosure = 0,
    HasNoClosure = 1,
}

impl core::fmt::Debug for discriminant_RocSingleTagPayload {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::HasClosure => f.write_str("discriminant_RocSingleTagPayload::HasClosure"),
            Self::HasNoClosure => f.write_str("discriminant_RocSingleTagPayload::HasNoClosure"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union RocSingleTagPayload {
    HasClosure: core::mem::ManuallyDrop<roc_std::RocList<R4>>,
    HasNoClosure: core::mem::ManuallyDrop<roc_std::RocList<R16>>,
    _sizer: [u8; 32],
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R10 {
    pub discriminantOffset: u32,
    pub discriminantSize: u32,
    pub name: roc_std::RocStr,
    pub tags: roc_std::RocList<R8>,
    pub indexOfNullTag: u16,
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R9 {
    pub name: roc_std::RocStr,
    pub nonNullPayload: u32,
    pub nonNullTag: roc_std::RocStr,
    pub nullTag: roc_std::RocStr,
    pub whichTagIsNull: U2,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum U2 {
    FirstTagIsNull = 0,
    SecondTagIsNull = 1,
}

impl core::fmt::Debug for U2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::FirstTagIsNull => f.write_str("U2::FirstTagIsNull"),
            Self::SecondTagIsNull => f.write_str("U2::SecondTagIsNull"),
        }
    }
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R7 {
    pub discriminantOffset: u32,
    pub discriminantSize: u32,
    pub name: roc_std::RocStr,
    pub tags: roc_std::RocList<R8>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_U1 {
    None = 0,
    Some = 1,
}

impl core::fmt::Debug for discriminant_U1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::None => f.write_str("discriminant_U1::None"),
            Self::Some => f.write_str("discriminant_U1::Some"),
        }
    }
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[repr(C)]
pub union U1 {
    Some: u32,
    _sizer: [u8; 8],
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R6 {
    pub name: roc_std::RocStr,
    pub payload: u32,
    pub tagName: roc_std::RocStr,
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R5 {
    pub name: roc_std::RocStr,
    pub size: u32,
    pub tags: roc_std::RocList<roc_std::RocStr>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R1 {
    pub fields: RocStructFields,
    pub name: roc_std::RocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_RocStructFields {
    HasClosure = 0,
    HasNoClosure = 1,
}

impl core::fmt::Debug for discriminant_RocStructFields {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::HasClosure => f.write_str("discriminant_RocStructFields::HasClosure"),
            Self::HasNoClosure => f.write_str("discriminant_RocStructFields::HasNoClosure"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union RocStructFields {
    HasClosure: core::mem::ManuallyDrop<roc_std::RocList<R2>>,
    HasNoClosure: core::mem::ManuallyDrop<roc_std::RocList<R4>>,
    _sizer: [u8; 32],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct R3 {
    pub getter: roc_std::RocStr,
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct RocType_RocDict {
    pub f0: u32,
    pub f1: u32,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum RocNum {
    Dec = 0,
    F32 = 1,
    F64 = 2,
    I128 = 3,
    I16 = 4,
    I32 = 5,
    I64 = 6,
    I8 = 7,
    U128 = 8,
    U16 = 9,
    U32 = 10,
    U64 = 11,
    U8 = 12,
}

impl core::fmt::Debug for RocNum {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Dec => f.write_str("RocNum::Dec"),
            Self::F32 => f.write_str("RocNum::F32"),
            Self::F64 => f.write_str("RocNum::F64"),
            Self::I128 => f.write_str("RocNum::I128"),
            Self::I16 => f.write_str("RocNum::I16"),
            Self::I32 => f.write_str("RocNum::I32"),
            Self::I64 => f.write_str("RocNum::I64"),
            Self::I8 => f.write_str("RocNum::I8"),
            Self::U128 => f.write_str("RocNum::U128"),
            Self::U16 => f.write_str("RocNum::U16"),
            Self::U32 => f.write_str("RocNum::U32"),
            Self::U64 => f.write_str("RocNum::U64"),
            Self::U8 => f.write_str("RocNum::U8"),
        }
    }
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct RocFn {
    pub args: roc_std::RocList<u32>,
    pub externName: roc_std::RocStr,
    pub functionName: roc_std::RocStr,
    pub lambdaSet: u32,
    pub ret: u32,
    pub is_toplevel: bool,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[repr(C)]
#[derive(Clone, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
pub struct Tuple1 {
    f0: roc_std::RocStr,
    f1: u64,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[repr(C)]
pub union RocType {
    Function: core::mem::ManuallyDrop<RocFn>,
    Num: RocNum,
    RecursivePointer: u64,
    RocBox: u64,
    RocDict: RocType_RocDict,
    RocList: u64,
    RocResult: RocType_RocDict,
    RocSet: u64,
    Struct: core::mem::ManuallyDrop<R1>,
    TagUnion: core::mem::ManuallyDrop<RocTagUnion>,
    TagUnionPayload: core::mem::ManuallyDrop<R1>,
    _sizer: [u8; 104],
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct R16 {
    pub id: u64,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R4 {
    pub id: u64,
    pub name: roc_std::RocStr,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R2 {
    pub accessors: R3,
    pub id: u64,
    pub name: roc_std::RocStr,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[repr(C)]
#[derive(Clone, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
pub struct Tuple2 {
    f0: u64,
    f1: roc_std::RocList<u64>,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[repr(C)]
pub union RocTagUnion {
    Enumeration: core::mem::ManuallyDrop<R5>,
    NonNullableUnwrapped: core::mem::ManuallyDrop<R6>,
    NonRecursive: core::mem::ManuallyDrop<R7>,
    NullableUnwrapped: core::mem::ManuallyDrop<R9>,
    NullableWrapped: core::mem::ManuallyDrop<R10>,
    Recursive: core::mem::ManuallyDrop<R7>,
    SingleTagStruct: core::mem::ManuallyDrop<R14>,
    _sizer: [u8; 96],
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R10 {
    pub name: roc_std::RocStr,
    pub tags: roc_std::RocList<R8>,
    pub discriminantOffset: u32,
    pub discriminantSize: u32,
    pub indexOfNullTag: u16,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R9 {
    pub name: roc_std::RocStr,
    pub nonNullPayload: u64,
    pub nonNullTag: roc_std::RocStr,
    pub nullTag: roc_std::RocStr,
    pub whichTagIsNull: U2,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R7 {
    pub name: roc_std::RocStr,
    pub tags: roc_std::RocList<R8>,
    pub discriminantOffset: u32,
    pub discriminantSize: u32,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[repr(C)]
pub union U1 {
    Some: u64,
    _sizer: [u8; 16],
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R6 {
    pub name: roc_std::RocStr,
    pub payload: u64,
    pub tagName: roc_std::RocStr,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct R5 {
    pub name: roc_std::RocStr,
    pub tags: roc_std::RocList<roc_std::RocStr>,
    pub size: u32,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[derive(Clone, Copy, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct RocType_RocDict {
    pub f0: u64,
    pub f1: u64,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct RocFn {
    pub args: roc_std::RocList<u64>,
    pub externName: roc_std::RocStr,
    pub functionName: roc_std::RocStr,
    pub lambdaSet: u64,
    pub ret: u64,
    pub isToplevel: bool,
}

impl Tuple1 {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named T, with the given payload.
    pub fn T(f0: roc_std::RocStr, f1: u32) -> Self {
        Self { f0, f1 }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Since `T` only has one tag (namely, `T`),
    /// convert it to `T`'s payload.
    pub fn into_T(self) -> (roc_std::RocStr, u32) {
        (self.f0, self.f1)
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Since `T` only has one tag (namely, `T`),
    /// convert it to `T`'s payload.
    pub fn as_T(&self) -> (&roc_std::RocStr, &u32) {
        (&self.f0, &self.f1)
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named T, with the given payload.
    pub fn T(f0: roc_std::RocStr, f1: u64) -> Self {
        Self { f0, f1 }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Since `T` only has one tag (namely, `T`),
    /// convert it to `T`'s payload.
    pub fn into_T(self) -> (roc_std::RocStr, u64) {
        (self.f0, self.f1)
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Since `T` only has one tag (namely, `T`),
    /// convert it to `T`'s payload.
    pub fn as_T(&self) -> (&roc_std::RocStr, &u64) {
        (&self.f0, &self.f1)
    }
}

impl core::fmt::Debug for Tuple1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("Tuple1::T")
            .field(&self.f0)
            .field(&self.f1)
            .finish()
    }
}

impl RocType {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_RocType {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_RocType>(*bytes.as_ptr().add(48))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_RocType) {
        let discriminant_ptr: *mut discriminant_RocType = (self as *mut RocType).cast();

        unsafe {
            *(discriminant_ptr.add(48)) = discriminant;
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named Bool, which has no payload.
    pub const Bool: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<RocType>()];

        bytes[48] = discriminant_RocType::Bool as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<RocType>()], RocType>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Bool tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Bool(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Bool tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Bool(&self) {
        ()
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named EmptyTagUnion, which has no payload.
    pub const EmptyTagUnion: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<RocType>()];

        bytes[48] = discriminant_RocType::EmptyTagUnion as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<RocType>()], RocType>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the EmptyTagUnion tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_EmptyTagUnion(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the EmptyTagUnion tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_EmptyTagUnion(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Function`, with the appropriate payload
    pub fn Function(arg0: RocFn) -> Self {
        let mut answer = Self {
            Function: core::mem::ManuallyDrop::new(arg0),
        };

        answer.set_discriminant(discriminant_RocType::Function);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `Function` and convert it to `Function`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Function`.
    pub unsafe fn into_Function(mut self) -> RocFn {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::Function);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Function,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `Function` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Function`.
    pub unsafe fn as_Function(&self) -> &RocFn {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::Function);
        let payload = &self.Function;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Num`, with the appropriate payload
    pub fn Num(arg: RocNum) -> Self {
        let mut answer = Self { Num: arg };

        answer.set_discriminant(discriminant_RocType::Num);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `Num` and convert it to `Num`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Num`.
    pub unsafe fn into_Num(self) -> RocNum {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::Num);
        let payload = self.Num;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `Num` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Num`.
    pub unsafe fn as_Num(&self) -> &RocNum {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::Num);
        let payload = &self.Num;

        &payload
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Construct a tag named `RecursivePointer`, with the appropriate payload
    pub fn RecursivePointer(arg: u32) -> Self {
        let mut answer = Self {
            RecursivePointer: arg,
        };

        answer.set_discriminant(discriminant_RocType::RecursivePointer);

        answer
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RecursivePointer` and convert it to `RecursivePointer`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RecursivePointer`.
    pub unsafe fn into_RecursivePointer(self) -> u32 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RecursivePointer);
        let payload = self.RecursivePointer;

        payload
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RecursivePointer` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RecursivePointer`.
    pub unsafe fn as_RecursivePointer(&self) -> &u32 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RecursivePointer);
        let payload = &self.RecursivePointer;

        &payload
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Construct a tag named `RocBox`, with the appropriate payload
    pub fn RocBox(arg: u32) -> Self {
        let mut answer = Self { RocBox: arg };

        answer.set_discriminant(discriminant_RocType::RocBox);

        answer
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocBox` and convert it to `RocBox`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocBox`.
    pub unsafe fn into_RocBox(self) -> u32 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocBox);
        let payload = self.RocBox;

        payload
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocBox` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocBox`.
    pub unsafe fn as_RocBox(&self) -> &u32 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocBox);
        let payload = &self.RocBox;

        &payload
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Construct a tag named `RocDict`, with the appropriate payload
    pub fn RocDict(arg0: u32, arg1: u32) -> Self {
        let mut answer = Self {
            RocDict: RocType_RocDict { f0: arg0, f1: arg1 },
        };

        answer.set_discriminant(discriminant_RocType::RocDict);

        answer
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocDict` and convert it to `RocDict`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocDict`.
    pub unsafe fn into_RocDict(self) -> (u32, u32) {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocDict);
        let payload = self.RocDict;

        (payload.f0, payload.f1)
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocDict` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocDict`.
    pub unsafe fn as_RocDict(&self) -> (&u32, &u32) {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocDict);
        let payload = &self.RocDict;

        (&payload.f0, &payload.f1)
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Construct a tag named `RocList`, with the appropriate payload
    pub fn RocList(arg: u32) -> Self {
        let mut answer = Self { RocList: arg };

        answer.set_discriminant(discriminant_RocType::RocList);

        answer
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocList` and convert it to `RocList`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocList`.
    pub unsafe fn into_RocList(self) -> u32 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocList);
        let payload = self.RocList;

        payload
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocList` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocList`.
    pub unsafe fn as_RocList(&self) -> &u32 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocList);
        let payload = &self.RocList;

        &payload
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Construct a tag named `RocResult`, with the appropriate payload
    pub fn RocResult(arg0: u32, arg1: u32) -> Self {
        let mut answer = Self {
            RocResult: RocType_RocDict { f0: arg0, f1: arg1 },
        };

        answer.set_discriminant(discriminant_RocType::RocResult);

        answer
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocResult` and convert it to `RocResult`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocResult`.
    pub unsafe fn into_RocResult(self) -> (u32, u32) {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocResult);
        let payload = self.RocResult;

        (payload.f0, payload.f1)
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocResult` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocResult`.
    pub unsafe fn as_RocResult(&self) -> (&u32, &u32) {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocResult);
        let payload = &self.RocResult;

        (&payload.f0, &payload.f1)
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Construct a tag named `RocSet`, with the appropriate payload
    pub fn RocSet(arg: u32) -> Self {
        let mut answer = Self { RocSet: arg };

        answer.set_discriminant(discriminant_RocType::RocSet);

        answer
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocSet` and convert it to `RocSet`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocSet`.
    pub unsafe fn into_RocSet(self) -> u32 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocSet);
        let payload = self.RocSet;

        payload
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocSet` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocSet`.
    pub unsafe fn as_RocSet(&self) -> &u32 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocSet);
        let payload = &self.RocSet;

        &payload
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named RocStr, which has no payload.
    pub const RocStr: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<RocType>()];

        bytes[48] = discriminant_RocType::RocStr as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<RocType>()], RocType>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the RocStr tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_RocStr(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the RocStr tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_RocStr(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Struct`, with the appropriate payload
    pub fn Struct(arg0: R1) -> Self {
        let mut answer = Self {
            Struct: core::mem::ManuallyDrop::new(arg0),
        };

        answer.set_discriminant(discriminant_RocType::Struct);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `Struct` and convert it to `Struct`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Struct`.
    pub unsafe fn into_Struct(mut self) -> R1 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::Struct);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Struct,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `Struct` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Struct`.
    pub unsafe fn as_Struct(&self) -> &R1 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::Struct);
        let payload = &self.Struct;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `TagUnion`, with the appropriate payload
    pub fn TagUnion(arg: RocTagUnion) -> Self {
        let mut answer = Self {
            TagUnion: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_RocType::TagUnion);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `TagUnion` and convert it to `TagUnion`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `TagUnion`.
    pub unsafe fn into_TagUnion(mut self) -> RocTagUnion {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::TagUnion);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.TagUnion,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `TagUnion` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `TagUnion`.
    pub unsafe fn as_TagUnion(&self) -> &RocTagUnion {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::TagUnion);
        let payload = &self.TagUnion;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `TagUnionPayload`, with the appropriate payload
    pub fn TagUnionPayload(arg0: R1) -> Self {
        let mut answer = Self {
            TagUnionPayload: core::mem::ManuallyDrop::new(arg0),
        };

        answer.set_discriminant(discriminant_RocType::TagUnionPayload);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `TagUnionPayload` and convert it to `TagUnionPayload`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `TagUnionPayload`.
    pub unsafe fn into_TagUnionPayload(mut self) -> R1 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::TagUnionPayload);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.TagUnionPayload,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `TagUnionPayload` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `TagUnionPayload`.
    pub unsafe fn as_TagUnionPayload(&self) -> &R1 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::TagUnionPayload);
        let payload = &self.TagUnionPayload;

        payload
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named Unit, which has no payload.
    pub const Unit: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<RocType>()];

        bytes[48] = discriminant_RocType::Unit as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<RocType>()], RocType>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Unit tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Unit(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Unit tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Unit(&self) {
        ()
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named Unsized, which has no payload.
    pub const Unsized: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<RocType>()];

        bytes[48] = discriminant_RocType::Unsized as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<RocType>()], RocType>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Unsized tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Unsized(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Unsized tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_Unsized(&self) {
        ()
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_RocType {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_RocType>(*bytes.as_ptr().add(96))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_RocType) {
        let discriminant_ptr: *mut discriminant_RocType = (self as *mut RocType).cast();

        unsafe {
            *(discriminant_ptr.add(96)) = discriminant;
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named Bool, which has no payload.
    pub const Bool: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<RocType>()];

        bytes[96] = discriminant_RocType::Bool as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<RocType>()], RocType>(bytes)
    };

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named EmptyTagUnion, which has no payload.
    pub const EmptyTagUnion: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<RocType>()];

        bytes[96] = discriminant_RocType::EmptyTagUnion as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<RocType>()], RocType>(bytes)
    };

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Construct a tag named `RecursivePointer`, with the appropriate payload
    pub fn RecursivePointer(arg: u64) -> Self {
        let mut answer = Self {
            RecursivePointer: arg,
        };

        answer.set_discriminant(discriminant_RocType::RecursivePointer);

        answer
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RecursivePointer` and convert it to `RecursivePointer`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RecursivePointer`.
    pub unsafe fn into_RecursivePointer(self) -> u64 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RecursivePointer);
        let payload = self.RecursivePointer;

        payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RecursivePointer` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RecursivePointer`.
    pub unsafe fn as_RecursivePointer(&self) -> &u64 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RecursivePointer);
        let payload = &self.RecursivePointer;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Construct a tag named `RocBox`, with the appropriate payload
    pub fn RocBox(arg: u64) -> Self {
        let mut answer = Self { RocBox: arg };

        answer.set_discriminant(discriminant_RocType::RocBox);

        answer
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocBox` and convert it to `RocBox`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocBox`.
    pub unsafe fn into_RocBox(self) -> u64 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocBox);
        let payload = self.RocBox;

        payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocBox` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocBox`.
    pub unsafe fn as_RocBox(&self) -> &u64 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocBox);
        let payload = &self.RocBox;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Construct a tag named `RocDict`, with the appropriate payload
    pub fn RocDict(arg0: u64, arg1: u64) -> Self {
        let mut answer = Self {
            RocDict: RocType_RocDict { f0: arg0, f1: arg1 },
        };

        answer.set_discriminant(discriminant_RocType::RocDict);

        answer
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocDict` and convert it to `RocDict`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocDict`.
    pub unsafe fn into_RocDict(self) -> (u64, u64) {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocDict);
        let payload = self.RocDict;

        (payload.f0, payload.f1)
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocDict` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocDict`.
    pub unsafe fn as_RocDict(&self) -> (&u64, &u64) {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocDict);
        let payload = &self.RocDict;

        (&payload.f0, &payload.f1)
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Construct a tag named `RocList`, with the appropriate payload
    pub fn RocList(arg: u64) -> Self {
        let mut answer = Self { RocList: arg };

        answer.set_discriminant(discriminant_RocType::RocList);

        answer
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocList` and convert it to `RocList`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocList`.
    pub unsafe fn into_RocList(self) -> u64 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocList);
        let payload = self.RocList;

        payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocList` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocList`.
    pub unsafe fn as_RocList(&self) -> &u64 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocList);
        let payload = &self.RocList;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Construct a tag named `RocResult`, with the appropriate payload
    pub fn RocResult(arg0: u64, arg1: u64) -> Self {
        let mut answer = Self {
            RocResult: RocType_RocDict { f0: arg0, f1: arg1 },
        };

        answer.set_discriminant(discriminant_RocType::RocResult);

        answer
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocResult` and convert it to `RocResult`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocResult`.
    pub unsafe fn into_RocResult(self) -> (u64, u64) {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocResult);
        let payload = self.RocResult;

        (payload.f0, payload.f1)
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocResult` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocResult`.
    pub unsafe fn as_RocResult(&self) -> (&u64, &u64) {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocResult);
        let payload = &self.RocResult;

        (&payload.f0, &payload.f1)
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Construct a tag named `RocSet`, with the appropriate payload
    pub fn RocSet(arg: u64) -> Self {
        let mut answer = Self { RocSet: arg };

        answer.set_discriminant(discriminant_RocType::RocSet);

        answer
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocSet` and convert it to `RocSet`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocSet`.
    pub unsafe fn into_RocSet(self) -> u64 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocSet);
        let payload = self.RocSet;

        payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `RocType` has a `.discriminant()` of `RocSet` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `RocSet`.
    pub unsafe fn as_RocSet(&self) -> &u64 {
        debug_assert_eq!(self.discriminant(), discriminant_RocType::RocSet);
        let payload = &self.RocSet;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named RocStr, which has no payload.
    pub const RocStr: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<RocType>()];

        bytes[96] = discriminant_RocType::RocStr as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<RocType>()], RocType>(bytes)
    };

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named Unit, which has no payload.
    pub const Unit: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<RocType>()];

        bytes[96] = discriminant_RocType::Unit as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<RocType>()], RocType>(bytes)
    };

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named Unsized, which has no payload.
    pub const Unsized: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<RocType>()];

        bytes[96] = discriminant_RocType::Unsized as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<RocType>()], RocType>(bytes)
    };
}

impl Drop for RocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_RocType::Bool => {}
            discriminant_RocType::EmptyTagUnion => {}
            discriminant_RocType::Function => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.Function)
            },
            discriminant_RocType::Num => {}
            discriminant_RocType::RecursivePointer => {}
            discriminant_RocType::RocBox => {}
            discriminant_RocType::RocDict => {}
            discriminant_RocType::RocList => {}
            discriminant_RocType::RocResult => {}
            discriminant_RocType::RocSet => {}
            discriminant_RocType::RocStr => {}
            discriminant_RocType::Struct => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.Struct)
            },
            discriminant_RocType::TagUnion => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.TagUnion)
            },
            discriminant_RocType::TagUnionPayload => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.TagUnionPayload)
            },
            discriminant_RocType::Unit => {}
            discriminant_RocType::Unsized => {}
        }
    }
}

impl Eq for RocType {}

impl PartialEq for RocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_RocType::Bool => true,
                discriminant_RocType::EmptyTagUnion => true,
                discriminant_RocType::Function => self.Function == other.Function,
                discriminant_RocType::Num => self.Num == other.Num,
                discriminant_RocType::RecursivePointer => {
                    self.RecursivePointer == other.RecursivePointer
                }
                discriminant_RocType::RocBox => self.RocBox == other.RocBox,
                discriminant_RocType::RocDict => self.RocDict == other.RocDict,
                discriminant_RocType::RocList => self.RocList == other.RocList,
                discriminant_RocType::RocResult => self.RocResult == other.RocResult,
                discriminant_RocType::RocSet => self.RocSet == other.RocSet,
                discriminant_RocType::RocStr => true,
                discriminant_RocType::Struct => self.Struct == other.Struct,
                discriminant_RocType::TagUnion => self.TagUnion == other.TagUnion,
                discriminant_RocType::TagUnionPayload => {
                    self.TagUnionPayload == other.TagUnionPayload
                }
                discriminant_RocType::Unit => true,
                discriminant_RocType::Unsized => true,
            }
        }
    }
}

impl PartialOrd for RocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_RocType::Bool => Some(core::cmp::Ordering::Equal),
                discriminant_RocType::EmptyTagUnion => Some(core::cmp::Ordering::Equal),
                discriminant_RocType::Function => self.Function.partial_cmp(&other.Function),
                discriminant_RocType::Num => self.Num.partial_cmp(&other.Num),
                discriminant_RocType::RecursivePointer => {
                    self.RecursivePointer.partial_cmp(&other.RecursivePointer)
                }
                discriminant_RocType::RocBox => self.RocBox.partial_cmp(&other.RocBox),
                discriminant_RocType::RocDict => self.RocDict.partial_cmp(&other.RocDict),
                discriminant_RocType::RocList => self.RocList.partial_cmp(&other.RocList),
                discriminant_RocType::RocResult => self.RocResult.partial_cmp(&other.RocResult),
                discriminant_RocType::RocSet => self.RocSet.partial_cmp(&other.RocSet),
                discriminant_RocType::RocStr => Some(core::cmp::Ordering::Equal),
                discriminant_RocType::Struct => self.Struct.partial_cmp(&other.Struct),
                discriminant_RocType::TagUnion => self.TagUnion.partial_cmp(&other.TagUnion),
                discriminant_RocType::TagUnionPayload => {
                    self.TagUnionPayload.partial_cmp(&other.TagUnionPayload)
                }
                discriminant_RocType::Unit => Some(core::cmp::Ordering::Equal),
                discriminant_RocType::Unsized => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for RocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_RocType::Bool => core::cmp::Ordering::Equal,
                discriminant_RocType::EmptyTagUnion => core::cmp::Ordering::Equal,
                discriminant_RocType::Function => self.Function.cmp(&other.Function),
                discriminant_RocType::Num => self.Num.cmp(&other.Num),
                discriminant_RocType::RecursivePointer => {
                    self.RecursivePointer.cmp(&other.RecursivePointer)
                }
                discriminant_RocType::RocBox => self.RocBox.cmp(&other.RocBox),
                discriminant_RocType::RocDict => self.RocDict.cmp(&other.RocDict),
                discriminant_RocType::RocList => self.RocList.cmp(&other.RocList),
                discriminant_RocType::RocResult => self.RocResult.cmp(&other.RocResult),
                discriminant_RocType::RocSet => self.RocSet.cmp(&other.RocSet),
                discriminant_RocType::RocStr => core::cmp::Ordering::Equal,
                discriminant_RocType::Struct => self.Struct.cmp(&other.Struct),
                discriminant_RocType::TagUnion => self.TagUnion.cmp(&other.TagUnion),
                discriminant_RocType::TagUnionPayload => {
                    self.TagUnionPayload.cmp(&other.TagUnionPayload)
                }
                discriminant_RocType::Unit => core::cmp::Ordering::Equal,
                discriminant_RocType::Unsized => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Clone for RocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_RocType::Bool => core::mem::transmute::<
                    core::mem::MaybeUninit<RocType>,
                    RocType,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_RocType::EmptyTagUnion => {
                    core::mem::transmute::<core::mem::MaybeUninit<RocType>, RocType>(
                        core::mem::MaybeUninit::uninit(),
                    )
                }
                discriminant_RocType::Function => Self {
                    Function: self.Function.clone(),
                },
                discriminant_RocType::Num => Self {
                    Num: self.Num.clone(),
                },
                discriminant_RocType::RecursivePointer => Self {
                    RecursivePointer: self.RecursivePointer.clone(),
                },
                discriminant_RocType::RocBox => Self {
                    RocBox: self.RocBox.clone(),
                },
                discriminant_RocType::RocDict => Self {
                    RocDict: self.RocDict.clone(),
                },
                discriminant_RocType::RocList => Self {
                    RocList: self.RocList.clone(),
                },
                discriminant_RocType::RocResult => Self {
                    RocResult: self.RocResult.clone(),
                },
                discriminant_RocType::RocSet => Self {
                    RocSet: self.RocSet.clone(),
                },
                discriminant_RocType::RocStr => core::mem::transmute::<
                    core::mem::MaybeUninit<RocType>,
                    RocType,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_RocType::Struct => Self {
                    Struct: self.Struct.clone(),
                },
                discriminant_RocType::TagUnion => Self {
                    TagUnion: self.TagUnion.clone(),
                },
                discriminant_RocType::TagUnionPayload => Self {
                    TagUnionPayload: self.TagUnionPayload.clone(),
                },
                discriminant_RocType::Unit => core::mem::transmute::<
                    core::mem::MaybeUninit<RocType>,
                    RocType,
                >(core::mem::MaybeUninit::uninit()),
                discriminant_RocType::Unsized => core::mem::transmute::<
                    core::mem::MaybeUninit<RocType>,
                    RocType,
                >(core::mem::MaybeUninit::uninit()),
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for RocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_RocType::Bool => discriminant_RocType::Bool.hash(state),
            discriminant_RocType::EmptyTagUnion => discriminant_RocType::EmptyTagUnion.hash(state),
            discriminant_RocType::Function => unsafe {
                discriminant_RocType::Function.hash(state);
                self.Function.hash(state);
            },
            discriminant_RocType::Num => unsafe {
                discriminant_RocType::Num.hash(state);
                self.Num.hash(state);
            },
            discriminant_RocType::RecursivePointer => unsafe {
                discriminant_RocType::RecursivePointer.hash(state);
                self.RecursivePointer.hash(state);
            },
            discriminant_RocType::RocBox => unsafe {
                discriminant_RocType::RocBox.hash(state);
                self.RocBox.hash(state);
            },
            discriminant_RocType::RocDict => unsafe {
                discriminant_RocType::RocDict.hash(state);
                self.RocDict.hash(state);
            },
            discriminant_RocType::RocList => unsafe {
                discriminant_RocType::RocList.hash(state);
                self.RocList.hash(state);
            },
            discriminant_RocType::RocResult => unsafe {
                discriminant_RocType::RocResult.hash(state);
                self.RocResult.hash(state);
            },
            discriminant_RocType::RocSet => unsafe {
                discriminant_RocType::RocSet.hash(state);
                self.RocSet.hash(state);
            },
            discriminant_RocType::RocStr => discriminant_RocType::RocStr.hash(state),
            discriminant_RocType::Struct => unsafe {
                discriminant_RocType::Struct.hash(state);
                self.Struct.hash(state);
            },
            discriminant_RocType::TagUnion => unsafe {
                discriminant_RocType::TagUnion.hash(state);
                self.TagUnion.hash(state);
            },
            discriminant_RocType::TagUnionPayload => unsafe {
                discriminant_RocType::TagUnionPayload.hash(state);
                self.TagUnionPayload.hash(state);
            },
            discriminant_RocType::Unit => discriminant_RocType::Unit.hash(state),
            discriminant_RocType::Unsized => discriminant_RocType::Unsized.hash(state),
        }
    }
}

impl core::fmt::Debug for RocType {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("RocType::")?;

        unsafe {
            match self.discriminant() {
                discriminant_RocType::Bool => f.write_str("Bool"),
                discriminant_RocType::EmptyTagUnion => f.write_str("EmptyTagUnion"),
                discriminant_RocType::Function => {
                    f.debug_tuple("Function").field(&*self.Function).finish()
                }
                discriminant_RocType::Num => f.debug_tuple("Num").field(&self.Num).finish(),
                discriminant_RocType::RecursivePointer => f
                    .debug_tuple("RecursivePointer")
                    .field(&self.RecursivePointer)
                    .finish(),
                discriminant_RocType::RocBox => {
                    f.debug_tuple("RocBox").field(&self.RocBox).finish()
                }
                discriminant_RocType::RocDict => f
                    .debug_tuple("RocDict")
                    .field(&(&self.RocDict).f0)
                    .field(&(&self.RocDict).f1)
                    .finish(),
                discriminant_RocType::RocList => {
                    f.debug_tuple("RocList").field(&self.RocList).finish()
                }
                discriminant_RocType::RocResult => f
                    .debug_tuple("RocResult")
                    .field(&(&self.RocResult).f0)
                    .field(&(&self.RocResult).f1)
                    .finish(),
                discriminant_RocType::RocSet => {
                    f.debug_tuple("RocSet").field(&self.RocSet).finish()
                }
                discriminant_RocType::RocStr => f.write_str("RocStr"),
                discriminant_RocType::Struct => {
                    f.debug_tuple("Struct").field(&*self.Struct).finish()
                }
                discriminant_RocType::TagUnion => {
                    f.debug_tuple("TagUnion").field(&*self.TagUnion).finish()
                }
                discriminant_RocType::TagUnionPayload => f
                    .debug_tuple("TagUnionPayload")
                    .field(&*self.TagUnionPayload)
                    .finish(),
                discriminant_RocType::Unit => f.write_str("Unit"),
                discriminant_RocType::Unsized => f.write_str("Unsized"),
            }
        }
    }
}

impl Tuple2 {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named T, with the given payload.
    pub fn T(f0: u32, f1: roc_std::RocList<u32>) -> Self {
        Self { f0, f1 }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Since `T` only has one tag (namely, `T`),
    /// convert it to `T`'s payload.
    pub fn into_T(self) -> (u32, roc_std::RocList<u32>) {
        (self.f0, self.f1)
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Since `T` only has one tag (namely, `T`),
    /// convert it to `T`'s payload.
    pub fn as_T(&self) -> (&u32, &roc_std::RocList<u32>) {
        (&self.f0, &self.f1)
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named T, with the given payload.
    pub fn T(f0: u64, f1: roc_std::RocList<u64>) -> Self {
        Self { f0, f1 }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Since `T` only has one tag (namely, `T`),
    /// convert it to `T`'s payload.
    pub fn into_T(self) -> (u64, roc_std::RocList<u64>) {
        (self.f0, self.f1)
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Since `T` only has one tag (namely, `T`),
    /// convert it to `T`'s payload.
    pub fn as_T(&self) -> (&u64, &roc_std::RocList<u64>) {
        (&self.f0, &self.f1)
    }
}

impl core::fmt::Debug for Tuple2 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("Tuple2::T")
            .field(&self.f0)
            .field(&self.f1)
            .finish()
    }
}

impl RocTagUnion {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_RocTagUnion {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_RocTagUnion>(*bytes.as_ptr().add(44))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_RocTagUnion) {
        let discriminant_ptr: *mut discriminant_RocTagUnion = (self as *mut RocTagUnion).cast();

        unsafe {
            *(discriminant_ptr.add(44)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Enumeration`, with the appropriate payload
    pub fn Enumeration(arg0: R5) -> Self {
        let mut answer = Self {
            Enumeration: core::mem::ManuallyDrop::new(arg0),
        };

        answer.set_discriminant(discriminant_RocTagUnion::Enumeration);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `Enumeration` and convert it to `Enumeration`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Enumeration`.
    pub unsafe fn into_Enumeration(mut self) -> R5 {
        debug_assert_eq!(self.discriminant(), discriminant_RocTagUnion::Enumeration);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Enumeration,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `Enumeration` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Enumeration`.
    pub unsafe fn as_Enumeration(&self) -> &R5 {
        debug_assert_eq!(self.discriminant(), discriminant_RocTagUnion::Enumeration);
        let payload = &self.Enumeration;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `NonNullableUnwrapped`, with the appropriate payload
    pub fn NonNullableUnwrapped(arg0: R6) -> Self {
        let mut answer = Self {
            NonNullableUnwrapped: core::mem::ManuallyDrop::new(arg0),
        };

        answer.set_discriminant(discriminant_RocTagUnion::NonNullableUnwrapped);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `NonNullableUnwrapped` and convert it to `NonNullableUnwrapped`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `NonNullableUnwrapped`.
    pub unsafe fn into_NonNullableUnwrapped(mut self) -> R6 {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocTagUnion::NonNullableUnwrapped
        );
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.NonNullableUnwrapped,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `NonNullableUnwrapped` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `NonNullableUnwrapped`.
    pub unsafe fn as_NonNullableUnwrapped(&self) -> &R6 {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocTagUnion::NonNullableUnwrapped
        );
        let payload = &self.NonNullableUnwrapped;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `NonRecursive`, with the appropriate payload
    pub fn NonRecursive(arg0: R7) -> Self {
        let mut answer = Self {
            NonRecursive: core::mem::ManuallyDrop::new(arg0),
        };

        answer.set_discriminant(discriminant_RocTagUnion::NonRecursive);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `NonRecursive` and convert it to `NonRecursive`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `NonRecursive`.
    pub unsafe fn into_NonRecursive(mut self) -> R7 {
        debug_assert_eq!(self.discriminant(), discriminant_RocTagUnion::NonRecursive);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.NonRecursive,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `NonRecursive` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `NonRecursive`.
    pub unsafe fn as_NonRecursive(&self) -> &R7 {
        debug_assert_eq!(self.discriminant(), discriminant_RocTagUnion::NonRecursive);
        let payload = &self.NonRecursive;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `NullableUnwrapped`, with the appropriate payload
    pub fn NullableUnwrapped(arg0: R9) -> Self {
        let mut answer = Self {
            NullableUnwrapped: core::mem::ManuallyDrop::new(arg0),
        };

        answer.set_discriminant(discriminant_RocTagUnion::NullableUnwrapped);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `NullableUnwrapped` and convert it to `NullableUnwrapped`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `NullableUnwrapped`.
    pub unsafe fn into_NullableUnwrapped(mut self) -> R9 {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocTagUnion::NullableUnwrapped
        );
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.NullableUnwrapped,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `NullableUnwrapped` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `NullableUnwrapped`.
    pub unsafe fn as_NullableUnwrapped(&self) -> &R9 {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocTagUnion::NullableUnwrapped
        );
        let payload = &self.NullableUnwrapped;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `NullableWrapped`, with the appropriate payload
    pub fn NullableWrapped(arg0: R10) -> Self {
        let mut answer = Self {
            NullableWrapped: core::mem::ManuallyDrop::new(arg0),
        };

        answer.set_discriminant(discriminant_RocTagUnion::NullableWrapped);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `NullableWrapped` and convert it to `NullableWrapped`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `NullableWrapped`.
    pub unsafe fn into_NullableWrapped(mut self) -> R10 {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocTagUnion::NullableWrapped
        );
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.NullableWrapped,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `NullableWrapped` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `NullableWrapped`.
    pub unsafe fn as_NullableWrapped(&self) -> &R10 {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocTagUnion::NullableWrapped
        );
        let payload = &self.NullableWrapped;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Recursive`, with the appropriate payload
    pub fn Recursive(arg0: R7) -> Self {
        let mut answer = Self {
            Recursive: core::mem::ManuallyDrop::new(arg0),
        };

        answer.set_discriminant(discriminant_RocTagUnion::Recursive);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `Recursive` and convert it to `Recursive`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Recursive`.
    pub unsafe fn into_Recursive(mut self) -> R7 {
        debug_assert_eq!(self.discriminant(), discriminant_RocTagUnion::Recursive);
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.Recursive,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `Recursive` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Recursive`.
    pub unsafe fn as_Recursive(&self) -> &R7 {
        debug_assert_eq!(self.discriminant(), discriminant_RocTagUnion::Recursive);
        let payload = &self.Recursive;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `SingleTagStruct`, with the appropriate payload
    pub fn SingleTagStruct(arg0: R14) -> Self {
        let mut answer = Self {
            SingleTagStruct: core::mem::ManuallyDrop::new(arg0),
        };

        answer.set_discriminant(discriminant_RocTagUnion::SingleTagStruct);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `SingleTagStruct` and convert it to `SingleTagStruct`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `SingleTagStruct`.
    pub unsafe fn into_SingleTagStruct(mut self) -> R14 {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocTagUnion::SingleTagStruct
        );
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.SingleTagStruct,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocTagUnion` has a `.discriminant()` of `SingleTagStruct` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `SingleTagStruct`.
    pub unsafe fn as_SingleTagStruct(&self) -> &R14 {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocTagUnion::SingleTagStruct
        );
        let payload = &self.SingleTagStruct;

        payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_RocTagUnion {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_RocTagUnion>(*bytes.as_ptr().add(88))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_RocTagUnion) {
        let discriminant_ptr: *mut discriminant_RocTagUnion = (self as *mut RocTagUnion).cast();

        unsafe {
            *(discriminant_ptr.add(88)) = discriminant;
        }
    }
}

impl Drop for RocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_RocTagUnion::Enumeration => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.Enumeration)
            },
            discriminant_RocTagUnion::NonNullableUnwrapped => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.NonNullableUnwrapped)
            },
            discriminant_RocTagUnion::NonRecursive => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.NonRecursive)
            },
            discriminant_RocTagUnion::NullableUnwrapped => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.NullableUnwrapped)
            },
            discriminant_RocTagUnion::NullableWrapped => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.NullableWrapped)
            },
            discriminant_RocTagUnion::Recursive => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.Recursive)
            },
            discriminant_RocTagUnion::SingleTagStruct => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.SingleTagStruct)
            },
        }
    }
}

impl Eq for RocTagUnion {}

impl PartialEq for RocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_RocTagUnion::Enumeration => self.Enumeration == other.Enumeration,
                discriminant_RocTagUnion::NonNullableUnwrapped => {
                    self.NonNullableUnwrapped == other.NonNullableUnwrapped
                }
                discriminant_RocTagUnion::NonRecursive => self.NonRecursive == other.NonRecursive,
                discriminant_RocTagUnion::NullableUnwrapped => {
                    self.NullableUnwrapped == other.NullableUnwrapped
                }
                discriminant_RocTagUnion::NullableWrapped => {
                    self.NullableWrapped == other.NullableWrapped
                }
                discriminant_RocTagUnion::Recursive => self.Recursive == other.Recursive,
                discriminant_RocTagUnion::SingleTagStruct => {
                    self.SingleTagStruct == other.SingleTagStruct
                }
            }
        }
    }
}

impl PartialOrd for RocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_RocTagUnion::Enumeration => {
                    self.Enumeration.partial_cmp(&other.Enumeration)
                }
                discriminant_RocTagUnion::NonNullableUnwrapped => self
                    .NonNullableUnwrapped
                    .partial_cmp(&other.NonNullableUnwrapped),
                discriminant_RocTagUnion::NonRecursive => {
                    self.NonRecursive.partial_cmp(&other.NonRecursive)
                }
                discriminant_RocTagUnion::NullableUnwrapped => {
                    self.NullableUnwrapped.partial_cmp(&other.NullableUnwrapped)
                }
                discriminant_RocTagUnion::NullableWrapped => {
                    self.NullableWrapped.partial_cmp(&other.NullableWrapped)
                }
                discriminant_RocTagUnion::Recursive => self.Recursive.partial_cmp(&other.Recursive),
                discriminant_RocTagUnion::SingleTagStruct => {
                    self.SingleTagStruct.partial_cmp(&other.SingleTagStruct)
                }
            }
        }
    }
}

impl Ord for RocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_RocTagUnion::Enumeration => self.Enumeration.cmp(&other.Enumeration),
                discriminant_RocTagUnion::NonNullableUnwrapped => {
                    self.NonNullableUnwrapped.cmp(&other.NonNullableUnwrapped)
                }
                discriminant_RocTagUnion::NonRecursive => {
                    self.NonRecursive.cmp(&other.NonRecursive)
                }
                discriminant_RocTagUnion::NullableUnwrapped => {
                    self.NullableUnwrapped.cmp(&other.NullableUnwrapped)
                }
                discriminant_RocTagUnion::NullableWrapped => {
                    self.NullableWrapped.cmp(&other.NullableWrapped)
                }
                discriminant_RocTagUnion::Recursive => self.Recursive.cmp(&other.Recursive),
                discriminant_RocTagUnion::SingleTagStruct => {
                    self.SingleTagStruct.cmp(&other.SingleTagStruct)
                }
            }
        }
    }
}

impl Clone for RocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_RocTagUnion::Enumeration => Self {
                    Enumeration: self.Enumeration.clone(),
                },
                discriminant_RocTagUnion::NonNullableUnwrapped => Self {
                    NonNullableUnwrapped: self.NonNullableUnwrapped.clone(),
                },
                discriminant_RocTagUnion::NonRecursive => Self {
                    NonRecursive: self.NonRecursive.clone(),
                },
                discriminant_RocTagUnion::NullableUnwrapped => Self {
                    NullableUnwrapped: self.NullableUnwrapped.clone(),
                },
                discriminant_RocTagUnion::NullableWrapped => Self {
                    NullableWrapped: self.NullableWrapped.clone(),
                },
                discriminant_RocTagUnion::Recursive => Self {
                    Recursive: self.Recursive.clone(),
                },
                discriminant_RocTagUnion::SingleTagStruct => Self {
                    SingleTagStruct: self.SingleTagStruct.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for RocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_RocTagUnion::Enumeration => unsafe {
                discriminant_RocTagUnion::Enumeration.hash(state);
                self.Enumeration.hash(state);
            },
            discriminant_RocTagUnion::NonNullableUnwrapped => unsafe {
                discriminant_RocTagUnion::NonNullableUnwrapped.hash(state);
                self.NonNullableUnwrapped.hash(state);
            },
            discriminant_RocTagUnion::NonRecursive => unsafe {
                discriminant_RocTagUnion::NonRecursive.hash(state);
                self.NonRecursive.hash(state);
            },
            discriminant_RocTagUnion::NullableUnwrapped => unsafe {
                discriminant_RocTagUnion::NullableUnwrapped.hash(state);
                self.NullableUnwrapped.hash(state);
            },
            discriminant_RocTagUnion::NullableWrapped => unsafe {
                discriminant_RocTagUnion::NullableWrapped.hash(state);
                self.NullableWrapped.hash(state);
            },
            discriminant_RocTagUnion::Recursive => unsafe {
                discriminant_RocTagUnion::Recursive.hash(state);
                self.Recursive.hash(state);
            },
            discriminant_RocTagUnion::SingleTagStruct => unsafe {
                discriminant_RocTagUnion::SingleTagStruct.hash(state);
                self.SingleTagStruct.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for RocTagUnion {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("RocTagUnion::")?;

        unsafe {
            match self.discriminant() {
                discriminant_RocTagUnion::Enumeration => f
                    .debug_tuple("Enumeration")
                    .field(&*self.Enumeration)
                    .finish(),
                discriminant_RocTagUnion::NonNullableUnwrapped => f
                    .debug_tuple("NonNullableUnwrapped")
                    .field(&*self.NonNullableUnwrapped)
                    .finish(),
                discriminant_RocTagUnion::NonRecursive => f
                    .debug_tuple("NonRecursive")
                    .field(&*self.NonRecursive)
                    .finish(),
                discriminant_RocTagUnion::NullableUnwrapped => f
                    .debug_tuple("NullableUnwrapped")
                    .field(&*self.NullableUnwrapped)
                    .finish(),
                discriminant_RocTagUnion::NullableWrapped => f
                    .debug_tuple("NullableWrapped")
                    .field(&*self.NullableWrapped)
                    .finish(),
                discriminant_RocTagUnion::Recursive => {
                    f.debug_tuple("Recursive").field(&*self.Recursive).finish()
                }
                discriminant_RocTagUnion::SingleTagStruct => f
                    .debug_tuple("SingleTagStruct")
                    .field(&*self.SingleTagStruct)
                    .finish(),
            }
        }
    }
}

impl RocSingleTagPayload {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_RocSingleTagPayload {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_RocSingleTagPayload>(*bytes.as_ptr().add(12))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_RocSingleTagPayload) {
        let discriminant_ptr: *mut discriminant_RocSingleTagPayload =
            (self as *mut RocSingleTagPayload).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `HasClosure`, with the appropriate payload
    pub fn HasClosure(arg: roc_std::RocList<R4>) -> Self {
        let mut answer = Self {
            HasClosure: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_RocSingleTagPayload::HasClosure);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocSingleTagPayload` has a `.discriminant()` of `HasClosure` and convert it to `HasClosure`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `HasClosure`.
    pub unsafe fn into_HasClosure(mut self) -> roc_std::RocList<R4> {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocSingleTagPayload::HasClosure
        );
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.HasClosure,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocSingleTagPayload` has a `.discriminant()` of `HasClosure` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `HasClosure`.
    pub unsafe fn as_HasClosure(&self) -> &roc_std::RocList<R4> {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocSingleTagPayload::HasClosure
        );
        let payload = &self.HasClosure;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `HasNoClosure`, with the appropriate payload
    pub fn HasNoClosure(arg: roc_std::RocList<R16>) -> Self {
        let mut answer = Self {
            HasNoClosure: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_RocSingleTagPayload::HasNoClosure);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocSingleTagPayload` has a `.discriminant()` of `HasNoClosure` and convert it to `HasNoClosure`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `HasNoClosure`.
    pub unsafe fn into_HasNoClosure(mut self) -> roc_std::RocList<R16> {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocSingleTagPayload::HasNoClosure
        );
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.HasNoClosure,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocSingleTagPayload` has a `.discriminant()` of `HasNoClosure` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `HasNoClosure`.
    pub unsafe fn as_HasNoClosure(&self) -> &roc_std::RocList<R16> {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocSingleTagPayload::HasNoClosure
        );
        let payload = &self.HasNoClosure;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_RocSingleTagPayload {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_RocSingleTagPayload>(*bytes.as_ptr().add(24))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_RocSingleTagPayload) {
        let discriminant_ptr: *mut discriminant_RocSingleTagPayload =
            (self as *mut RocSingleTagPayload).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }
}

impl Drop for RocSingleTagPayload {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_RocSingleTagPayload::HasClosure => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.HasClosure)
            },
            discriminant_RocSingleTagPayload::HasNoClosure => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.HasNoClosure)
            },
        }
    }
}

impl Eq for RocSingleTagPayload {}

impl PartialEq for RocSingleTagPayload {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_RocSingleTagPayload::HasClosure => self.HasClosure == other.HasClosure,
                discriminant_RocSingleTagPayload::HasNoClosure => {
                    self.HasNoClosure == other.HasNoClosure
                }
            }
        }
    }
}

impl PartialOrd for RocSingleTagPayload {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_RocSingleTagPayload::HasClosure => {
                    self.HasClosure.partial_cmp(&other.HasClosure)
                }
                discriminant_RocSingleTagPayload::HasNoClosure => {
                    self.HasNoClosure.partial_cmp(&other.HasNoClosure)
                }
            }
        }
    }
}

impl Ord for RocSingleTagPayload {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_RocSingleTagPayload::HasClosure => {
                    self.HasClosure.cmp(&other.HasClosure)
                }
                discriminant_RocSingleTagPayload::HasNoClosure => {
                    self.HasNoClosure.cmp(&other.HasNoClosure)
                }
            }
        }
    }
}

impl Clone for RocSingleTagPayload {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_RocSingleTagPayload::HasClosure => Self {
                    HasClosure: self.HasClosure.clone(),
                },
                discriminant_RocSingleTagPayload::HasNoClosure => Self {
                    HasNoClosure: self.HasNoClosure.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for RocSingleTagPayload {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_RocSingleTagPayload::HasClosure => unsafe {
                discriminant_RocSingleTagPayload::HasClosure.hash(state);
                self.HasClosure.hash(state);
            },
            discriminant_RocSingleTagPayload::HasNoClosure => unsafe {
                discriminant_RocSingleTagPayload::HasNoClosure.hash(state);
                self.HasNoClosure.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for RocSingleTagPayload {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("RocSingleTagPayload::")?;

        unsafe {
            match self.discriminant() {
                discriminant_RocSingleTagPayload::HasClosure => f
                    .debug_tuple("HasClosure")
                    .field(&*self.HasClosure)
                    .finish(),
                discriminant_RocSingleTagPayload::HasNoClosure => f
                    .debug_tuple("HasNoClosure")
                    .field(&*self.HasNoClosure)
                    .finish(),
            }
        }
    }
}

impl U1 {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U1 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U1>(*bytes.as_ptr().add(4))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U1) {
        let discriminant_ptr: *mut discriminant_U1 = (self as *mut U1).cast();

        unsafe {
            *(discriminant_ptr.add(4)) = discriminant;
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<U1>()];

        bytes[4] = discriminant_U1::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<U1>()], U1>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_None(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the None tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn as_None(&self) {
        ()
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Construct a tag named `Some`, with the appropriate payload
    pub fn Some(arg: u32) -> Self {
        let mut answer = Self { Some: arg };

        answer.set_discriminant(discriminant_U1::Some);

        answer
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `U1` has a `.discriminant()` of `Some` and convert it to `Some`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
    pub unsafe fn into_Some(self) -> u32 {
        debug_assert_eq!(self.discriminant(), discriminant_U1::Some);
        let payload = self.Some;

        payload
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Unsafely assume the given `U1` has a `.discriminant()` of `Some` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
    pub unsafe fn as_Some(&self) -> &u32 {
        debug_assert_eq!(self.discriminant(), discriminant_U1::Some);
        let payload = &self.Some;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U1 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U1>(*bytes.as_ptr().add(8))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U1) {
        let discriminant_ptr: *mut discriminant_U1 = (self as *mut U1).cast();

        unsafe {
            *(discriminant_ptr.add(8)) = discriminant;
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named None, which has no payload.
    pub const None: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<U1>()];

        bytes[8] = discriminant_U1::None as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<U1>()], U1>(bytes)
    };

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Construct a tag named `Some`, with the appropriate payload
    pub fn Some(arg: u64) -> Self {
        let mut answer = Self { Some: arg };

        answer.set_discriminant(discriminant_U1::Some);

        answer
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `U1` has a `.discriminant()` of `Some` and convert it to `Some`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
    pub unsafe fn into_Some(self) -> u64 {
        debug_assert_eq!(self.discriminant(), discriminant_U1::Some);
        let payload = self.Some;

        payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Unsafely assume the given `U1` has a `.discriminant()` of `Some` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Some`.
    pub unsafe fn as_Some(&self) -> &u64 {
        debug_assert_eq!(self.discriminant(), discriminant_U1::Some);
        let payload = &self.Some;

        &payload
    }
}

impl Eq for U1 {}

impl PartialEq for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_U1::None => true,
                discriminant_U1::Some => self.Some == other.Some,
            }
        }
    }
}

impl PartialOrd for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U1::None => Some(core::cmp::Ordering::Equal),
                discriminant_U1::Some => self.Some.partial_cmp(&other.Some),
            }
        }
    }
}

impl Ord for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U1::None => core::cmp::Ordering::Equal,
                discriminant_U1::Some => self.Some.cmp(&other.Some),
            }
        }
    }
}

impl Copy for U1 {}

impl Clone for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        *self
    }
}

impl core::hash::Hash for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_U1::None => discriminant_U1::None.hash(state),
            discriminant_U1::Some => unsafe {
                discriminant_U1::Some.hash(state);
                self.Some.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U1::")?;

        unsafe {
            match self.discriminant() {
                discriminant_U1::None => f.write_str("None"),
                discriminant_U1::Some => f.debug_tuple("Some").field(&self.Some).finish(),
            }
        }
    }
}

impl RocStructFields {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_RocStructFields {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_RocStructFields>(*bytes.as_ptr().add(12))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_RocStructFields) {
        let discriminant_ptr: *mut discriminant_RocStructFields =
            (self as *mut RocStructFields).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `HasClosure`, with the appropriate payload
    pub fn HasClosure(arg: roc_std::RocList<R2>) -> Self {
        let mut answer = Self {
            HasClosure: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_RocStructFields::HasClosure);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocStructFields` has a `.discriminant()` of `HasClosure` and convert it to `HasClosure`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `HasClosure`.
    pub unsafe fn into_HasClosure(mut self) -> roc_std::RocList<R2> {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocStructFields::HasClosure
        );
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.HasClosure,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocStructFields` has a `.discriminant()` of `HasClosure` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `HasClosure`.
    pub unsafe fn as_HasClosure(&self) -> &roc_std::RocList<R2> {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocStructFields::HasClosure
        );
        let payload = &self.HasClosure;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `HasNoClosure`, with the appropriate payload
    pub fn HasNoClosure(arg: roc_std::RocList<R4>) -> Self {
        let mut answer = Self {
            HasNoClosure: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_RocStructFields::HasNoClosure);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocStructFields` has a `.discriminant()` of `HasNoClosure` and convert it to `HasNoClosure`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `HasNoClosure`.
    pub unsafe fn into_HasNoClosure(mut self) -> roc_std::RocList<R4> {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocStructFields::HasNoClosure
        );
        let payload = {
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut self.HasNoClosure,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `RocStructFields` has a `.discriminant()` of `HasNoClosure` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `HasNoClosure`.
    pub unsafe fn as_HasNoClosure(&self) -> &roc_std::RocList<R4> {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_RocStructFields::HasNoClosure
        );
        let payload = &self.HasNoClosure;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_RocStructFields {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_RocStructFields>(*bytes.as_ptr().add(24))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_RocStructFields) {
        let discriminant_ptr: *mut discriminant_RocStructFields =
            (self as *mut RocStructFields).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }
}

impl Drop for RocStructFields {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_RocStructFields::HasClosure => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.HasClosure)
            },
            discriminant_RocStructFields::HasNoClosure => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.HasNoClosure)
            },
        }
    }
}

impl Eq for RocStructFields {}

impl PartialEq for RocStructFields {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_RocStructFields::HasClosure => self.HasClosure == other.HasClosure,
                discriminant_RocStructFields::HasNoClosure => {
                    self.HasNoClosure == other.HasNoClosure
                }
            }
        }
    }
}

impl PartialOrd for RocStructFields {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_RocStructFields::HasClosure => {
                    self.HasClosure.partial_cmp(&other.HasClosure)
                }
                discriminant_RocStructFields::HasNoClosure => {
                    self.HasNoClosure.partial_cmp(&other.HasNoClosure)
                }
            }
        }
    }
}

impl Ord for RocStructFields {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_RocStructFields::HasClosure => self.HasClosure.cmp(&other.HasClosure),
                discriminant_RocStructFields::HasNoClosure => {
                    self.HasNoClosure.cmp(&other.HasNoClosure)
                }
            }
        }
    }
}

impl Clone for RocStructFields {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_RocStructFields::HasClosure => Self {
                    HasClosure: self.HasClosure.clone(),
                },
                discriminant_RocStructFields::HasNoClosure => Self {
                    HasNoClosure: self.HasNoClosure.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for RocStructFields {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_RocStructFields::HasClosure => unsafe {
                discriminant_RocStructFields::HasClosure.hash(state);
                self.HasClosure.hash(state);
            },
            discriminant_RocStructFields::HasNoClosure => unsafe {
                discriminant_RocStructFields::HasNoClosure.hash(state);
                self.HasNoClosure.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for RocStructFields {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("RocStructFields::")?;

        unsafe {
            match self.discriminant() {
                discriminant_RocStructFields::HasClosure => f
                    .debug_tuple("HasClosure")
                    .field(&*self.HasClosure)
                    .finish(),
                discriminant_RocStructFields::HasNoClosure => f
                    .debug_tuple("HasNoClosure")
                    .field(&*self.HasNoClosure)
                    .finish(),
            }
        }
    }
}
