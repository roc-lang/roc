//! Lists that make it easier to avoid incorrect indexing.

const std = @import("std");
const utils = @import("utils.zig");
const padded_ptr = @import("padded_ptr.zig");
const math = std.math;

const testing = std.testing;
const Allocator = std.mem.Allocator;
const exitOnOom = utils.exitOnOom;
const PaddedPtr = padded_ptr.PaddedPtr;

// Parts of this implementation are adapted from the Zig standard library under the MIT License.
// Thanks, Zig authors!

/// Represents a type safe range in a list; [start, end)
///
/// This is the conceptual equivalent of slice, but since this is based
/// on indexes in the list rather than pointers, it is reliable across
/// (de)serilaization and reallocation of the list.
///
/// This range is inclusive on the lower bound, exclusive on the upper bound.
pub fn SafeRange(comptime Idx: type) type {
    return struct {
        start: Idx,
        end: Idx,
    };
}

/// Wraps a `std.ArrayList` to provide a list that's safer to access
/// with arbitrary indices.
///
/// Use this for values that aren't structs with more than one field.
/// Those values would likely be better stored in a SafeMultiList.
///
/// By default, lists and arrays in Zig are accessed with a `usize`
/// index, which allows for any index to be used with any list. This
/// requires devs to be careful about using indices on the right list
/// and to not look for out-of-bounds values.
///
/// Using a SafeList fixes this as it can only be accessed with a
/// SafeList(T).Idx, which is only created on appending to a SafeList
/// (barring manual usage of macros). An Idx can only be used for lists
/// that hold T's, giving type safety. Also, out-of-bounds errors are
/// less likely since indices are only created for valid list entries.
pub fn SafeList(comptime T: type, comptime Len: type) type {
    return struct {
        ptr: PaddedPtr(T),
        length: Len,
        capacity: Len,

        /// An index for an item in the list.
        pub const Idx = enum(Len) { _ };

        /// A non-type-safe slice of the list.
        pub const Slice = std.ArrayListUnmanaged(T).Slice;

        /// A type-safe range of the list.
        pub const Range = SafeRange(Idx);

        /// A type-safe range which must have at least one element.
        pub const NonEmptyRange = struct {
            range: Range,
        };

        /// Intialize the `SafeList` with the specified capacity.
        pub fn initCapacity(gpa: Allocator, capacity: Len) SafeList(T) {
            return .{
                .items = std.ArrayListUnmanaged(T).initCapacity(gpa, capacity) catch |err| exitOnOom(err),
            };
        }

        /// Deinitialize the memory of this `SafeList`.
        pub fn deinit(self: *SafeList(T), gpa: Allocator) void {
            self.items.deinit(gpa);
        }

        /// Get the length of this list.
        pub fn len(self: *const SafeList(T)) Len {
            return self.items.items.len;
        }

        /// Add an item to the end of this list.
        pub fn append(self: *SafeList(T), gpa: Allocator, item: T) Idx {
            const length = self.len();
            self.items.append(gpa, item) catch |err| exitOnOom(err);

            return @enumFromInt(@as(Len, @intCast(length)));
        }

        /// Add all the items in a slice to the end of this list.
        pub fn appendSlice(self: *SafeList(T), gpa: Allocator, items: []const T) Range {
            const start_length = self.len();
            self.items.appendSlice(gpa, items) catch |err| exitOnOom(err);
            const end_length = self.len();
            return Range{ .start = @enumFromInt(start_length), .end = @enumFromInt(end_length) };
        }

        /// Extend this list with all items generated by an iterator.
        pub fn extendFromIter(self: *SafeList(T), gpa: Allocator, iter: anytype) Range {
            const start_length = self.len();
            while (iter.next()) |item| {
                self.items.append(gpa, item) catch |err| exitOnOom(err);
            }
            const end_length = self.len();
            return Range{ .start = @enumFromInt(start_length), .end = @enumFromInt(end_length) };
        }

        /// Convert a range to a slice
        pub fn rangeToSlice(self: *const SafeList(T), range: Range) Slice {
            const start: usize = @intFromEnum(range.start);
            const end: usize = @intFromEnum(range.end);

            std.debug.assert(start <= end);
            std.debug.assert(end <= self.items.items.len);

            return self.items.items[@intFromEnum(range.start)..@intFromEnum(range.end)];
        }

        /// Get an item from this list without worrying about out-of-bounds errors.
        pub fn get(self: *const SafeList(T), id: Idx) *T {
            return &self.items.items[@as(usize, @intFromEnum(id))];
        }

        /// Set the value of an item in this list without worrying about out-of-bounds errors.
        pub fn set(self: *const SafeList(T), id: Idx, value: T) void {
            self.items.items[@as(usize, @intFromEnum(id))] = value;
        }

        /// An iterator over all the indices in this list.
        pub const IndexIterator = struct {
            len: usize,
            current: usize,

            pub fn next(iter: *IndexIterator) ?Idx {
                if (iter.len == iter.current) {
                    return null;
                }

                const curr = iter.current;
                iter.current += 1;

                const idx: Len = @truncate(curr);
                return @enumFromInt(idx);
            }
        };

        /// Iterate over all the indices of the items in this list.
        pub fn iterIndices(self: *const SafeList(T)) IndexIterator {
            return IndexIterator{
                .len = self.len(),
                .current = 0,
            };
        }

        /// If the current capacity is less than `new_capacity`, this function will
        /// modify the list so that it can hold at least `new_capacity` items.
        /// Invalidates element pointers if additional memory is needed.
        pub fn ensureTotalCapacity(self: *SafeList(T), alloc: Allocator, new_capacity: Len) !void {
            if (@sizeOf(T) == 0) {
                self.capacity = math.maxInt(Len);
                return;
            }

            if (self.capacity >= new_capacity) return;

            const better_capacity = ArrayListAlignedUnmanaged(T, alignment).growCapacity(self.capacity, new_capacity);
            return self.ensureTotalCapacityPrecise(better_capacity);
        }

        /// Called internally when capacity gets exceeded.
        fn expand(self: *SafeList(T), alloc: Allocator) !void {
            // Expand by 1.5x, or if previous capacity was 0, expand to 8 by default.
            try self.ensureTotalCapacity(alloc, @max(8, (self.capacity * 3) / 2));
        }

        /// Serialize into pointers (most likely both being into the same memory-mapped file).
        /// If heap_dest doesn't have the necessary alignment, writes zeros.
        pub fn serialize(self: *const SafeList(T), stack_dest: *[]u8, heap_dest: *[]u8) void {
            // TODO debug assert that stack_dest has the correct alignment
            const zeroed = .{
                .ptr = null,
                .length = self.length,
                .capacity = self.length, // We serialize these as exact-fit.
            };

            const padding = null; // TODO make a slice for the alignment padding

            @memcpy(stack_dest, &zeroed);
            @memset(padding, 0); // TODO can presumably make branchless + use simd
            @memcpy(heap_dest, self.asSlice());

            // TODO advance stack_dest base on self's size
            // TODO advance heap_dest based on (padding + elem bytes written)
        }

        pub fn rehydrateFrom(self: *SafeList(T), heap_src: *[]u8) void {
            // TODO advance heap_src until it's aligned to T

            self.ptr = PaddedPtr.init(heap_src);

            // TODO advance heap_src based on how many bytes we just took.
        }

        pub fn cachedHeapBytes(self: *const SafeList(T)) usize {
            // When we serialize, we only write len bytes, not capacity bytes.
            return self.length * @sizeOf(T); // TODO round off to 16B alignment always.
        }
    };
}

/// Wraps a `std.ArrayMultiList` to provide a list that's safer to access
/// with arbitrary indices.
///
/// Use this for lists comprising structs with differently-sized fields
/// to make the storage of those fields more compact, otherwise a
/// SafeList may be a simpler container.
///
/// By default, lists and arrays in Zig are accessed with a `usize`
/// index, which allows for any index to be used with any list. This
/// requires devs to be careful about using indices on the right list
/// and to not look for out-of-bounds values.
///
/// Using a SafeMultiList fixes this as it can only be accessed with a
/// SafeMultiList(T).Idx, which is only created on appending to a SafeMultiList
/// (barring manual usage of macros). An Idx can only be used for lists
/// that hold T's, giving type safety. Also, out-of-bounds errors are
/// less likely since indices are only created for valid list entries.
pub fn SafeMultiList(comptime T: type, comptime Len: type) type {
    return struct {
        items: std.MultiArrayList(T) = .{},

        /// Index of an item in the list.
        pub const Idx = enum(Len) { zero = 0, _ };

        /// A non-type-safe slice of the list.
        pub const Slice = std.MultiArrayList(T).Slice;

        /// A type-safe slice of the list.
        pub const Range = SafeRange(Idx);

        /// One of the comptime fields in the list's wrapped type.
        pub const Field = std.MultiArrayList(T).Field;

        /// A slice of all values for a specific field of the wrapped type.
        pub fn field(self: *const SafeMultiList(T), comptime field_name: Field) []type {
            return self.items.items(field_name);
        }

        /// The value for a specific field at a specific index in the list.
        pub fn fieldItem(self: *const SafeMultiList(T), comptime field_name: Field, idx: Idx) type {
            return self.items.items(field_name)[@as(usize, @intFromEnum(idx))];
        }

        /// Initialize the `SafeMultiList` with the specified capacity.
        pub fn initCapacity(gpa: Allocator, capacity: usize) SafeMultiList(T) {
            var items = std.MultiArrayList(T){};
            items.ensureTotalCapacity(gpa, capacity) catch |err| exitOnOom(err);
            return .{
                .items = items,
            };
        }

        /// Deinitialize the memory of a `SafeMultiList`.
        pub fn deinit(self: *SafeMultiList(T), gpa: Allocator) void {
            self.items.deinit(gpa);
        }

        /// Get the length of this list.
        pub fn len(self: *const SafeMultiList(T)) usize {
            return self.items.len;
        }

        /// Add a new item to the end of this list.
        pub fn append(self: *SafeMultiList(T), gpa: Allocator, item: T) Idx {
            const length = self.len();
            self.items.append(gpa, item) catch |err| exitOnOom(err);

            return @enumFromInt(@as(Len, @intCast(length)));
        }

        pub fn appendSlice(self: *SafeMultiList(T), gpa: Allocator, elems: []const T) Range {
            if (elems.len == 0) {
                return .{ .start = .zero, .end = .zero };
            }
            const start_length = self.len();
            self.items.ensureUnusedCapacity(gpa, elems.len) catch |err| exitOnOom(err);
            for (elems) |elem| {
                self.items.appendAssumeCapacity(elem);
            }
            const end_length = self.len();
            return Range{ .start = @enumFromInt(start_length), .end = @enumFromInt(end_length) };
        }

        /// Convert a range to a slice
        pub fn rangeToSlice(self: *const SafeMultiList(T), range: Range) Slice {
            const start: usize = @intFromEnum(range.start);
            const end: usize = @intFromEnum(range.end);

            std.debug.assert(start <= end);
            std.debug.assert(end <= self.items.len);

            const base = self.items.slice();

            var new_ptrs: [base.ptrs.len][*]u8 = undefined;

            // This has to be inline, so `cur_field` can be known at comptime
            inline for (0..base.ptrs.len) |i| {
                const cur_field = @as(Field, @enumFromInt(i));
                const cur_items = base.items(cur_field);
                new_ptrs[i] = if (cur_items.len == 0)
                    undefined
                else
                    @ptrCast(&cur_items[start]);
            }

            return .{
                .ptrs = new_ptrs,
                .len = end - start,
                .capacity = base.capacity - start,
            };
        }

        /// Set the value of an element in this list.
        pub fn set(self: *SafeMultiList(T), idx: Idx, value: T) void {
            self.items.set(@intFromEnum(idx), value);
        }

        // TODO: consider removing this, or at least renaming to imply this is not a zero-cost operation
        pub fn get(self: *const SafeMultiList(T), idx: Idx) T {
            return self.items.get(@intFromEnum(idx));
        }

        /// Make sure that the backing array has at least capacity for the specified number of elements.
        pub fn ensureTotalCapacity(self: *SafeMultiList(T), gpa: Allocator, capacity: usize) void {
            self.items.ensureTotalCapacity(gpa, capacity) catch |err| exitOnOom(err);
        }

        /// An iterator over the indices of all elements in a list.
        pub const IndexIterator = struct {
            len: usize,
            current: usize,

            /// Get the next index from this iterator, or `null` if the iterator is finished.
            pub fn next(iter: *IndexIterator) ?Idx {
                if (iter.len == iter.current) {
                    return null;
                }

                const curr = iter.current;
                iter.current += 1;

                const idx: Len = @truncate(curr);
                return @enumFromInt(idx);
            }
        };

        /// Iterator over all indices in this list.
        pub fn iterIndices(self: *const SafeMultiList(T)) IndexIterator {
            return IndexIterator{
                .len = self.len(),
                .current = 0,
            };
        }
    };
}

test "SafeList(32) inserting and getting" {
    const gpa = testing.allocator;

    var list_u32 = SafeList(u32){};
    defer list_u32.deinit(gpa);

    try testing.expectEqual(list_u32.len(), 0);

    const id = list_u32.append(gpa, 1);

    try testing.expectEqual(list_u32.len(), 1);

    const item = list_u32.get(id);

    try testing.expectEqual(item.*, 1);
}

test "SafeList(u8) appendSlice" {
    const gpa = testing.allocator;

    var list = SafeList(u8){};
    defer list.deinit(gpa);

    const rangeA = list.appendSlice(gpa, &[_]u8{ 'a', 'b', 'c', 'd' });
    try testing.expectEqual(0, @intFromEnum(rangeA.start));
    try testing.expectEqual(4, @intFromEnum(rangeA.end));

    const rangeB = list.appendSlice(gpa, &[_]u8{ 'd', 'e', 'f', 'g' });
    try testing.expectEqual(4, @intFromEnum(rangeB.start));
    try testing.expectEqual(8, @intFromEnum(rangeB.end));
}

test "SafeList(u8) rangeToSlice" {
    const gpa = testing.allocator;

    var list = SafeList(u8){};
    defer list.deinit(gpa);

    const rangeA = list.appendSlice(gpa, &[_]u8{ 'a', 'b', 'c', 'd' });
    const sliceA = list.rangeToSlice(rangeA);
    try testing.expectEqual('a', sliceA[0]);
    try testing.expectEqual('d', sliceA[3]);

    const rangeB = SafeList(u8).Range{ .start = @enumFromInt(2), .end = @enumFromInt(4) };
    const sliceB = list.rangeToSlice(rangeB);
    try testing.expectEqual('c', sliceB[0]);
    try testing.expectEqual('d', sliceB[1]);
}

test "SafeMultiList(u8) appendSlice" {
    const gpa = testing.allocator;

    const Struct = struct { num: u32, char: u8 };
    const StructMultiList = SafeMultiList(Struct);

    var multilist = StructMultiList.initCapacity(gpa, 3);
    defer multilist.deinit(gpa);

    const rangeA = multilist.appendSlice(gpa, &[_]Struct{ .{ .num = 100, .char = 'a' }, .{ .num = 200, .char = 'b' }, .{ .num = 300, .char = 'd' } });
    try testing.expectEqual(0, @intFromEnum(rangeA.start));
    try testing.expectEqual(3, @intFromEnum(rangeA.end));

    const rangeB = multilist.appendSlice(gpa, &[_]Struct{ .{ .num = 400, .char = 'd' }, .{ .num = 500, .char = 'e' }, .{ .num = 600, .char = 'f' } });
    try testing.expectEqual(3, @intFromEnum(rangeB.start));
    try testing.expectEqual(6, @intFromEnum(rangeB.end));
}

test "SafeMultiList(u8) rangeToSlice" {
    const gpa = testing.allocator;

    const Struct = struct { num: u32, char: u8 };
    const StructMultiList = SafeMultiList(Struct);

    var multilist = StructMultiList.initCapacity(gpa, 3);
    defer multilist.deinit(gpa);

    const range_a = multilist.appendSlice(gpa, &[_]Struct{ .{ .num = 100, .char = 'a' }, .{ .num = 200, .char = 'b' }, .{ .num = 300, .char = 'c' } });
    const slice_a = multilist.rangeToSlice(range_a);

    const num_slice_a = slice_a.items(.num);
    try testing.expectEqual(3, num_slice_a.len);
    try testing.expectEqual(100, num_slice_a[0]);
    try testing.expectEqual(200, num_slice_a[1]);
    try testing.expectEqual(300, num_slice_a[2]);

    const char_slice_a = slice_a.items(.char);
    try testing.expectEqual(3, char_slice_a.len);
    try testing.expectEqual('a', char_slice_a[0]);
    try testing.expectEqual('b', char_slice_a[1]);
    try testing.expectEqual('c', char_slice_a[2]);

    const range_b = StructMultiList.Range{ .start = @enumFromInt(1), .end = @enumFromInt(2) };
    const slice_b = multilist.rangeToSlice(range_b);

    const num_slice_b = slice_b.items(.num);
    try testing.expectEqual(1, num_slice_b.len);
    try testing.expectEqual(200, num_slice_b[0]);

    const char_slice_b = slice_b.items(.char);
    try testing.expectEqual(1, char_slice_b.len);
    try testing.expectEqual('b', char_slice_b[0]);
}
