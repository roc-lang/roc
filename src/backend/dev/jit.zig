//! JIT (Just-In-Time) execution infrastructure for the dev backend.
//!
//! This module provides the ability to execute generated machine code at runtime.
//! It allocates executable memory, copies generated code into it, and provides
//! a way to call the code as a function.
//!
//! The typical workflow is:
//! 1. Generate machine code using the CodeGen module
//! 2. Create a JitCode instance with the generated bytes
//! 3. Call the code as a function
//! 4. Clean up when done

const std = @import("std");
const builtin = @import("builtin");

/// Executable memory region containing JIT-compiled code.
/// The code can be called as a function using the `call*` methods.
pub const JitCode = struct {
    /// The executable memory region
    memory: []align(std.heap.page_size_min) u8,
    /// Size of the actual code (may be less than memory.len)
    code_size: usize,

    const Self = @This();

    /// Allocate executable memory and copy the given code into it.
    /// The memory will be marked as executable (but not writable after copy).
    pub fn init(code: []const u8) !Self {
        if (code.len == 0) {
            return error.EmptyCode;
        }

        // Round up to page size
        const page_size = std.heap.page_size_min;
        const alloc_size = std.mem.alignForward(usize, code.len, page_size);

        // Allocate memory with read-write permissions initially
        const memory = try allocateExecutableMemory(alloc_size);
        errdefer freeExecutableMemory(memory);

        // Copy the code
        @memcpy(memory[0..code.len], code);

        // Make the memory executable (and read-only on some platforms)
        try makeExecutable(memory);

        return Self{
            .memory = memory,
            .code_size = code.len,
        };
    }

    /// Free the executable memory
    pub fn deinit(self: *Self) void {
        freeExecutableMemory(self.memory);
        self.memory = &.{};
        self.code_size = 0;
    }

    /// Get a pointer to the start of the code
    pub fn codePtr(self: *const Self) [*]const u8 {
        return self.memory.ptr;
    }

    /// Call the code as a function that takes no arguments and returns i64
    pub fn callReturnI64(self: *const Self) i64 {
        const func: *const fn () callconv(.c) i64 = @ptrCast(self.memory.ptr);
        return func();
    }

    /// Call the code as a function that takes no arguments and returns u64
    pub fn callReturnU64(self: *const Self) u64 {
        const func: *const fn () callconv(.c) u64 = @ptrCast(self.memory.ptr);
        return func();
    }

    /// Call the code as a function that takes no arguments and returns f64
    pub fn callReturnF64(self: *const Self) f64 {
        const func: *const fn () callconv(.c) f64 = @ptrCast(self.memory.ptr);
        return func();
    }

    /// Call the code as a function that takes a result pointer and returns void.
    /// This is the Roc calling convention for functions that return values.
    pub fn callWithResultPtr(self: *const Self, result_ptr: *anyopaque) void {
        const func: *const fn (*anyopaque) callconv(.c) void = @ptrCast(self.memory.ptr);
        func(result_ptr);
    }
};

/// Allocate memory that can be made executable
fn allocateExecutableMemory(size: usize) ![]align(std.heap.page_size_min) u8 {
    switch (builtin.os.tag) {
        .macos, .ios, .tvos, .watchos, .linux, .freebsd, .openbsd, .netbsd => {
            // Use mmap for POSIX systems
            const prot = std.posix.PROT.READ | std.posix.PROT.WRITE;
            const flags = std.posix.MAP{ .TYPE = .PRIVATE, .ANONYMOUS = true };
            const result = std.posix.mmap(null, size, prot, flags, -1, 0) catch {
                return error.MmapFailed;
            };
            return @alignCast(result[0..size]);
        },
        .windows => {
            // On Windows, use VirtualAlloc
            const mem = std.os.windows.VirtualAlloc(
                null,
                size,
                std.os.windows.MEM_COMMIT | std.os.windows.MEM_RESERVE,
                std.os.windows.PAGE_READWRITE,
            ) catch return error.VirtualAllocFailed;
            const ptr: [*]align(std.heap.page_size_min) u8 = @ptrCast(@alignCast(mem));
            return ptr[0..size];
        },
        else => return error.UnsupportedPlatform,
    }
}

/// Make the memory executable
fn makeExecutable(memory: []align(std.heap.page_size_min) u8) !void {
    switch (builtin.os.tag) {
        .macos, .ios, .tvos, .watchos, .linux, .freebsd, .openbsd, .netbsd => {
            // Change protection to read-execute
            const prot = std.posix.PROT.READ | std.posix.PROT.EXEC;
            std.posix.mprotect(memory, prot) catch return error.MprotectFailed;
        },
        .windows => {
            // On Windows, change protection to execute-read
            var old_protect: std.os.windows.DWORD = undefined;
            std.os.windows.VirtualProtect(
                memory.ptr,
                memory.len,
                std.os.windows.PAGE_EXECUTE_READ,
                &old_protect,
            ) catch return error.VirtualProtectFailed;
        },
        else => return error.UnsupportedPlatform,
    }
}

/// Free executable memory
fn freeExecutableMemory(memory: []align(std.heap.page_size_min) u8) void {
    switch (builtin.os.tag) {
        .macos, .ios, .tvos, .watchos, .linux, .freebsd, .openbsd, .netbsd => {
            std.posix.munmap(memory);
        },
        .windows => {
            // VirtualFree returns void on native Windows, error union on cross-compilation
            const result = std.os.windows.VirtualFree(memory.ptr, 0, std.os.windows.MEM_RELEASE);
            if (@typeInfo(@TypeOf(result)) == .error_union) {
                _ = result catch {};
            }
        },
        else => {},
    }
}

// Tests

test "jit execute simple x86_64 code" {
    // Only run on x86_64
    if (builtin.cpu.arch != .x86_64) return error.SkipZigTest;

    // Simple x86_64 code that returns 42:
    // mov eax, 42   ; B8 2A 00 00 00
    // ret          ; C3
    const code = [_]u8{
        0xB8, 0x2A, 0x00, 0x00, 0x00, // mov eax, 42
        0xC3, // ret
    };

    var jit = try JitCode.init(&code);
    defer jit.deinit();

    const result = jit.callReturnI64();
    try std.testing.expectEqual(@as(i64, 42), result);
}

test "jit execute x86_64 return 64-bit value" {
    if (builtin.cpu.arch != .x86_64) return error.SkipZigTest;

    // x86_64 code that returns 0x123456789ABCDEF0:
    // movabs rax, 0x123456789ABCDEF0  ; 48 B8 F0 DE BC 9A 78 56 34 12
    // ret                             ; C3
    const code = [_]u8{
        0x48, 0xB8, 0xF0, 0xDE, 0xBC, 0x9A, 0x78, 0x56, 0x34, 0x12, // movabs rax, imm64
        0xC3, // ret
    };

    var jit = try JitCode.init(&code);
    defer jit.deinit();

    const result = jit.callReturnU64();
    try std.testing.expectEqual(@as(u64, 0x123456789ABCDEF0), result);
}

test "jit execute aarch64 code" {
    // Only run on aarch64
    if (builtin.cpu.arch != .aarch64) return error.SkipZigTest;

    // Simple aarch64 code that returns 42:
    // mov w0, #42   ; 52 80 05 40 (encoded as little-endian: 40 05 80 52)
    // ret          ; C0 03 5F D6
    const code = [_]u8{
        0x40, 0x05, 0x80, 0x52, // mov w0, #42
        0xC0, 0x03, 0x5F, 0xD6, // ret
    };

    var jit = try JitCode.init(&code);
    defer jit.deinit();

    const result = jit.callReturnI64();
    try std.testing.expectEqual(@as(i64, 42), result);
}
