//! JIT (Just-In-Time) execution infrastructure for the dev backend.
//!
//! This module provides the ability to execute generated machine code at runtime.
//! It allocates executable memory, copies generated code into it, and provides
//! a way to call the code as a function.
//!
//! The typical workflow is:
//! 1. Generate machine code using the CodeGen module
//! 2. Create a JitCode instance with the generated bytes
//! 3. Call the code as a function
//! 4. Clean up when done
//!
//! For code that calls external functions (like RC operations), use initWithRelocations
//! which resolves function addresses and patches the call sites.

const std = @import("std");
const builtin = @import("builtin");
const Relocation = @import("Relocation.zig").Relocation;

/// Executable memory region containing JIT-compiled code.
/// The code can be called as a function using the `call*` methods.
pub const JitCode = struct {
    /// The executable memory region
    memory: []align(std.heap.page_size_min) u8,
    /// Size of the actual code (may be less than memory.len)
    code_size: usize,

    const Self = @This();

    /// Allocate executable memory and copy the given code into it.
    /// The memory will be marked as executable (but not writable after copy).
    pub fn init(code: []const u8) !Self {
        return initWithRelocations(code, &.{}, null);
    }

    /// Function address resolver for linking external function calls.
    /// Returns the address of a function given its name, or null if not found.
    pub const FunctionResolver = *const fn (name: []const u8) ?usize;

    /// Allocate executable memory, apply relocations, and make it executable.
    /// Use this when the generated code contains calls to external functions.
    pub fn initWithRelocations(
        code: []const u8,
        relocations: []const Relocation,
        resolver: ?FunctionResolver,
    ) !Self {
        if (code.len == 0) {
            return error.EmptyCode;
        }

        // Round up to page size
        const page_size = std.heap.page_size_min;
        const alloc_size = std.mem.alignForward(usize, code.len, page_size);

        // Allocate memory with read-write permissions initially
        const memory = try allocateExecutableMemory(alloc_size);
        errdefer freeExecutableMemory(memory);

        // Copy the code
        @memcpy(memory[0..code.len], code);

        // Apply relocations before making memory executable
        if (resolver) |resolve_fn| {
            for (relocations) |reloc| {
                switch (reloc) {
                    .linked_function => |func_reloc| {
                        const target_addr = resolve_fn(func_reloc.name) orelse {
                            return error.UnresolvedSymbol;
                        };
                        // Calculate relative offset for x86_64 call instruction
                        // The call is relative to the instruction after the call (offset + 4)
                        const offset: usize = @intCast(func_reloc.offset);
                        const call_site = @intFromPtr(memory.ptr) + offset;
                        const rel_offset: i32 = @intCast(@as(i64, @intCast(target_addr)) - @as(i64, @intCast(call_site + 4)));
                        const offset_bytes: [4]u8 = @bitCast(rel_offset);
                        @memcpy(memory[offset..][0..4], &offset_bytes);
                    },
                    .local_data => {
                        // Local data relocations not yet supported
                    },
                    .linked_data => {
                        // Linked data relocations not yet supported
                    },
                    .jmp_to_return => {
                        // Jump relocations not yet supported
                    },
                }
            }
        }

        // Make the memory executable (and read-only on some platforms)
        try makeExecutable(memory);

        return Self{
            .memory = memory,
            .code_size = code.len,
        };
    }

    /// Free the executable memory
    pub fn deinit(self: *Self) void {
        freeExecutableMemory(self.memory);
        self.memory = &.{};
        self.code_size = 0;
    }

    /// Get a pointer to the start of the code
    pub fn codePtr(self: *const Self) [*]const u8 {
        return self.memory.ptr;
    }

    /// Call the code as a function that takes no arguments and returns i64
    pub fn callReturnI64(self: *const Self) i64 {
        const func: *const fn () callconv(.c) i64 = @ptrCast(self.memory.ptr);
        return func();
    }

    /// Call the code as a function that takes no arguments and returns u64
    pub fn callReturnU64(self: *const Self) u64 {
        const func: *const fn () callconv(.c) u64 = @ptrCast(self.memory.ptr);
        return func();
    }

    /// Call the code as a function that takes no arguments and returns f64
    pub fn callReturnF64(self: *const Self) f64 {
        const func: *const fn () callconv(.c) f64 = @ptrCast(self.memory.ptr);
        return func();
    }

    /// Call the code as a function that takes a result pointer and returns void.
    /// This is the Roc calling convention for functions that return values.
    pub fn callWithResultPtr(self: *const Self, result_ptr: *anyopaque) void {
        const func: *const fn (*anyopaque) callconv(.c) void = @ptrCast(self.memory.ptr);
        func(result_ptr);
    }

    /// Call the code as a function that takes a result pointer and RocOps pointer.
    /// Use this when the generated code needs to perform RC operations or call builtins.
    pub fn callWithResultPtrAndRocOps(self: *const Self, result_ptr: *anyopaque, roc_ops: *anyopaque) void {
        const func: *const fn (*anyopaque, *anyopaque) callconv(.c) void = @ptrCast(self.memory.ptr);
        func(result_ptr, roc_ops);
    }
};

/// Allocate memory that can be made executable
fn allocateExecutableMemory(size: usize) ![]align(std.heap.page_size_min) u8 {
    switch (builtin.os.tag) {
        .macos, .ios, .tvos, .watchos, .linux, .freebsd, .openbsd, .netbsd => {
            // Use mmap for POSIX systems
            const prot = std.posix.PROT.READ | std.posix.PROT.WRITE;
            const flags = std.posix.MAP{ .TYPE = .PRIVATE, .ANONYMOUS = true };
            const result = std.posix.mmap(null, size, prot, flags, -1, 0) catch {
                return error.MmapFailed;
            };
            return @alignCast(result[0..size]);
        },
        .windows => {
            // On Windows, use VirtualAlloc
            const mem = std.os.windows.VirtualAlloc(
                null,
                size,
                std.os.windows.MEM_COMMIT | std.os.windows.MEM_RESERVE,
                std.os.windows.PAGE_READWRITE,
            ) catch return error.VirtualAllocFailed;
            const ptr: [*]align(std.heap.page_size_min) u8 = @ptrCast(@alignCast(mem));
            return ptr[0..size];
        },
        else => return error.UnsupportedPlatform,
    }
}

/// Make the memory executable
fn makeExecutable(memory: []align(std.heap.page_size_min) u8) !void {
    switch (builtin.os.tag) {
        .macos, .ios, .tvos, .watchos, .linux, .freebsd, .openbsd, .netbsd => {
            // Change protection to read-execute
            const prot = std.posix.PROT.READ | std.posix.PROT.EXEC;
            std.posix.mprotect(memory, prot) catch return error.MprotectFailed;
        },
        .windows => {
            // On Windows, change protection to execute-read
            var old_protect: std.os.windows.DWORD = undefined;
            std.os.windows.VirtualProtect(
                memory.ptr,
                memory.len,
                std.os.windows.PAGE_EXECUTE_READ,
                &old_protect,
            ) catch return error.VirtualProtectFailed;
        },
        else => return error.UnsupportedPlatform,
    }
}

/// Free executable memory
fn freeExecutableMemory(memory: []align(std.heap.page_size_min) u8) void {
    switch (builtin.os.tag) {
        .macos, .ios, .tvos, .watchos, .linux, .freebsd, .openbsd, .netbsd => {
            std.posix.munmap(memory);
        },
        .windows => {
            // VirtualFree returns void on native Windows, error union on cross-compilation
            const result = std.os.windows.VirtualFree(memory.ptr, 0, std.os.windows.MEM_RELEASE);
            if (@typeInfo(@TypeOf(result)) == .error_union) {
                _ = result catch {};
            }
        },
        else => {},
    }
}

// Tests

test "jit execute simple x86_64 code" {
    // Only run on x86_64
    if (builtin.cpu.arch != .x86_64) return error.SkipZigTest;

    // Simple x86_64 code that returns 42:
    // mov eax, 42   ; B8 2A 00 00 00
    // ret          ; C3
    const code = [_]u8{
        0xB8, 0x2A, 0x00, 0x00, 0x00, // mov eax, 42
        0xC3, // ret
    };

    var jit = try JitCode.init(&code);
    defer jit.deinit();

    const result = jit.callReturnI64();
    try std.testing.expectEqual(@as(i64, 42), result);
}

test "jit execute x86_64 return 64-bit value" {
    if (builtin.cpu.arch != .x86_64) return error.SkipZigTest;

    // x86_64 code that returns 0x123456789ABCDEF0:
    // movabs rax, 0x123456789ABCDEF0  ; 48 B8 F0 DE BC 9A 78 56 34 12
    // ret                             ; C3
    const code = [_]u8{
        0x48, 0xB8, 0xF0, 0xDE, 0xBC, 0x9A, 0x78, 0x56, 0x34, 0x12, // movabs rax, imm64
        0xC3, // ret
    };

    var jit = try JitCode.init(&code);
    defer jit.deinit();

    const result = jit.callReturnU64();
    try std.testing.expectEqual(@as(u64, 0x123456789ABCDEF0), result);
}

test "jit execute aarch64 code" {
    // Only run on aarch64
    if (builtin.cpu.arch != .aarch64) return error.SkipZigTest;

    // Simple aarch64 code that returns 42:
    // mov w0, #42   ; 52 80 05 40 (encoded as little-endian: 40 05 80 52)
    // ret          ; C0 03 5F D6
    const code = [_]u8{
        0x40, 0x05, 0x80, 0x52, // mov w0, #42
        0xC0, 0x03, 0x5F, 0xD6, // ret
    };

    var jit = try JitCode.init(&code);
    defer jit.deinit();

    const result = jit.callReturnI64();
    try std.testing.expectEqual(@as(i64, 42), result);
}

// Test function for relocation tests - returns 123
fn testFuncForRelocation() callconv(.c) i64 {
    return 123;
}

// Resolver for relocation test
fn testResolver(name: []const u8) ?usize {
    if (std.mem.eql(u8, name, "test_func")) {
        return @intFromPtr(&testFuncForRelocation);
    }
    return null;
}

// Resolver that always fails
fn failingResolver(_: []const u8) ?usize {
    return null;
}

test "jit with function call relocation x86_64" {
    // Only run on x86_64
    if (builtin.cpu.arch != .x86_64) return error.SkipZigTest;

    // x86_64 code that calls our test function and returns its result:
    // call rel32     ; E8 XX XX XX XX (placeholder - will be patched)
    // ret            ; C3
    var code = [_]u8{
        0xE8, 0x00, 0x00, 0x00, 0x00, // call rel32 (placeholder)
        0xC3, // ret
    };

    // Create relocation for the call instruction
    const relocations = [_]Relocation{
        .{ .linked_function = .{
            .offset = 1, // After the E8 opcode
            .name = "test_func",
        } },
    };

    var jit = try JitCode.initWithRelocations(&code, &relocations, testResolver);
    defer jit.deinit();

    const result = jit.callReturnI64();
    try std.testing.expectEqual(@as(i64, 123), result);
}

test "jit unresolved symbol error" {
    // Only run on x86_64
    if (builtin.cpu.arch != .x86_64) return error.SkipZigTest;

    var code = [_]u8{
        0xE8, 0x00, 0x00, 0x00, 0x00, // call rel32
        0xC3, // ret
    };

    const relocations = [_]Relocation{
        .{ .linked_function = .{
            .offset = 1,
            .name = "nonexistent_func",
        } },
    };

    const result = JitCode.initWithRelocations(&code, &relocations, failingResolver);
    try std.testing.expectError(error.UnresolvedSymbol, result);
}
