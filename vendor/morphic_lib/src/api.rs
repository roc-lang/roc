use sha2::{digest::Digest, Sha256};
use smallvec::SmallVec;
use std::collections::{btree_map::Entry, BTreeMap};
use std::rc::Rc;

use crate::preprocess;
use crate::render_api_ir;
use crate::type_cache::TypeCache;
use crate::util::blocks::Blocks;
use crate::util::id_bi_map::IdBiMap;
use crate::util::id_type::Count;
use crate::util::id_vec::IdVec;
use crate::util::op_graph::OpGraph;
use crate::util::replace_none::replace_none;
use crate::{analyze, ir};

#[derive(Clone, thiserror::Error, Debug)]
#[non_exhaustive]
enum ErrorKind {
    #[error("no type found for {0:?}")]
    TypeIdNotFound(TypeId),
    #[error("no block found for {0:?}")]
    BlockIdNotFound(BlockId),
    #[error("no value found for {0:?}")]
    ValueIdNotFound(ValueId),
    #[error("no continuation found for {0:?}")]
    ContinuationIdNotFound(ContinuationId),
    #[error("body of continuation {0:?} is not defined")]
    ContinuationNotDefined(ContinuationId),
    #[error("body of continuation {0:?} has already been defined")]
    ContinuationAlreadyDefined(ContinuationId),
    #[error("block {0:?} has no parent")]
    BlockDetached(BlockId),
    #[error("block {0:?} already has a parent")]
    BlockAlreadyAttached(BlockId),
    #[error("callee specialization variable {0:?} already used elsewhere in the same function")]
    DuplicateCalleeSpecVar(CalleeSpecBuf),
    #[error("update mode variable {0:?} already used elsewhere in the same function")]
    DuplicateUpdateModeVar(UpdateModeBuf),
    #[error("duplicate type name {0:?} in module")]
    DuplicateTypeName(TypeNameBuf),
    #[error("duplicate function name {0:?} in module")]
    DuplicateFuncName(FuncNameBuf),
    #[error("duplicate constant name {0:?} in module")]
    DuplicateConstName(ConstNameBuf),
    #[error("duplicate module name {0:?} in program")]
    DuplicateModName(ModNameBuf),
    #[error("duplicate entry point name {0:?} in program")]
    DuplicateEntryPointName(EntryPointNameBuf),
    #[error("callee specialization variable {0:?} not found")]
    CalleeSpecVarNotFound(CalleeSpecBuf),
    #[error("update mode variable {0:?} not found")]
    UpdateModeVarNotFound(UpdateModeBuf),
    #[error("function specialization {0:?} not found")]
    FuncSpecNotFound(FuncSpec),
    #[error("function {0:?} not found in module")]
    FuncNotFound(FuncNameBuf),
    #[error("constant {0:?} not found in module")]
    ConstNotFound(ConstNameBuf),
    #[error("module {0:?} not found in program")]
    ModNotFound(ModNameBuf),
    #[error("entry point {0:?} not found in program")]
    EntryPointNotFound(EntryPointNameBuf),
    #[error("{0}")]
    PreprocessError(preprocess::Error),
}

#[derive(Clone, thiserror::Error, Debug)]
#[error("{kind}")]
pub struct Error {
    #[from]
    kind: ErrorKind,
}

pub type Result<T> = std::result::Result<T, Error>;

// Global identifiers:

bytes_id! {
    pub ModName;
    pub(crate) ModNameBuf;
}

bytes_id! {
    pub EntryPointName;
    pub(crate) EntryPointNameBuf;
}

// Module-level identifiers (unique within a module):

bytes_id! {
    pub TypeName;
    pub(crate) TypeNameBuf;
}

bytes_id! {
    pub FuncName;
    pub(crate) FuncNameBuf;
}

bytes_id! {
    pub ConstName;
    pub(crate) ConstNameBuf;
}

// Local identifiers (unique within a function body):

id_type! {
    /// A reference to an arena-allocated expression object in a function body.
    #[repr(C)]
    pub ValueId(u32);
}

id_type! {
    /// A reference to an arena-allocated continuation in a function body.
    ///
    /// See [`ExprContext::declare_continuation`], [`ExprContext::define_continuation`], and
    /// [`ExprContext::add_jump`] for more information.
    #[repr(C)]
    pub ContinuationId(u32);
}

id_type! {
    /// A reference to an arena-allocated block in a function body.
    ///
    /// A block is a sequence of zero or more expressions. Each expression has an associated
    /// `ValueId`, which is unique across all blocks within its function.
    #[repr(C)]
    pub BlockId(u32);
}

id_type! {
    /// A reference to an arena-allocated type node in a type definition or function body.
    #[repr(C)]
    pub TypeId(u32);
}

bytes_id! {
    /// A client-provided name used as a key to look up callee specializations in the solution
    /// tables generated by the analysis engine.
    pub CalleeSpecVar;
    pub(crate) CalleeSpecBuf;
}

bytes_id! {
    /// A client-provided name used as a key to look up concrete update mode flags in the solution
    /// tables generated by the analysis engine.
    pub UpdateModeVar;
    pub(crate) UpdateModeBuf;
}

// Input API:

forward_trait! {
    /// A trait for constructing types in both typedefs and expressions.
    ///
    /// Types are conceptually represented via trees of arena-allocated nodes. References to these
    /// nodes are exposed in the API as integer identifiers.
    pub trait TypeContext {
        /// Create a local type node referring to a named type defined in a module.
        ///
        /// A named type is essentially identical to a `newtype` in e.g. Haskell. Named types are
        /// useful for defining recursive types.
        fn add_named_type(&mut self, mod_: ModName, type_: TypeName) -> TypeId;

        /// Create a local type node representing an anonymous tuple type of the given types.
        fn add_tuple_type(&mut self, field_types: &[TypeId]) -> Result<TypeId>;

        /// Create a local type node representing an anonymous tagged union of the given types.
        fn add_union_type(&mut self, variant_types: &[TypeId]) -> Result<TypeId>;

        /// Create a local type node representing a heap cell.
        ///
        /// A heap cell is an abstract object used to model data types which are candidates for
        /// in-place mutation. A heap cell has reference semantics, and is always in one of two
        /// states: either "fresh" or "mutated". Accessing a mutated heap cell is considered unsafe,
        /// and in-place mutations mark heap cells as mutated. The analysis engine tries to perform
        /// as many heap cell updates as possible in-place, subject to the constraint that every
        /// heap cell access must be safe.
        fn add_heap_cell_type(&mut self) -> TypeId;

        /// Create a local type node representing a bag of a given type.
        ///
        /// A bag is an immutable unordered collection of values of a given type, permitting
        /// duplicates.
        fn add_bag_type(&mut self, item_type: TypeId) -> Result<TypeId>;
    }

    impl TypeDefBuilder => .inner;
    impl ExprBuilder => .type_builder;
    impl FuncDefBuilder => .expr_builder;
    impl ConstDefBuilder => .expr_builder;
}

#[derive(Debug)]
struct SeqGen {
    next: u32,
}

impl SeqGen {
    fn new() -> Self {
        Self { next: 0 }
    }

    fn next(&mut self) -> u32 {
        let result = self.next;
        self.next += 1;
        result
    }

    fn check_in_range(&self, id: u32) -> std::result::Result<(), ()> {
        if id < self.next {
            Ok(())
        } else {
            Err(())
        }
    }
}

/// A block, together with a value to return from the block.
///
/// The returned value must be in scope at the end of the block.
///
/// This is conceptually similar to a `let ... in ...` expression. The block corresponds to the
/// sequence of `let` bindings, and the returned value id corresponds to the final `in ...`
/// expression.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlockExpr(pub BlockId, pub ValueId);

forward_trait! {
    /// A trait for constructing expressions in both function bodies and constant initializers.
    pub trait ExprContext {
        /// Add a block to the current function body.
        ///
        /// A block is a sequence of zero or more expressions. Each expression has an associated
        /// `ValueId`, which is unique across all blocks within the current function.
        ///
        /// Blocks form a tree. In particular, blocks may contain other blocks via 'choice'
        /// expressions, and building a function with `build` requires providing a 'root' block
        /// which acts as the entry point of the function.
        ///
        /// When a function body is finalized with `build`, every non-root block should have exactly
        /// one parent, and the root block should have no parents.
        fn add_block(&mut self) -> BlockId;

        /// Add an expression with unknown semantics to a block, operating on a given set of values.
        ///
        /// The analysis engine will conservatively treat this expression as if it could perform any
        /// operation expressible in the modeling language mentioning `args`, except in-place
        /// mutations.
        ///
        /// The analysis engine will not consider any possible behaviors which would require access
        /// to values in scope not appearing in `args`, or which would require access to any join
        /// point in scope.
        ///
        /// This will significantly limit optimizations, but could be useful for prototyping.
        fn add_unknown_with(
            &mut self,
            block: BlockId,
            args: &[ValueId],
            result_type: TypeId,
        ) -> Result<ValueId>;

        /// Add a function call expression to a block.
        ///
        /// The call must be annotated with a `CalleeSpecVar`, to be used in the solution table as a
        /// key associated with the appropriate specialization of the callee selected by the
        /// analysis engine.
        fn add_call(
            &mut self,
            block: BlockId,
            callee_spec_var: CalleeSpecVar,
            callee_mod: ModName,
            callee: FuncName,
            arg: ValueId,
        ) -> Result<ValueId>;

        /// Add a const ref expression to a block.
        ///
        /// This conceptually represents a fetch of a global constant value with static lifetime,
        /// initialized at the beginning of the program.  It is considered unsafe to perform an
        /// in-place update on any heap cell reachable from a value returned from a const ref.
        fn add_const_ref(
            &mut self,
            block: BlockId,
            const_mod: ModName,
            const_: ConstName,
        ) -> Result<ValueId>;

        /// Add a 'choice' expression to a block.
        ///
        /// A 'choice' expression consists of one or more 'case' blocks, each of which returns a
        /// value. Semantically, executing a choice expression always executes exactly one of its
        /// 'case' blocks. The analysis engine assumes that any 'case' block may be executed
        /// whenever the 'choice' expression is encountered; it is as if a nondeterministic process
        /// selects the 'case' block to be executed.
        fn add_choice(&mut self, block: BlockId, cases: &[BlockExpr]) -> Result<ValueId>;

        /// Add a sub-block expression to a block.
        ///
        /// The sub-block expression evaluates to the value returned by the sub-block.
        ///
        /// This is useful in combination with continuations, because returning from a continuation
        /// always yields control to the parent of the enclosing block in which the continuation was
        /// defined. Without sub-blocks, there would be no way to reduce the scope of a continuation
        /// within a block.
        fn add_sub_block(&mut self, block: BlockId, sub_block: BlockExpr) -> Result<ValueId>;

        /// Add a 'terminate' expression to a block.
        ///
        /// Semantically, a 'terminate' expression is modeled as immediately terminating the entire
        /// program. Terminating the program is considered to be safe behavior.
        ///
        /// The type of the resulting value can be chosen freely, because a 'terminate' expression
        /// never actually returns (this is analogous to `panic!()` in Rust, which may be used where
        /// a value of any type is expected).
        fn add_terminate(&mut self, block: BlockId, result_type: TypeId) -> Result<ValueId>;

        /// Add an expression which creates a fresh heap cell to a block.
        fn add_new_heap_cell(&mut self, block: BlockId) -> Result<ValueId>;

        /// Add a 'touch' expression to a block.
        ///
        /// A 'touch' expression represents "reading" the contents of a heap cell. Semantically,
        /// 'touch'ing a heap cell which has been mutated is considered *unsafe*. The analysis
        /// engine will choose update mode flags to ensure that this never happens.
        ///
        /// A 'touch' expression returns the empty tuple type `()`.
        fn add_touch(&mut self, block: BlockId, heap_cell: ValueId) -> Result<ValueId>;

        /// Add a 'recursive touch' expression to a block.
        ///
        /// Semantically, this is equivalent to 'touch'ing all heap cells reachable from `object`,
        /// including heap cells nested inside tuples, unions, bags, and named types.  The `object`
        /// argument may be of any type, and does not necessarily need to contain any heap cells at
        /// all (in which case this operation will be a no-op).
        ///
        /// A 'recursive touch' expression returns the empty tuple type `()`.
        fn add_recursive_touch(&mut self, block: BlockId, object: ValueId) -> Result<ValueId>;

        /// Add an 'update' expression to a block.
        ///
        /// An 'update' expression represents an attempt to "write" the contents of the heap cell.
        /// The analysis engine will assign each 'update' operation a concrete "update mode" flag,
        /// which is either `UpdateMode::Immutable` or `UpdateMode::InPlace`. When the mode is
        /// `Immutable`, an 'update' operation is semantically a no-op. When the mode is `InPlace`,
        /// an 'update' operation *mutates* its heap cell, making further 'touch' and 'update'
        /// operations on that heap cell unsafe. The analysis engine will always choose update modes
        /// such that all possible executions of the program are guaranteed to be safe.
        ///
        /// Note that performing an 'update' operation on a mutated heap cell is considered
        /// *unsafe*. This is a conservative assumption, and accurately models most real-world
        /// update operations. If you want a version of 'update' which the analysis engine considers
        /// safe to perform on mutated heap cells, see `add_update_write_only`. A call to
        /// `add_update` is semantically equivalent to `add_touch` followed by
        /// `add_update_write_only`.
        ///
        /// The 'update' expression must be annotated with an `UpdateModeVar`, to be used in the
        /// solution table as a key associated with the concrete update mode selected for this
        /// expression by the analysis engine.
        ///
        /// An 'update' expression returns the empty tuple type `()`. If you want to model an
        /// operation which returns an updated version of its input data structure (with the update
        /// possibly performed in-place), you can return a fresh heap cell with `add_new_heap_cell`.
        /// Returning the original heap cell is almost certainly not what you want, because if the
        /// 'update' is performed in-place then any subsequent accesses to the original heap cell
        /// will be considered unsafe.
        fn add_update(
            &mut self,
            block: BlockId,
            update_mode_var: UpdateModeVar,
            heap_cell: ValueId,
        ) -> Result<ValueId>;

        /// Add a write-only 'update' expression to a block.
        ///
        /// This is identical to `add_update`, except that write-only 'update's of mutated heap
        /// cells are considered safe. This is probably not what you want for most real-world update
        /// operations.
        fn add_update_write_only(
            &mut self,
            block: BlockId,
            update_mode_var: UpdateModeVar,
            heap_cell: ValueId,
        ) -> Result<ValueId>;

        /// Add an expression to a block which creates an empty bag.
        ///
        /// A bag is an immutable unordered collection of values of a given type, permitting
        /// duplicates.
        fn add_empty_bag(&mut self, block: BlockId, item_type: TypeId) -> Result<ValueId>;

        /// Add an expression to a block which inserts a value into a bag, producing a new bag.
        fn add_bag_insert(
            &mut self,
            block: BlockId,
            bag: ValueId,
            to_insert: ValueId,
        ) -> Result<ValueId>;

        /// Add an expression to a block which gets an item from a bag, returning the item.
        ///
        /// The analysis engine assumes that any item in the bag may potentially be obtained from
        /// this operation; it is as if the item is chosen by a nondeterministic process.
        ///
        /// Semantically, if the bag is empty the program is considered to terminate immediately, as
        /// if a 'terminate' expression had appeared. Terminating the program in this way is
        /// considered safe behavior.
        fn add_bag_get(&mut self, block: BlockId, bag: ValueId) -> Result<ValueId>;

        /// Add an expression to a block which removes an item from a bag, producing a two-element
        /// tuple containing (1) the bag with the item removed, and (2) the removed item.
        ///
        /// The analysis engine assumes that any item in the bag may potentially be removed by this
        /// operation; it is as if the item to remove is chosen by a nondeterministic process.
        //
        /// Semantically, if the original bag is empty the program is considered to terminate
        /// immediately, as if a 'terminate' expression had appeared. Terminating the program in
        /// this way is considered safe behavior.
        fn add_bag_remove(&mut self, block: BlockId, bag: ValueId) -> Result<ValueId>;

        /// Add an expression to a block which constructs a tuple value.
        fn add_make_tuple(&mut self, block: BlockId, field_vals: &[ValueId]) -> Result<ValueId>;

        /// Add an expression to a block which gets a single field of a tuple value.
        fn add_get_tuple_field(
            &mut self,
            block: BlockId,
            tuple: ValueId,
            field_idx: u32,
        ) -> Result<ValueId>;

        /// Add an expression to a block which constructs a specific variant of an anonymous tagged
        /// union.
        fn add_make_union(
            &mut self,
            block: BlockId,
            variant_types: &[TypeId],
            variant_idx: u32,
            to_wrap: ValueId,
        ) -> Result<ValueId>;

        /// Add an expression to a block which unwraps a specific variant of an anonymous tagged
        /// union.
        ///
        /// Semantically, if the union value is not actually tagged with the requested variant
        /// index, the program is considered to terminate immediately, as if a 'terminate'
        /// expression had appeared. Terminating the program as a result of this kind of variant tag
        /// mismatch is considered safe behavior.
        fn add_unwrap_union(
            &mut self,
            block: BlockId,
            to_unwrap: ValueId,
            variant_idx: u32,
        ) -> Result<ValueId>;

        /// Add an expression to a block which wraps a value in a named type.
        ///
        /// The type of the wrapped value must match the content type of the named type.
        fn add_make_named(
            &mut self,
            block: BlockId,
            named_mod: ModName,
            named: TypeName,
            to_wrap: ValueId,
        ) -> Result<ValueId>;

        /// Add an expression to a block which unwraps a value wrapped in a named type.
        ///
        /// The type of the resulting value will match the content type of the named type.
        fn add_unwrap_named(
            &mut self,
            block: BlockId,
            named_mod: ModName,
            named: TypeName,
            to_unwrap: ValueId,
        ) -> Result<ValueId>;

        /// Declare a continuation in a `block`.
        ///
        /// A continuation is like a local function which does not return to its caller.  A
        /// continuation always has a single argument, and a "body" block in which that argument is
        /// in scope.  Declaring a continuation has no effect on its own, but after a continuation
        /// is declared it may be called with a ['jump'](ExprContext::add_jump) expression.
        ///
        /// Like calling a function, jumping to a continuation transfers control to its body.
        /// However, unlike a function, a continuation does not return control to its caller.  When
        /// a continuation returns, instead of transferring control to the 'jump' expression that
        /// called it, the continuation transfers control to the *parent of the `block` in which the
        /// continuation was defined*. When a continuation returns, its return value becomes the
        /// return value of the `block` in which it was defined.
        ///
        /// Continuations can be used to express constructs such as 'goto' statements, loops,
        /// 'break' and 'continue' statements, early returns, tail calls, and ["join
        /// points"](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf).
        ///
        /// THe `declare_continuation` function allows you to forward-declare a continuation without
        /// specifying its body, which makes it possible to define recursive and mutually recursive
        /// continuations.  However, you must eventually populate the body of each continuation via
        /// a call to [`define_continuation`](ExprContext::define_continuation).
        ///
        /// The `ValueId` returned from `declare_continuation` is the `ValueId` of the *argument* to
        /// the continuation, which is in scope within the body of the continuation.
        fn declare_continuation(
            &mut self,
            block: BlockId,
            arg_type: TypeId,
            ret_type: TypeId,
        ) -> Result<(ContinuationId, ValueId)>;

        /// Define the body of a continuation.
        ///
        /// Before a continuation can be defined, it must be declared via a call to
        /// [`declare_continuation`](ExprContext::declare_continuation).
        fn define_continuation(
            &mut self,
            continuation: ContinuationId,
            body: BlockExpr
        ) -> Result<()>;

        /// Add a 'jump' to a continuation.
        ///
        /// A 'jump' expression never returns, and any code which operates on the notional "return
        /// value" of a 'jump' expression will be unreachable.  However, in some cases it may still
        /// be useful to treat a 'jump' expression as if it returned a value of a given type (for
        /// example, in a `choice` expression in which one arm returns a value, and the other arm
        /// ends in a 'jump').   For this reason, `add_jump` accepts an `unreachable_return_type`
        /// argument which allows you to set the return type of the 'jump' expression to *any type
        /// of your choosing*. This is analogous to the idea of a ["diverging
        /// function"](https://doc.rust-lang.org/stable/rust-by-example/fn/diverging.html) in Rust,
        /// whose return value may be used where a value of any type is expected.
        fn add_jump(
            &mut self,
            block: BlockId,
            continuation: ContinuationId,
            arg: ValueId,
            unreachable_result_type: TypeId,
        ) -> Result<ValueId>;
    }

    impl FuncDefBuilder => .expr_builder;
    impl ConstDefBuilder => .expr_builder;
}

#[derive(Clone, Debug)]
pub(crate) enum TypeOp {
    // 0 inputs
    Named {
        named_mod: ModNameBuf,
        named: TypeNameBuf,
    },
    // Variadic inputs
    Tuple,
    // Variadic inputs
    Union,
    // 0 inputs
    HeapCell,
    // 1 input
    Bag,
}

/// A `TypeDef` defines the content type of a named type.
pub struct TypeDef {
    pub(crate) builder: TypeBuilder,
    pub(crate) root: TypeId,
}

#[derive(Clone, Debug)]
pub(crate) struct TypeBuilder {
    pub(crate) types: OpGraph<TypeId, TypeOp>,
}

impl Default for TypeBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl TypeBuilder {
    fn new() -> Self {
        Self {
            types: OpGraph::new(),
        }
    }

    fn check(&self, id: TypeId) -> Result<()> {
        if id >= self.types.count() {
            return Err(ErrorKind::TypeIdNotFound(id).into());
        }
        Ok(())
    }

    fn add_node_checked(&mut self, op: TypeOp, inputs: &[TypeId]) -> Result<TypeId> {
        for &input in inputs {
            self.check(input)?;
        }
        Ok(self.types.add_node(op, inputs))
    }
}

impl TypeContext for TypeBuilder {
    fn add_named_type(&mut self, named_mod: ModName, named: TypeName) -> TypeId {
        self.types.add_node(
            TypeOp::Named {
                named_mod: named_mod.into(),
                named: named.into(),
            },
            &[],
        )
    }

    fn add_tuple_type(&mut self, field_types: &[TypeId]) -> Result<TypeId> {
        self.add_node_checked(TypeOp::Tuple, field_types)
    }

    fn add_union_type(&mut self, variant_types: &[TypeId]) -> Result<TypeId> {
        self.add_node_checked(TypeOp::Union, variant_types)
    }

    fn add_heap_cell_type(&mut self) -> TypeId {
        self.types.add_node(TypeOp::HeapCell, &[])
    }

    fn add_bag_type(&mut self, item_type: TypeId) -> Result<TypeId> {
        self.add_node_checked(TypeOp::Bag, &[item_type])
    }
}

pub struct TypeDefBuilder {
    inner: TypeBuilder,
}

impl Default for TypeDefBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl TypeDefBuilder {
    pub fn new() -> Self {
        Self {
            inner: TypeBuilder::new(),
        }
    }

    /// Create a `TypeDef` using the given type node as the root.
    pub fn build(self, root: TypeId) -> Result<TypeDef> {
        self.inner.check(root)?;
        Ok(TypeDef {
            builder: self.inner,
            root,
        })
    }
}

id_type! {
    pub(crate) UpdateModeVarId(u32);
}

id_type! {
    pub(crate) CalleeSpecVarId(u32);
}

#[derive(Clone, Debug)]
pub(crate) enum Op {
    // 0 inputs
    Arg,
    // 0 inputs
    ContinuationArg,
    // 0 inputs
    // TODO: We may want to refactor the IR so that this is not an op.
    DeclareContinuation {
        continuation: ContinuationId,
    },
    // 1 input
    Jump {
        continuation: ContinuationId,
        unreachable_result_type: TypeId,
    },
    // Variadic inputs
    UnknownWith {
        result_type: TypeId,
    },
    // 1 input
    Call {
        callee_spec_var: CalleeSpecVarId,
        callee_mod: ModNameBuf,
        callee: FuncNameBuf,
    },
    // 0 inputs
    ConstRef {
        const_mod: ModNameBuf,
        const_: ConstNameBuf,
    },
    // 0 inputs
    Choice {
        // Invariant: 'cases' must be nonempty (to ensure we can always infer the type of a `Choice`
        // op).
        cases: SmallVec<[BlockExpr; 6]>,
    },
    // 0 inputs
    SubBlock {
        sub_block: BlockExpr,
    },
    // 0 inputs
    Terminate {
        unreachable_result_type: TypeId,
    },
    // 0 inputs
    NewHeapCell,
    // 1 input
    Touch,
    // 1 input
    RecursiveTouch,
    // 1 input
    UpdateWriteOnly {
        update_mode_var: UpdateModeVarId,
    },
    // 0 inputs
    EmptyBag {
        item_type: TypeId,
    },
    // 2 inputs: (bag, to_insert)
    BagInsert,
    // 1 input
    BagGet,
    // 1 input
    // output: (new bag, item)
    BagRemove,
    // Variadic inputs
    MakeTuple,
    // 1 input
    GetTupleField {
        field_idx: u32,
    },
    // 1 input
    MakeUnion {
        variant_types: SmallVec<[TypeId; 10]>,
        variant_idx: u32,
    },
    // 1 input
    UnwrapUnion {
        variant_idx: u32,
    },
    // 1 input
    MakeNamed {
        named_mod: ModNameBuf,
        named: TypeNameBuf,
    },
    // 1 input
    UnwrapNamed {
        named_mod: ModNameBuf,
        named: TypeNameBuf,
    },
}

#[derive(Clone, Copy, Debug)]
pub(crate) struct ContinuationInfo {
    pub(crate) arg_type: TypeId,
    pub(crate) ret_type: TypeId,
    pub(crate) arg: ValueId,
    pub(crate) body: Option<BlockExpr>,
}

#[derive(Clone, Copy, Debug)]
pub(crate) enum BlockState {
    Detached,
    Attached,
}

#[derive(Clone, Debug)]
pub(crate) struct ExprBuilder {
    pub(crate) type_builder: TypeBuilder,
    pub(crate) blocks: Blocks<BlockId, ValueId, BlockState>,
    pub(crate) vals: OpGraph<ValueId, Op>,
    pub(crate) continuations: IdVec<ContinuationId, ContinuationInfo>,
    pub(crate) callee_spec_vars: IdBiMap<CalleeSpecVarId, CalleeSpecBuf>,
    pub(crate) update_mode_vars: IdBiMap<UpdateModeVarId, UpdateModeBuf>,
}

impl Default for ExprBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl ExprBuilder {
    fn new() -> Self {
        Self {
            type_builder: TypeBuilder::new(),
            blocks: Blocks::new(),
            vals: OpGraph::new(),
            continuations: IdVec::new(),
            callee_spec_vars: IdBiMap::new(),
            update_mode_vars: IdBiMap::new(),
        }
    }

    fn check_tid(&self, id: TypeId) -> Result<()> {
        self.type_builder.check(id)
    }

    fn check_bid(&self, id: BlockId) -> Result<()> {
        if id >= self.blocks.block_count() {
            return Err(ErrorKind::BlockIdNotFound(id).into());
        }
        Ok(())
    }

    fn check_vid(&self, id: ValueId) -> Result<()> {
        if id >= self.vals.count() {
            return Err(ErrorKind::ValueIdNotFound(id).into());
        }
        Ok(())
    }

    fn check_cid(&self, id: ContinuationId) -> Result<()> {
        if id >= self.continuations.count() {
            return Err(ErrorKind::ContinuationIdNotFound(id).into());
        }
        Ok(())
    }

    fn finalize_with_root(&mut self, root: BlockExpr) -> Result<()> {
        self.attach_block(root.0)?;
        self.check_vid(root.1)?;
        for (continuation, info) in &self.continuations {
            if info.body.is_none() {
                return Err(ErrorKind::ContinuationNotDefined(continuation).into());
            }
        }
        for block_id in self.blocks.block_count().iter() {
            match self.blocks.block_info(block_id) {
                BlockState::Detached => {
                    return Err(ErrorKind::BlockDetached(block_id).into());
                }
                BlockState::Attached => {}
            }
        }
        Ok(())
    }

    fn add_argument(&mut self) -> ValueId {
        self.vals.add_node(Op::Arg, &[])
    }

    fn add_node_checked(&mut self, block: BlockId, op: Op, inputs: &[ValueId]) -> Result<ValueId> {
        self.check_bid(block)?;
        for &input in inputs {
            self.check_vid(input)?;
        }
        let val_id = self.vals.add_node(op, inputs);
        self.blocks.add_value(block, val_id);
        Ok(val_id)
    }

    fn attach_block(&mut self, block: BlockId) -> Result<()> {
        self.check_bid(block)?;
        let state = self.blocks.block_info_mut(block);
        match state {
            BlockState::Detached => *state = BlockState::Attached,
            BlockState::Attached => return Err(ErrorKind::BlockAlreadyAttached(block).into()),
        }
        Ok(())
    }
}

impl ExprContext for ExprBuilder {
    fn declare_continuation(
        &mut self,
        block: BlockId,
        arg_type: TypeId,
        ret_type: TypeId,
    ) -> Result<(ContinuationId, ValueId)> {
        self.check_tid(arg_type)?;
        self.check_tid(ret_type)?;
        let arg = self.vals.add_node(Op::ContinuationArg, &[]);
        let continuation = self.continuations.push(ContinuationInfo {
            arg_type,
            ret_type,
            arg,
            body: None,
        });
        self.add_node_checked(block, Op::DeclareContinuation { continuation }, &[])?;
        Ok((continuation, arg))
    }

    fn define_continuation(&mut self, continuation: ContinuationId, body: BlockExpr) -> Result<()> {
        self.check_cid(continuation)?;
        self.check_bid(body.0)?;
        self.check_vid(body.1)?;
        self.attach_block(body.0)?;
        replace_none(&mut self.continuations[continuation].body, body)
            .map_err(|_| ErrorKind::ContinuationAlreadyDefined(continuation))?;
        Ok(())
    }

    fn add_jump(
        &mut self,
        block: BlockId,
        continuation: ContinuationId,
        arg: ValueId,
        unreachable_result_type: TypeId,
    ) -> Result<ValueId> {
        self.check_cid(continuation)?;
        self.check_tid(unreachable_result_type)?;
        self.add_node_checked(
            block,
            Op::Jump {
                continuation,
                unreachable_result_type,
            },
            &[arg],
        )
    }

    fn add_block(&mut self) -> BlockId {
        self.blocks
            .add_block(self.vals.count().0, BlockState::Detached)
    }

    fn add_unknown_with(
        &mut self,
        block: BlockId,
        args: &[ValueId],
        result_type: TypeId,
    ) -> Result<ValueId> {
        self.check_tid(result_type)?;
        self.add_node_checked(block, Op::UnknownWith { result_type }, args)
    }

    fn add_call(
        &mut self,
        block: BlockId,
        callee_spec_var: CalleeSpecVar,
        callee_mod: ModName,
        callee: FuncName,
        arg: ValueId,
    ) -> Result<ValueId> {
        let callee_spec_var_id = self
            .callee_spec_vars
            .insert(callee_spec_var.into())
            .map_err(|_| ErrorKind::DuplicateCalleeSpecVar(callee_spec_var.into()))?;
        self.add_node_checked(
            block,
            Op::Call {
                callee_spec_var: callee_spec_var_id,
                callee_mod: callee_mod.into(),
                callee: callee.into(),
            },
            &[arg],
        )
    }

    fn add_const_ref(
        &mut self,
        block: BlockId,
        const_mod: ModName,
        const_: ConstName,
    ) -> Result<ValueId> {
        self.add_node_checked(
            block,
            Op::ConstRef {
                const_mod: const_mod.into(),
                const_: const_.into(),
            },
            &[],
        )
    }

    fn add_choice(&mut self, block: BlockId, cases: &[BlockExpr]) -> Result<ValueId> {
        for &BlockExpr(case_block, case_ret) in cases {
            self.attach_block(case_block)?;
            self.check_vid(case_ret)?;
        }
        self.add_node_checked(
            block,
            Op::Choice {
                cases: SmallVec::from_slice(cases),
            },
            &[],
        )
    }

    fn add_sub_block(&mut self, block: BlockId, sub_block: BlockExpr) -> Result<ValueId> {
        self.attach_block(sub_block.0)?;
        self.check_vid(sub_block.1)?;
        self.add_node_checked(block, Op::SubBlock { sub_block }, &[])
    }

    fn add_terminate(
        &mut self,
        block: BlockId,
        unreachable_result_type: TypeId,
    ) -> Result<ValueId> {
        self.check_tid(unreachable_result_type)?;
        self.add_node_checked(
            block,
            Op::Terminate {
                unreachable_result_type,
            },
            &[],
        )
    }

    fn add_new_heap_cell(&mut self, block: BlockId) -> Result<ValueId> {
        self.add_node_checked(block, Op::NewHeapCell, &[])
    }

    fn add_touch(&mut self, block: BlockId, heap_cell: ValueId) -> Result<ValueId> {
        self.add_node_checked(block, Op::Touch, &[heap_cell])
    }

    fn add_recursive_touch(&mut self, block: BlockId, object: ValueId) -> Result<ValueId> {
        self.add_node_checked(block, Op::RecursiveTouch, &[object])
    }

    fn add_update(
        &mut self,
        block: BlockId,
        update_mode_var: UpdateModeVar,
        heap_cell: ValueId,
    ) -> Result<ValueId> {
        self.add_touch(block, heap_cell)?;
        self.add_update_write_only(block, update_mode_var, heap_cell)
    }

    fn add_update_write_only(
        &mut self,
        block: BlockId,
        update_mode_var: UpdateModeVar,
        heap_cell: ValueId,
    ) -> Result<ValueId> {
        let update_mode_var_id = self
            .update_mode_vars
            .insert(update_mode_var.into())
            .map_err(|_| ErrorKind::DuplicateUpdateModeVar(update_mode_var.into()))?;
        self.add_node_checked(
            block,
            Op::UpdateWriteOnly {
                update_mode_var: update_mode_var_id,
            },
            &[heap_cell],
        )
    }

    fn add_empty_bag(&mut self, block: BlockId, item_type: TypeId) -> Result<ValueId> {
        self.check_tid(item_type)?;
        self.add_node_checked(block, Op::EmptyBag { item_type }, &[])
    }

    fn add_bag_insert(
        &mut self,
        block: BlockId,
        bag: ValueId,
        to_insert: ValueId,
    ) -> Result<ValueId> {
        self.add_node_checked(block, Op::BagInsert, &[bag, to_insert])
    }

    fn add_bag_get(&mut self, block: BlockId, bag: ValueId) -> Result<ValueId> {
        self.add_node_checked(block, Op::BagGet, &[bag])
    }

    fn add_bag_remove(&mut self, block: BlockId, bag: ValueId) -> Result<ValueId> {
        self.add_node_checked(block, Op::BagRemove, &[bag])
    }

    fn add_make_tuple(&mut self, block: BlockId, field_vals: &[ValueId]) -> Result<ValueId> {
        self.add_node_checked(block, Op::MakeTuple, field_vals)
    }

    fn add_get_tuple_field(
        &mut self,
        block: BlockId,
        tuple: ValueId,
        field_idx: u32,
    ) -> Result<ValueId> {
        self.add_node_checked(block, Op::GetTupleField { field_idx }, &[tuple])
    }

    fn add_make_union(
        &mut self,
        block: BlockId,
        variant_types: &[TypeId],
        variant_idx: u32,
        to_wrap: ValueId,
    ) -> Result<ValueId> {
        for &variant_type in variant_types {
            self.check_tid(variant_type)?;
        }
        // TODO: Check variant_idx in range
        self.add_node_checked(
            block,
            Op::MakeUnion {
                variant_types: SmallVec::from_slice(variant_types),
                variant_idx,
            },
            &[to_wrap],
        )
    }

    fn add_unwrap_union(
        &mut self,
        block: BlockId,
        to_unwrap: ValueId,
        variant_idx: u32,
    ) -> Result<ValueId> {
        self.add_node_checked(block, Op::UnwrapUnion { variant_idx }, &[to_unwrap])
    }

    fn add_make_named(
        &mut self,
        block: BlockId,
        named_mod: ModName,
        named: TypeName,
        to_wrap: ValueId,
    ) -> Result<ValueId> {
        self.add_node_checked(
            block,
            Op::MakeNamed {
                named_mod: named_mod.into(),
                named: named.into(),
            },
            &[to_wrap],
        )
    }

    fn add_unwrap_named(
        &mut self,
        block: BlockId,
        named_mod: ModName,
        named: TypeName,
        to_unwrap: ValueId,
    ) -> Result<ValueId> {
        self.add_node_checked(
            block,
            Op::UnwrapNamed {
                named_mod: named_mod.into(),
                named: named.into(),
            },
            &[to_unwrap],
        )
    }
}

/// A `FuncDef` defines the signature and body of a function.
pub struct FuncDef {
    pub(crate) builder: FuncDefBuilder,
    pub(crate) arg_type: TypeId,
    pub(crate) ret_type: TypeId,
    pub(crate) root: BlockExpr,
}

pub struct FuncDefBuilder {
    pub(crate) expr_builder: ExprBuilder,
    pub(crate) argument: ValueId,
}

impl Default for FuncDefBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl FuncDefBuilder {
    pub fn new() -> Self {
        let mut expr_builder = ExprBuilder::new();
        let argument = expr_builder.add_argument();
        Self {
            expr_builder,
            argument,
        }
    }

    /// Get the value id of the argument to the current function.
    ///
    /// Every function takes exactly one argument.  Multiple arguments can be represented via
    /// tuples.
    pub fn get_argument(&self) -> ValueId {
        self.argument
    }

    /// Construct a function from this builder with a given argument type, return type, root block,
    /// and value to return from that root block.
    pub fn build(mut self, arg_type: TypeId, ret_type: TypeId, root: BlockExpr) -> Result<FuncDef> {
        // TODO: Perform scope checking and typechecking
        self.expr_builder.check_tid(arg_type)?;
        self.expr_builder.check_tid(ret_type)?;
        self.expr_builder.finalize_with_root(root)?;
        Ok(FuncDef {
            builder: self,
            arg_type,
            ret_type,
            root,
        })
    }
}

/// A `ConstDef` defines the type and initializer expression for a global constant.
pub struct ConstDef {
    pub(crate) builder: ConstDefBuilder,
    pub(crate) type_: TypeId,
    pub(crate) root: BlockExpr,
}

pub struct ConstDefBuilder {
    pub(crate) expr_builder: ExprBuilder,
}

impl Default for ConstDefBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl ConstDefBuilder {
    pub fn new() -> Self {
        Self {
            expr_builder: ExprBuilder::new(),
        }
    }

    /// Construct a const from this builder with a given type, root block, and value to return from
    /// that root block.
    pub fn build(mut self, type_: TypeId, root: BlockExpr) -> Result<ConstDef> {
        // TODO: Perform scope checking and typechecking
        self.expr_builder.check_tid(type_)?;
        self.expr_builder.finalize_with_root(root)?;
        Ok(ConstDef {
            builder: self,
            type_,
            root,
        })
    }
}

/// A `ModDef` defines a module, which is a collection of named types, functions, and constants.
pub struct ModDef {
    pub(crate) type_defs: BTreeMap<TypeNameBuf, TypeDef>,
    pub(crate) func_defs: BTreeMap<FuncNameBuf, FuncDef>,
    pub(crate) const_defs: BTreeMap<ConstNameBuf, ConstDef>,
}

pub struct ModDefBuilder {
    type_defs: BTreeMap<TypeNameBuf, TypeDef>,
    func_defs: BTreeMap<FuncNameBuf, FuncDef>,
    const_defs: BTreeMap<ConstNameBuf, ConstDef>,
}

impl Default for ModDefBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl ModDefBuilder {
    pub fn new() -> Self {
        Self {
            type_defs: BTreeMap::new(),
            func_defs: BTreeMap::new(),
            const_defs: BTreeMap::new(),
        }
    }

    pub fn build(self) -> Result<ModDef> {
        Ok(ModDef {
            type_defs: self.type_defs,
            func_defs: self.func_defs,
            const_defs: self.const_defs,
        })
    }

    pub fn add_named_type(&mut self, name: TypeName, type_def: TypeDef) -> Result<()> {
        if self.type_defs.insert(name.into(), type_def).is_some() {
            return Err(ErrorKind::DuplicateTypeName(name.into()).into());
        }
        Ok(())
    }

    pub fn add_func(&mut self, name: FuncName, func_def: FuncDef) -> Result<()> {
        if self.func_defs.insert(name.into(), func_def).is_some() {
            return Err(ErrorKind::DuplicateFuncName(name.into()).into());
        }
        Ok(())
    }

    pub fn add_const(&mut self, name: ConstName, const_def: ConstDef) -> Result<()> {
        if self.const_defs.insert(name.into(), const_def).is_some() {
            return Err(ErrorKind::DuplicateConstName(name.into()).into());
        }
        Ok(())
    }
}

/// A `Program` is the input to the analysis engine, consisting of a collection of modules
/// and entry points.
///
/// Each entry point has an associated main function, which must have signature `() -> ()`.
pub struct Program {
    pub(crate) mods: BTreeMap<ModNameBuf, ModDef>,
    pub(crate) entry_points: BTreeMap<EntryPointNameBuf, (ModNameBuf, FuncNameBuf)>,
}

impl Program {
    pub fn to_source_string(&self) -> String {
        render_api_ir::render_program_to_string(self)
    }
}

pub struct ProgramBuilder {
    mods: BTreeMap<ModNameBuf, ModDef>,
    entry_points: BTreeMap<EntryPointNameBuf, (ModNameBuf, FuncNameBuf)>,
}

impl Default for ProgramBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl ProgramBuilder {
    pub fn new() -> Self {
        Self {
            mods: BTreeMap::new(),
            entry_points: BTreeMap::new(),
        }
    }

    pub fn build(self) -> Result<Program> {
        Ok(Program {
            mods: self.mods,
            entry_points: self.entry_points,
        })
    }

    pub fn add_mod(&mut self, name: ModName, mod_def: ModDef) -> Result<()> {
        match self.mods.entry(name.into()) {
            Entry::Occupied(entry) => Err(ErrorKind::DuplicateModName(entry.key().clone()).into()),
            Entry::Vacant(entry) => {
                entry.insert(mod_def);
                Ok(())
            }
        }
    }

    pub fn add_entry_point(
        &mut self,
        name: EntryPointName,
        func_mod: ModName,
        func: FuncName,
    ) -> Result<()> {
        match self.entry_points.entry(name.into()) {
            Entry::Occupied(entry) => {
                Err(ErrorKind::DuplicateEntryPointName(entry.key().clone()).into())
            }
            Entry::Vacant(entry) => {
                entry.insert((func_mod.into(), func.into()));
                Ok(())
            }
        }
    }
}

// Output API:

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum UpdateMode {
    Immutable,
    InPlace,
}

pub const SPEC_HASH_BYTES: usize = 32;

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct FuncSpec(pub [u8; SPEC_HASH_BYTES]);

/// The solution table for an individual specialization.
pub struct FuncSpecSolutions {
    // TODO: eliminate the RC here (this will require introducing a lifetime, and is therefore a
    // breaking API change)
    func_def: Rc<FuncDef>,
    solution: analyze::FuncSolution,
}

impl FuncSpecSolutions {
    pub fn callee_spec(&self, var: CalleeSpecVar) -> Result<FuncSpec> {
        // TODO: The clone here is unnecessary -- avoid it!
        // (might require something like a transmute)
        match self
            .func_def
            .builder
            .expr_builder
            .callee_spec_vars
            .get_by_val(&var.into())
        {
            Some(id) => Ok(self.solution.callee_specs[id]),
            None => Err(ErrorKind::CalleeSpecVarNotFound(var.into()).into()),
        }
    }

    pub fn update_mode(&self, var: UpdateModeVar) -> Result<UpdateMode> {
        // TODO: The clone here is unnecessary -- avoid it!
        // (might require something like a transmute)
        match self
            .func_def
            .builder
            .expr_builder
            .update_mode_vars
            .get_by_val(&var.into())
        {
            Some(id) => Ok(self.solution.update_modes[id]),
            None => Err(ErrorKind::UpdateModeVarNotFound(var.into()).into()),
        }
    }
}

/// Zero or more specializations for a single function, and the solution table for each
/// specialization.
pub struct FuncSolutions {
    spec_solutions: BTreeMap<FuncSpec, FuncSpecSolutions>,
}

impl FuncSolutions {
    pub fn specs(&self) -> impl Iterator<Item = &FuncSpec> {
        self.spec_solutions.keys()
    }

    pub fn spec(&self, spec: &FuncSpec) -> Result<&FuncSpecSolutions> {
        if let Some(solution) = self.spec_solutions.get(spec) {
            Ok(solution)
        } else {
            Err(ErrorKind::FuncSpecNotFound(*spec).into())
        }
    }
}

/// The solution table for a constant definition.
///
/// Note that, unlike functions, constant definitions cannot have multiple specializations.
pub struct ConstSolutions {
    const_def: ConstDef,
    callee_specs: IdVec<CalleeSpecVarId, FuncSpec>,
}

impl ConstSolutions {
    pub fn callee_spec(&self, var: CalleeSpecVar) -> Result<FuncSpec> {
        // TODO: The clone here is unnecessary -- avoid it!
        // (might require something like a transmute)
        match self
            .const_def
            .builder
            .expr_builder
            .callee_spec_vars
            .get_by_val(&var.into())
        {
            Some(id) => Ok(self.callee_specs[id]),
            None => Err(ErrorKind::CalleeSpecVarNotFound(var.into()).into()),
        }
    }

    pub fn update_mode(&self, var: UpdateModeVar) -> Result<UpdateMode> {
        // TODO: The clone here is unnecessary -- avoid it!
        // (might require something like a transmute)
        match self
            .const_def
            .builder
            .expr_builder
            .update_mode_vars
            .get_by_val(&var.into())
        {
            Some(_id) => Ok(UpdateMode::Immutable),
            None => Err(ErrorKind::UpdateModeVarNotFound(var.into()).into()),
        }
    }
}

/// Specializations and solution tables for a single module.
pub struct ModSolutions {
    funcs: BTreeMap<FuncNameBuf, FuncSolutions>,
    consts: BTreeMap<ConstNameBuf, ConstSolutions>,
}

impl ModSolutions {
    pub fn func_solutions(&self, func: FuncName) -> Result<&FuncSolutions> {
        // TODO: The clone here is unnecessary -- avoid it!
        // (might require something like a transmute)
        match self.funcs.get(&func.into()) {
            Some(func_solutions) => Ok(func_solutions),
            None => Err(ErrorKind::FuncNotFound(func.into()).into()),
        }
    }

    pub fn const_solutions(&self, const_: ConstName) -> Result<&ConstSolutions> {
        // TODO: The clone here is unnecessary -- avoid it!
        match self.consts.get(&const_.into()) {
            Some(const_solutions) => Ok(const_solutions),
            None => Err(ErrorKind::ConstNotFound(const_.into()).into()),
        }
    }
}

/// Specializations and solution tables generated for the entire program.
pub struct Solutions {
    mods: BTreeMap<ModNameBuf, ModSolutions>,
    entry_points: BTreeMap<EntryPointNameBuf, (ModNameBuf, FuncNameBuf, FuncSpec)>,
}

impl Solutions {
    pub fn mod_solutions(&self, mod_: ModName) -> Result<&ModSolutions> {
        // TODO: The clone here is unnecessary -- avoid it!
        // (might require something like a transmute)
        match self.mods.get(&mod_.into()) {
            Some(mod_solutions) => Ok(mod_solutions),
            None => Err(ErrorKind::ModNotFound(mod_.into()).into()),
        }
    }

    pub fn entry_point_solution(
        &self,
        entry_point: EntryPointName,
    ) -> Result<(ModName, FuncName, FuncSpec)> {
        // TODO: The clone here is unnecessary -- avoid it!
        // (might require something like a transmute)
        match self.entry_points.get(&entry_point.into()) {
            Some((mod_name, func_name, spec)) => {
                Ok((mod_name.borrowed(), func_name.borrowed(), *spec))
            }
            None => Err(ErrorKind::EntryPointNotFound(entry_point.into()).into()),
        }
    }
}

// TODO: Remove this; it's only used in obsolete logic for populating const definitions with trivial
// solutions
fn populate_specs(
    callee_spec_var_ids: Count<CalleeSpecVarId>,
    vals: &OpGraph<ValueId, Op>,
) -> IdVec<CalleeSpecVarId, FuncSpec> {
    let mut results = IdVec::filled_with(callee_spec_var_ids, || None);
    for val_id in vals.count().iter() {
        if let Op::Call {
            callee_spec_var,
            callee_mod,
            callee,
        } = vals.node(val_id).op
        {
            replace_none(
                &mut results[callee_spec_var],
                hash_func_name(callee_mod.borrowed(), callee.borrowed()),
            )
            .unwrap();
        }
    }
    results.into_mapped(|_, spec| spec.unwrap())
}

fn solve_with(
    api_program: Program,
    analysis: impl for<'a> FnOnce(TypeCache, &'a ir::Program) -> analyze::ProgramSolutions,
) -> Result<Solutions> {
    let (nc, tc, program) =
        preprocess::preprocess(&api_program).map_err(ErrorKind::PreprocessError)?;

    let mut solutions = analysis(tc, &program);

    Ok(Solutions {
        mods: api_program
            .mods
            .into_iter()
            .map(|(mod_name, mod_def)| {
                let mod_sols = ModSolutions {
                    funcs: mod_def
                        .func_defs
                        .into_iter()
                        .map(|(func_name, func_def)| {
                            // TODO: avoid the clones here
                            let func_id = nc
                                .funcs
                                .get_by_val(&(mod_name.clone(), func_name.clone()))
                                .unwrap();
                            let func_def = Rc::new(func_def);
                            let func_sols = FuncSolutions {
                                spec_solutions: std::mem::take(
                                    &mut solutions.funcs.solutions[func_id],
                                )
                                .into_iter()
                                .map(|(spec, solution)| {
                                    (
                                        spec,
                                        FuncSpecSolutions {
                                            func_def: func_def.clone(),
                                            solution: solution.unwrap(),
                                        },
                                    )
                                })
                                .collect(),
                            };
                            (func_name, func_sols)
                        })
                        .collect(),
                    consts: mod_def
                        .const_defs
                        .into_iter()
                        .map(|(const_name, const_def)| {
                            // TODO: This is left over from the original stub implementation, and
                            // generates incorrect callee specialization hashes!
                            let callee_specs = populate_specs(
                                const_def.builder.expr_builder.callee_spec_vars.count(),
                                &const_def.builder.expr_builder.vals,
                            );
                            (
                                const_name,
                                ConstSolutions {
                                    const_def,
                                    callee_specs,
                                },
                            )
                        })
                        .collect(),
                };
                (mod_name, mod_sols)
            })
            .collect(),
        entry_points: api_program
            .entry_points
            .into_iter()
            .map(|(entry_point_name, (mod_name, func_name))| {
                let entry_point_id = nc.entry_points.get_by_val(&entry_point_name).unwrap();
                let spec = solutions.entry_points[entry_point_id];
                (entry_point_name, (mod_name, func_name, spec))
            })
            .collect(),
    })
}

/// Solve for optimized update modes and function specializations
pub fn solve(api_program: Program) -> Result<Solutions> {
    solve_with(api_program, analyze::analyze)
}

/// Return a "trivial" solution for the program, setting every update mode to `Immutable`.
///
/// This function does not perform any expensive analysis, but it does typecheck the input program,
/// so it can be useful for verifying the correctness of a generated program.
pub fn solve_trivial(api_program: Program) -> Result<Solutions> {
    solve_with(api_program, |_, program| analyze::analyze_trivial(program))
}

// TODO: Remove this; it's only used in obsolete logic for populating const definitions with trivial
// solutions
fn hash_bstr(hasher: &mut Sha256, bstr: &[u8]) {
    let header = (bstr.len() as u64).to_le_bytes();
    hasher.update(&header);
    hasher.update(bstr);
}

// TODO: Remove this; it's only used in obsolete logic for populating const definitions with trivial
// solutions
fn hash_func_name(mod_: ModName, func: FuncName) -> FuncSpec {
    let mut hasher = Sha256::new();
    hash_bstr(&mut hasher, mod_.0);
    hash_bstr(&mut hasher, func.0);
    FuncSpec(hasher.finalize().into())
}
